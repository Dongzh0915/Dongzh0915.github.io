<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言浅学-运算符、表达式和语句</title>
      <link href="/2023/05/12/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/05/12/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>上一篇博客我们结束了对格式化字符串的输入输出的介绍和学习，这一篇博客我们将学习如何来处理数据，处理方式：算数运算、比较值的大小、修改变量、各种逻辑的组合关系等。</p><p><strong>Tip：此篇中我们还学习循环这个编程中最强大的特性。</strong></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>为什么我们需要使用循环，因为若是完成单一的工作，编写程序的工作量远不如人完成的快速有效率，计算机需要帮助我们完成的就是重复计算的工作，C中有相当多的方法可以去做重复计算，这里先简单的介绍一种——while循环。</p><p>如下所示，在有或没有循环两种情况下的代码的效率：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121448492.png"></p><p>无循环，只能输出单个的结果。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121459096.png"></p><p>加入while循环，可以输出多个结果。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121503058.png"></p><p>从这里我们可以得出结论，在进行重复运算时，计算机相较于人有显著的优势。</p><p>while循环的原理：</p><p>当程序第一次到达循环时，会检查圆括号中的条件是否为真，在上述例子中条件表达式：shoe &lt; 18.5。初始鞋码为3.0，条件为真，程序将进入循环执行，将尺码转化为英寸，进行打印结果，在最后给shoe增加1.0，返回while入口检查条件，while下两个花括号括起来的称为块。返回入口时会再次进行判断，直至循环结束。</p><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><p>在C中使用运算符表示算数运算，除开基本运算符以外，C没有指数运算符，不过C标准库提供一个<strong>pow（）函数</strong>用于指数运算：pow（3.5， 2.2）表示3.5的2.2次幂。</p><p><strong>Tip：在使用Pow（）函数时需先导入math.h的头文件，且在编译时需要在gcc mi.c -o mi 后加上 -lm才能编译成功。（链接math头文件）。</strong></p><h2 id="赋值运算符：-x3D"><a href="#赋值运算符：-x3D" class="headerlink" title="赋值运算符：&#x3D;"></a>赋值运算符：&#x3D;</h2><p>对于这个运算符应该都不陌生，不是常规数学中的等于号意味着相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bmw = <span class="number">2000</span>；</span><br></pre></td></tr></table></figure><p>上述语句就是把2000这个数值赋给bmw这个变量，赋值行从右往左进行。</p><p>变量名和变量值的区别看似区别不大，那么下面这个语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>这在数学上来说是完全行不通的，但是在赋值语句中就是常规的对变量加1并且赋值给 原变量的过程。在编写代码的过程中，&#x3D; 号左侧必须是一个变量名，右侧是一个常量或者表达式。</p><p><strong>几个术语：数据对象、左值、右值和运算符</strong></p><p>数据对象：存储值的数据存储区域称为数据对象。一般使用变量名来标识对象，还有指定数组的元素、结构的成员、使用指针表达式等。（房间）</p><p>左值：用于标识特定数据对象的名称或者表达式。（房间号）</p><p>前篇提到过的 const 限定符也是变量名却不能被赋值，所以左值就变成了可修改的左值。</p><p>右值：指能赋值给可修改左值的量，且本身不是左值。可以是常量、变量或者可求值的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ex;</span><br><span class="line"><span class="type">int</span> why;</span><br><span class="line"><span class="type">int</span> zee;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TWO = <span class="number">2</span>;</span><br><span class="line">why = <span class="number">42</span>;</span><br><span class="line">zee = why;</span><br><span class="line">ex = TWO * (why + zee);</span><br></pre></td></tr></table></figure><p>一般来说其他语言会回避程序的三重赋值，但是在C中完全没问题。</p><h2 id="加法运算符："><a href="#加法运算符：" class="headerlink" title="加法运算符：+"></a>加法运算符：+</h2><p>用于加法运算，使得两侧的值相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">4</span> + <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>输出的是24，而不是表达式 4 + 20。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">income = salary + bribes;</span><br></pre></td></tr></table></figure><p>这样的表达式也是可以的，程序会读取右边变量的值并将其相加，然后把和赋值给income。</p><h2 id="减法运算符："><a href="#减法运算符：" class="headerlink" title="减法运算符：-"></a>减法运算符：-</h2><p>同加法运算符理，这两个运算符被称为二元运算符，即需要两个运算符才能完成操作。</p><h2 id="符号运算符"><a href="#符号运算符" class="headerlink" title="符号运算符"></a>符号运算符</h2><p>减号还可以用于标记一个值的代数符号。例如，执行下面的语句后，值会变成12：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rocky = <span class="number">-12</span>;</span><br><span class="line">smokey = -rocky;</span><br></pre></td></tr></table></figure><p>以这种方式使用的负号被称为一元运算符。</p><p><strong>Tip：在最新的标准中，增加了+的一元运算符，仅仅是编译不会报错。</strong></p><h2 id="乘法运算符："><a href="#乘法运算符：" class="headerlink" title="乘法运算符：*"></a>乘法运算符：*</h2><p>符号*表示乘法，并将结果进行赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cm = <span class="number">2.54</span> * inch;</span><br></pre></td></tr></table></figure><p>在C中没有平方函数，我们就可以使用乘法来计算平方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d %6d\n&quot;</span>, num, num * num);</span><br><span class="line">        num = num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另外一个在棋盘中放麦粒也是类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARES 64 <span class="comment">// 棋盘中的方格数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> CROP = <span class="number">2E16</span>; <span class="comment">// 世界小麦年产谷粒数</span></span><br><span class="line"><span class="type">double</span> current, total;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;square grains total &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fraction of \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; added grains &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world total\n&quot;</span>);</span><br><span class="line">total = current = <span class="number">1.0</span>; <span class="comment">/* 从1颗谷粒开始 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d %13.2e %12.2e %12.2e\n&quot;</span>, count, current,</span><br><span class="line">total, total / CROP);</span><br><span class="line"><span class="keyword">while</span> (count &lt; SQUARES)</span><br><span class="line">&#123;</span><br><span class="line">count = count + <span class="number">1</span>;</span><br><span class="line">current = <span class="number">2.0</span> * current; <span class="comment">/* 下一个方格谷粒翻倍 */</span></span><br><span class="line">total = total + current; <span class="comment">/* 更新总数 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d %13.2e %12.2e %12.2e\n&quot;</span>, count, current,</span><br><span class="line">total, total / CROP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中还运用到了while循环。</p><h2 id="除法运算符：-x2F"><a href="#除法运算符：-x2F" class="headerlink" title="除法运算符：&#x2F;"></a>除法运算符：&#x2F;</h2><p>C中使用符号&#x2F;来表示除法，左侧属于被除数，右侧属于除数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four = <span class="number">12.0</span>/<span class="number">3.0</span>；</span><br></pre></td></tr></table></figure><p><strong>Tip：在C语言中，整数除法结果会有小数部分被丢弃，这一过程被称为截断。</strong></p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 5/4 is %d \n&quot;</span>, <span class="number">5</span> / <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 6/3 is %d \n&quot;</span>, <span class="number">6</span> / <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 7/4 is %d \n&quot;</span>, <span class="number">7</span> / <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;floating division: 7./4. is %1.2f \n&quot;</span>, <span class="number">7.</span> / <span class="number">4.</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mixed division: 7./4 is %1.2f \n&quot;</span>, <span class="number">7.</span> / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip：C语言中对于负数的截断一般会舍弃小数部分，称为趋零截断，如-3.8会变成-3。</strong></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-系统管理命令</title>
      <link href="/2023/04/24/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/04/24/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中我们总结了处理文件和目录的指令学习，接下来我们来对Linux的系统管理命令展开学习，这也是我们在开始脚本编程之前需要学习的，如何通过命令行的命令来探查系统内部信息。</p><h1 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h1><p>在Linux系统中最复杂的任务就是跟踪已经在运行的程序，如何探查？</p><h2 id="探查进程"><a href="#探查进程" class="headerlink" title="探查进程"></a>探查进程</h2><p>当程序在Linux系统运行时，我们称之为进程（process）。</p><p>命令：ps </p><p>功能：输出运行在系统上的所有程序的许多信息。</p><p>缺点：稳健而带来的就是复杂性，参数过多（详见man ps），只能显示特定时间点的信息。</p><p>默认情况下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300049523.png"></p><p>例子解析：输出显示了程序的进程ID（process ID，PID），运行的终端（TTY），进程已使用的CPU时间。</p><p><strong>Tip：ps 命令叫人头疼的地方在于它曾经有两个版本。每个版本都有自己的命令行参数集，这些参数控制着输出什么信息以及如何显示。最近，Linux开发人员已经将这两种ps命令格式合并到了单个ps命令中。</strong></p><p>Linux系统主要支持3种类型的命令行参数：</p><p>1.Unix风格的参数，前面加破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300057824.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300058087.png"></p><p>一般来说，我们并不需要记住所有的参数，常用的是ps -ef ；ps -l 这两个命令。</p><p>2.BSD风格的参数，前面不加破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300105635.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300107591.png"></p><p>如上所示，Unix和BSD类型的参数有很多重叠的地方。使用其中某种类型参数得到的信息也同样可以使用另一种获得。大多数情况下，你只要选择自己所喜欢格式的参数类型就行了。</p><p>3.GNU风格的参数，前面是双破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301344251.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301345346.png"></p><p>在GNU长参数中一个着实让人喜爱的功能就是–forest参数。它会显示进程的层级信息，并用ASCII字符绘出可爱的图表。如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301346827.png"></p><p>以上就是对三种风格的参数的简单介绍，我们只需要记住常用的几个命令即可。</p><p>ps -ef 所展示的扩展的信息包含以下几个方面：</p><p>UID：启动这些进程的用户。<br>PID：进程的进程ID。<br>PPID：父进程的进程号（如果该进程是由另一个进程启动的）。<br>C：进程生命周期中的CPU利用率。<br>STIME：进程启动时的系统时间。<br>TTY：进程启动时的终端设备。<br>TIME：运行进程需要的累计CPU时间。<br>CMD：启动的程序名称。</p><p>ps -l 指令多出的那些列：</p><p>F：内核分配给进程的系统标记。<br>S：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止）。<br>PRI：进程的优先级（越大的数字代表越低的优先级）。<br>NI：谦让度值用来参与决定优先级。<br>ADDR：进程的内存地址。<br>SZ：假如进程被换出，所需交换空间的大致大小。<br>WCHAN：进程休眠的内核函数的地址。</p><h2 id="实时监测进程"><a href="#实时监测进程" class="headerlink" title="实时监测进程"></a>实时监测进程</h2><p>ps命令虽然在收集运行在系统的进程信息时非常有用，缺点如上所述，为了解决特定时间点的问题，另一个命令就刚好合适：</p><p>命令：top</p><p>功能：实时显示进程信息</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301358009.png"></p><p>总体来说和ps命令并没有太大的不同，只是从特定时间点变成了实时。在默认情况下，top命令在启动的时候会按照使用CPU时间比例进行排序，键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。键入q可以退出top。</p><p>当我们找到了占用系统大部分资源的进程之后，我们就要开始结束这些进程了。</p><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>接上节所讲，作为系统的管理员，我们应该具备何时以及如何结束一个进程，在Linux进程中大多数是通过信号来通信：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301412584.png"></p><p>命令：kill </p><p>功能：该命令可以通过PID给进程发出信号终止进程。</p><p>缺点：默认情况下，kill会向命令行发送一个TERM信号，只能使用PID而不是命令名。</p><p>TERM信号告诉进程尽可能停止，若是有不服管教的进程需要我们强制终止，可以使用 -s 参数。若是要检查是否有效，可以再次运行ps 和 top 命令。</p><p>命令：killall</p><p>功能：该命令可以通过进程名而不是PID来结束进程，也支持通配符，在系统因为负载过大而变慢时很有用。</p><h1 id="监测磁盘空间"><a href="#监测磁盘空间" class="headerlink" title="监测磁盘空间"></a>监测磁盘空间</h1><p>系统管理员的另一个重要任务就是要监测系统磁盘的使用情况（也就是空间）。在Linux系统上有几个命令行命令用来帮助存储媒体：</p><h2 id="挂载存储媒体"><a href="#挂载存储媒体" class="headerlink" title="挂载存储媒体"></a>挂载存储媒体</h2><p>在文件管理中曾介绍Linux文件系统将所有的磁盘都并入一个虚拟目录下，在使用新的存储媒体之前需要把它放在虚拟目录下，这就叫做挂载。</p><p>现在大多数的系统都能自动挂载，若是用的发行版不支持自动挂载，就必须手动挂载了。</p><p>命令：mount</p><p>功能：挂载媒体，默认情况下也可以用来显示挂载的设备列表</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301427346.png"></p><p>mount命令主要提供四部分信息：</p><p>1.媒体的设备文件名</p><p>2.媒体挂载到虚拟目录的挂载点</p><p>3.文件系统类型</p><p>4.已挂载媒体的访问状态</p><p>手动挂载设备，需要以root用户登录，或者是以root用户运行sudo命令</p><p>手动命令：mount -t type device directory</p><p>type参数指定了磁盘被格式化的文件系统类型。</p><p><strong>Tip：手动挂载的磁盘要先格式化才能进行挂载。</strong></p><p>mount命令的参数：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301444408.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301444867.png"></p><p>命令：umount</p><p>功能：从Linux系统上移除一个可移动设备，就要先卸载。</p><p>实际格式：umount  [directory | device]</p><p>若是有任何程序正在使用设备上的文件，系统是不会允许我们卸载它。</p><h2 id="df命令的使用"><a href="#df命令的使用" class="headerlink" title="df命令的使用"></a>df命令的使用</h2><p>学习挂载之后，我们需要查看设备还剩余多少的磁盘空间，df命令就显得很方便。</p><p>命令：df</p><p>功能：显示每个有数据的已挂载文件系统。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301504380.png"></p><p><strong>Tip：Linux系统后台一直有进程来处理文件或使用文件。df命令的输出值显示的是Linux系统认为的当前值。有可能系统上有运行的进程已经创建或删除了某个文件，但尚未释放文件。这个值是不会算进闲置空间的。</strong></p><h2 id="du命令的使用"><a href="#du命令的使用" class="headerlink" title="du命令的使用"></a>du命令的使用</h2><p>df命令只能告诉我们宏观的磁盘的存储空间，并不能告诉我们细分的文件或者特定的目录，这个时候就要用到du命令来显示具体的占用的空间的文件。</p><p>命令：du</p><p>功能：显示当前目录下的所有文件和目录。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301621919.png"></p><p>du命令的几个参数：</p><p>-c：显示所有已列出文件总的大小。<br>-h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。<br>-s：显示每个输出参数的总计。</p><p>在我们查看了具体的文件之后就是要对它们使用文件处理命令进行处理。</p><h1 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h1><p>结合上节所述，当我们有大量的数据时，一般来说很难提取到有用的信息，但是Linux系统提供了命令行工具来处理大量的数据，这些命令可以帮助我们更好的应对。</p><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p>命令：sort</p><p>功能：sort命令是对数据进行排序的。默认情况下，sort命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301630992.png"></p><p>缺点：默认情况下，sort命令会把数字当做字符来执行标准的字符排序，产生的输出可能根本就不是你要的。解决这个问题可用-n参数。</p><p>另一个常用的参数是 -M，按月排序，Linux的日志中经常会有时间戳来表明事件是什么时候发生的。</p><p>其他参数：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301636268.png"></p><p><strong>Tip：管道命令（|）将du命令的输出重定向到sort命令。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301643408.png"></p><h2 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h2><p>在海量的数据背景下，我们通常需要在大文件中找到一行或几行数据即可，这个时候我们就需要搜索数据了。</p><p>命令：grep  pattern  file</p><p>功能：在文件中查找数据。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301650375.png"></p><p>若是要进行反向搜索，加入参数 -v 即可。</p><p>显示匹配模式的行的行号，加入 -n 参数即可。</p><p>若想知道有多少行含有匹配模式，加入参数 -c 。</p><p>若要指定多个匹配模式，可使用 -e 模式。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301653653.png"></p><p><strong>Tip：在默认模式下，也可使用正则表达式来定义查找匹配的模式。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301655071.png"></p><h2 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h2><p>在windows系统中我们经常使用的压缩文件就是zip文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301700599.png"></p><p><strong>Tip：compress文件压缩已经很少在Linux系统中见到了，基本现在都是使用gzip。</strong></p><p>命令：gzip；gzcat；gunzip</p><p>功能：压缩文件；查看压缩文件的内容；解压文件。</p><p>缺点：该命令只能压缩一个文件，不能将多个文件压缩进一个压缩包。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301703112.png"></p><p>gzip命令可以一次性指定多个文件名，也可以使用通配符来一次性批量压缩文件。</p><h2 id="归档数据"><a href="#归档数据" class="headerlink" title="归档数据"></a>归档数据</h2><p>为了解决压缩数据中不能同时压缩多个文件的缺点，还有另外的命令来解决这个问题。</p><p>命令：tar function [options] objects1 objects2</p><p>功能：能将多个文件在磁带设备中归档到一个文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301713823.png"></p><p><strong>Tip：文件名以.tgz结尾。这些是gzip压缩过的tar文件可以用命令tar -zxvf filename.tgz来解压。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301718385.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此篇博客是学完系统管理之后一些要点的总结，下一篇将是对Linux shell及其使用。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-字符串的格式化输入输出</title>
      <link href="/2023/04/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2023/04/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在总结完数据类型之后，我们就开始对printf（）和scanf（）中都有的格式化字符串进行学习和探讨。</p><h1 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h1><p>字符串是一个或多个字符的序列，一般使用双引号将内容括起来，正如单引号对于字符一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Zing went the strings of my heart!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="char类型数组和null字符"><a href="#char类型数组和null字符" class="headerlink" title="char类型数组和null字符"></a>char类型数组和null字符</h2><p>在C语言中没有专门用于储存字符串的变量类型，一般被储存在char类型的数组中，每个单元储存一个字符。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304191340852.png"></p><p>上述数组的末尾的字符\0，这是空字符（null字符），C语言用它标记字符串的结束，空字符不是数字0，它是非打印字符，其ASCII码值是0。C的字符串一定是以空字符结束，也就是说数组的容量至少要比存储字符串的字符数多一。</p><p>数组：一行连续的多个储存单元，同类型数据元素的有序序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">40</span>];</span><br></pre></td></tr></table></figure><p>char是声明变量的数据类型，name是数组的名字，方括号表明这是一个数组，40则是说明该数组的数量。</p><h2 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h2><p>转换说明：%s</p><p>我们不需要把空字符放到字符串结尾，scanf（）在读取输入时就已经完成这项工作了，编译器也会在末尾加上空字符。</p><p><strong>Tip：scanf（）只会读取连续的字符，从第一个非空白字符起到空白字符结束。下面将会进行详尽阐述</strong></p><p>字符串和字符的区别：”x” 和 ‘x’ 就是不一样的，前者是char数组，后者是char类型；前者在末尾还有空字符，而后者则没有。</p><h2 id="Strlen（）函数"><a href="#Strlen（）函数" class="headerlink" title="Strlen（）函数"></a>Strlen（）函数</h2><p>在数据类型的博客中我们介绍了一个sizeof运算符，它以字节为单位给出对象的大小。strlen（）函数给出字符串的字符长度，因为一个字节储存一个字符，但其实这两种方法应用字符串的结果并不相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRAISE <span class="string">&quot;You are an extraordinary being.&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">40</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK, %s.%s\n&quot;</span>, name, PRAISE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your name of %zd letters occupies %zd memory cells.\n&quot;</span>, <span class="built_in">strlen</span>(name), <span class="keyword">sizeof</span>(name));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The phrase of praise has %zd letters &quot;</span>, <span class="built_in">strlen</span>(PRAISE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;and occpies %zd memory cells.\n&quot;</span>, <span class="keyword">sizeof</span>(PRAISE));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中 sizeof 运算符报告name数组有40个存储单元，但是只有前11个用来存储，所以strlen（）得出的结果是11。一般来说 sizeof 运算符给出的数更大，因为它要把字符串末尾的空字符也计算在内。</p><p><strong>Tip：sizeof 运算符使用圆括号的场景，取决于运算对象是类型还是特定量。运算对象是类型，则必不可少；若是特定量则可以省略，但还是建议在所有情况加上（）。</strong></p><h1 id="常量和预处理器"><a href="#常量和预处理器" class="headerlink" title="常量和预处理器"></a>常量和预处理器</h1><p>在程序中，我们使用一个常量一般都是直接键入，虽然无需声明，但是不够好，我们可以使用符号常量。一般使用符号常量有两种方法：</p><p>1.声明一个变量，给变量赋予所需的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> tax;</span><br><span class="line">tax = <span class="number">0.015</span>;</span><br></pre></td></tr></table></figure><p>虽然这样做提供了一个符号名，但是 tax 本质是一个变量，复杂的程序在运行中可能会无意改变它的值。</p><p>2.C预处理器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAX 0.015</span></span><br></pre></td></tr></table></figure><p>在前面博客介绍过预处理器是如何使用 #include 包含其他文件信息，但同时预处理器也可以用来定义常量。</p><p>通用格式：#define <em>NAME</em>  <em>value</em></p><p>#define 指令还可以定义字符和字符串常量，前者单引号，后者双引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BEEP &#x27;\a&#x27;</span><br><span class="line">#define TEE &#x27;T&#x27;</span><br><span class="line">#define ESC &#x27;\033&#x27;</span><br><span class="line">#define OOPS &quot;Now you have done it!&quot;</span><br></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>在C90标准中新增了const关键字，用于限定一个变量为只读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>num 这个值成为一个只读值，不能更改。</p><p><strong>Tip：const 定义的是一个只读变量，而不是常量。</strong></p><p>后面的博客再来详细介绍。</p><h2 id="明示常量"><a href="#明示常量" class="headerlink" title="明示常量"></a>明示常量</h2><p>C头文件limits.h 和 floar.h 分别提供了整数类型和浮点类型大小限制相关的详细信息。</p><p>在limits.h头文件中包含以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX +32767</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MIN -32768</span></span><br></pre></td></tr></table></figure><p>下表是limits.h中一些明示常量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201515931.png"></p><p>类似的，下表是一些float.h中的一些明示常量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201519224.png"></p><h1 id="printf（）和scanf（）"><a href="#printf（）和scanf（）" class="headerlink" title="printf（）和scanf（）"></a>printf（）和scanf（）</h1><p>这个两个函数对于C语言学习者来说并不陌生，一个输入函数，一个输出函数；工作原理几乎相同，都是使用格式化字符串和参数列表。</p><h2 id="printf（）函数"><a href="#printf（）函数" class="headerlink" title="printf（）函数"></a>printf（）函数</h2><p>在请求printf（）函数打印数据的指令要与待打印数据的类型相匹配。打印整数使用%d，打印字符要用%c，这些符号被称为转换说明：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201529890.png"></p><h2 id="printf（）函数的使用"><a href="#printf（）函数的使用" class="headerlink" title="printf（）函数的使用"></a>printf（）函数的使用</h2><p>打印输出函数的使用就需要在这里赘述了，简单说一下格式即可：</p><p>格式：printf（格式化字符串，待打印项1，待打印项2，…）;</p><p>其中待打印项1等都是需要打印的，它们可以是变量，常量，甚至是打印之前要计算的表达式，前提是格式化字符串应当包含每个待打印项对应的转换说明；数量和类型都要对应。</p><p>若是只打印短语或句子，就不需要使用任何转换说明；如果只打印数据，也不用加入说明文字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%d\n&quot;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="number">2</span> * cost);</span><br></pre></td></tr></table></figure><p><strong>Tip：由于%在printf（）函数中拿来标识转换说明了，因此打印%符号就需要用别的方法，然而我们之前有使用过 \ （反斜杠）的转义字符来表示符号，但在这里并不适用，我们只需要使用%%即可。</strong></p><h2 id="printf（）的转换说明修饰符"><a href="#printf（）的转换说明修饰符" class="headerlink" title="printf（）的转换说明修饰符"></a>printf（）的转换说明修饰符</h2><p>在%和转换字符之间插入修饰符可以修饰基本的转换说明，下面列出一些可作为修饰符的合法字符，若要同时插入多个字符，也得与下表顺序相同。（并非所有的组合都可行）</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201600738.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201602465.png"></p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGES 959</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%2d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%-10d*\n&quot;</span>, PAGES);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展示的是对于字段宽度以及修饰符的作用。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201614801.png"></p><p>上面是对于整型来说的，下面我们看看对于浮点型来说，修饰符又有那些作用呢:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> RENT <span class="number">3852.99</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%e*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%4.2f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%3.1f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10.3f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10.3E*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%+4.2f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%010.2f*\n&quot;</span>, RENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序输出结果如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304211740883.png"></p><p>该程序中使用了const 关键字，限定变量为只读。</p><p>第一个转换说明%f ，在这种情况下，字段宽度和小数点后面的位数均为系统默认设置，小数点后打印6位数字。</p><p>第二个转换说明%e 无需过多的赘述，在数据类型的博客中有详细讲解。</p><p>第四个和第六个例子分别对输出结果进行四舍五入。</p><p>第七个转换说明中包含了+标记，这使得打印的值前面多了一个代数符号；最后一个转换说明的 0 标记使得打印的值前面用 0 填充来满足字段的要求。</p><p>剩下的一些其他格式的数据在这里就不逐个展示了。</p><p><strong>Tip：在整型数据中使用精度（%5.3d）生成足够的前导0 用来满足最小位数的要求，若是精度和 0 同时出现，0 标记会被忽略。</strong></p><p>对于字符串格式来说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLURB <span class="string">&quot;Authentic imitation&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%2s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%24s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%24.5s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%-24.5s]\n&quot;</span>, BLURB);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然第一个转换说明是%2s ，但是字段会被扩大为可容纳所有字符的格式，另 . 5是告诉打印函数只打印5个字符，- 号则是使得文本左对齐输出。</p><h2 id="转换说明的意义"><a href="#转换说明的意义" class="headerlink" title="转换说明的意义"></a>转换说明的意义</h2><p>在介绍了这么多转换说明和修饰符之后，我们应该深入了解一下转换说明的存在意义，实际上转换说明就是把电脑中存储的二进制格式的值转换成我们所需的一系列字符。转换本质上是翻译说明，而非替换；无论输出格式如何多种多样，数据存储的方式都只有二进制一种。</p><p>转换说明会碰到的问题：</p><h3 id="1-转换不匹配："><a href="#1-转换不匹配：" class="headerlink" title="1.转换不匹配："></a>1.转换不匹配：</h3><p>通常我们打印一个 int 类型的值，我们可以使用%d ，%x ，%o ，类似的，打印float 类型的值，我们可以使用%f ，%e ，%g 。</p><p>在这个转换说明中可以着重看一下原码，反码和补码的概念，但是我们同样需要注意%u 不会把数字和符号进行区分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGES 336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORDS 65618</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">short</span> num = PAGES;</span><br><span class="line"><span class="type">short</span> mnum = -PAGES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num as short and unsigned short: %hd %hu\n&quot;</span>, num,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-num as short and unsigned short: %hd %hu\n&quot;</span>, mnum,mnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num as int and char: %d %c\n&quot;</span>, num, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WORDS as int, short, and char: %d %hd %c\n&quot;</span>,WORDS,WORDS,WORDS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码说的都是整型数据中的错误，若是错误出现在浮点型中时，出现的结果会更令人意想不到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n1 = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">double</span> n2 = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">long</span> n3 = <span class="number">2000000000</span>;</span><br><span class="line"><span class="type">long</span> n4 = <span class="number">1234567890</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1e %.1e %.1e %.1e\n&quot;</span>, n1, n2, n3, n4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld %ld\n&quot;</span>, n3, n4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld %ld %ld %ld\n&quot;</span>, n1, n2, n3, n4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行中除了n1和n2两个值之外，n3和n4这两个值输出都并不正常，这里我们就需要说到在printf（）函数中，float类型（4位字节）会变成double类型（8位字节）进行输出，使用%e 打印long类型（4位字节），除了查看本身的4位之外，还会额外查看相邻的4位字节，共同组成解释浮点数。即使n3 位数正确，最终得到的结果也是无意义的值。</p><p>在第三行中输出显示，printf（）函数即使使用正确的转换说明也可能会生成虚假的结果，其中的问题就出在了C语言的信息传递过程中。参数传递过程会因为系统和编译器的实现方式而出现变化。</p><p>上面程序的第三句输出，n1是作为double类型存储到栈的内存区域占8位字节，n2 同样也是占8位，n3 和 n4 各自占据了4位字节，然后才是函数根据不同的转换说明进行数据的读取，%ld 说明应该读取4个字节，然而前4个字节是n1 的前半部分，这样的读取就出现错误。n2 则是读取了n1 的后半部分。虽然用对了转换说明，却读不出正确的值。</p><p><strong>Tip：从这里可以看出计算机其实非常的死板，只能按部就班的完成指令</strong></p><h3 id="2-printf（）的返回值："><a href="#2-printf（）的返回值：" class="headerlink" title="2.printf（）的返回值："></a>2.printf（）的返回值：</h3><p>在C语言起始那篇博客中，我们介绍过大部分C语言函数都会有一个返回值，这是函数计算并且返回给主调程序的值，总之程序中可以把返回值像其他值一样使用。printf（）的返回值是函数打印之后的附带用途，一般很少用的到，一般是检查错误用到比较多。（写入文件的时候比较常用），若是一张CD拒绝写入时，程序采取相应的行动。要实现需要先了解 if 语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bph2o = <span class="number">212</span>;</span><br><span class="line"><span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">    rv = <span class="built_in">printf</span>(<span class="string">&quot;%d F is water&#x27;s boiling point.\n&quot;</span>, bph2o);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The printf() function printed %d characters.\n&quot;</span>,</span><br><span class="line">rv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序就展示了printf（）在正常运行时的返回值。计算了所有的字符数包括空格和不可见的换行符。</p><h3 id="3-打印较长的字符串"><a href="#3-打印较长的字符串" class="headerlink" title="3.打印较长的字符串"></a>3.打印较长的字符串</h3><p>在打印字符串时，我们经常会碰到较长的语句，在屏幕上不方便阅读，若是有空格、制表符、换行符等用于分隔不同的部分，C编译器会忽略他们，所以一条语句可以写成很多行，在不同部分之间输入空白即可。</p><p><strong>Tip：切记不能在双引号括起来的字符串中间断行，会产生报错。</strong></p><p>给字符串断行的三种方法：</p><p>1.我们可以使用多个printf（）语句，因为第一个字符串没有以\n字符结束，所以第二个字符串会紧跟第一个字符串的末尾。</p><p>2.用反斜杠（\）和Enter键组合的方式来断行，这使得光标移到下一行，而且字符串不会包含换行符。</p><p>3.ANSI C 引入的字符串连接，在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作一个字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s one way to print a &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;long string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s another way to print a \</span></span><br><span class="line"><span class="string">long string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s the newest way to print a &quot;</span></span><br><span class="line"><span class="string">&quot;long string.\n&quot;</span>); <span class="comment">/* ANSI C */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231633510.png"></p><h2 id="scanf（）的使用"><a href="#scanf（）的使用" class="headerlink" title="scanf（）的使用"></a>scanf（）的使用</h2><p>结束了printf（）函数的学习，接下来介绍一下scanf（）函数，C语言库中包含很多的输出函数，scanf（）是其中最通用的一个，因为它可以读取不同格式的数据，但是从键盘输入的都是文本字符：字母，数字和标点符号，要把字符依次转换成数值就是scanf（）函数需要做的事情，与printf（）所做的事情正好相反。</p><p><strong>Tip：printf（）整数、浮点数、字符串–&gt; 文本</strong></p><p>​           <strong>scanf（） 文本 –&gt; 整数、浮点数、字符串</strong></p><p>这两个函数的核心本质都是格式化字符串。</p><p>scanf（）函数中用的最多的是指向变量的指针，关于指针的内容后续再详细介绍，这里我们只需要知道两条规则：</p><p>1.如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;。</p><p>2.如果用scanf()把字符串读入字符数组中，不要使用&amp;。</p><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age; <span class="comment">// 变量</span></span><br><span class="line"><span class="type">float</span> assets; <span class="comment">// 变量</span></span><br><span class="line"><span class="type">char</span> pet[<span class="number">30</span>]; <span class="comment">// 字符数组，用于储存字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your age, assets, and favorite pet.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %f&quot;</span>, &amp;age, &amp;assets); <span class="comment">// 这里要使用&amp;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pet); <span class="comment">// 字符数组不使用&amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d $%.2f %s\n&quot;</span>, age, assets, pet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面包含了整型、浮点型和字符串三个数据类型。</p><p><strong>Tip：在scanf（）函数中唯一的例外是%c 转换说明，根据%c ，scanf（）会读取每个字符，包括空白。</strong></p><p>scanf（）函数所用的转换说明与printf（）函数几乎相同，主要的区别是对于float类型和double类型，printf（）都使用%f ，%e ，%g。而scanf（）函数仅仅把这几个用于float类型，对于double类型需要加上l 修饰符。</p><p>具体的转换说明如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231700976.png"></p><p>修饰符如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231702651.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231702338.png"></p><p><strong>Tip：若要同时使用多个修饰符需要严格按照修饰符的顺序。</strong></p><h3 id="从scanf（）看输入"><a href="#从scanf（）看输入" class="headerlink" title="从scanf（）看输入"></a>从scanf（）看输入</h3><p>scanf（）函数读取输入若是%d ，一开始会跳过所有的空白字符，直至遇到第一个非空白字符才开始读取，若是遇到数字或符号，继续读取，若还是数字继续，反之暂停。然后会把非数字字符返回给输入，也意味着下次读取会是上次丢弃的字符，这点很重要。</p><p>若是%d 遇到第一个非空白字符是A而不是数字，那么scanf（）函数就会一直卡在第一个转换说明这里。若是多个转换说明，C语言规定会在第一个出错处停止读取输入。</p><p>如果使用的是%s 转换说明，scanf（）会读取除了空白以外的所有字符。即非空白字符起，空白字符止。</p><p>C语言还有其他的输入函数，如 getchar（）和 fgets（）等。这两个函数更适合特殊的处理情况，未来碰到在详细介绍。</p><h3 id="格式化字符串中的普通字符"><a href="#格式化字符串中的普通字符" class="headerlink" title="格式化字符串中的普通字符"></a>格式化字符串中的普通字符</h3><p>scanf（）函数可以把普通字符放在格式化字符串里，除了空格字符外的普通字<br>符必须与输入字符串严格匹配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;n, &amp;m);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">88</span>,<span class="number">121</span></span><br><span class="line"><span class="number">88</span>, <span class="number">121</span></span><br><span class="line"><span class="number">88</span>,</span><br><span class="line"><span class="number">121</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d ,%d&quot;</span>, &amp;n, &amp;m);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">88</span>,<span class="number">121</span></span><br><span class="line"><span class="number">88</span> ,<span class="number">121</span></span><br><span class="line"><span class="number">88</span> , <span class="number">121</span></span><br></pre></td></tr></table></figure><p>上述代码就是输入一个数字，逗号，一个数字，逗号必须紧跟第一个数字，后面的间隔和空白并没有具体的要求。格式化字符串的空白意味着跳过下一个输入项前面的所有的空白。（所有的空白包括没有空格的情况）。</p><p><strong>Tip：那么对于%c 来说，在格式化字符串中添加一个空格字符会有所不同，如果把空格放到格式化字符串的%c之前，scanf（）会跳过非空白字符。若没有空格，那么会读取空白字符。</strong></p><h3 id="scanf（）的返回值"><a href="#scanf（）的返回值" class="headerlink" title="scanf（）的返回值"></a>scanf（）的返回值</h3><p>scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0。当scanf()检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。</p><h2 id="printf（）和scanf（）的-修饰符"><a href="#printf（）和scanf（）的-修饰符" class="headerlink" title="printf（）和scanf（）的*修饰符"></a>printf（）和scanf（）的*修饰符</h2><p>在这两个函数的修饰符中都有*修饰符，但是作用却完全不同。</p><p>在printf（）中，若是不想预先指定字段宽度，希望通过程序来指定，可以使用* 修饰符来代替字段宽度，但是需要一个参数告诉函数，字段宽度是多少，也就是说转换说明%*d，参数列表应包含 *和d对应的值。这同样适用于浮点数的指定精度和字段宽度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> width, precision;</span><br><span class="line"><span class="type">int</span> number = <span class="number">256</span>;</span><br><span class="line">    <span class="type">double</span> weight = <span class="number">242.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a field width:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;width);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The number is :%*d:\n&quot;</span>, width, number);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now enter a width and a precision:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;width, &amp;precision);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Weight = %*.*f\n&quot;</span>, width, precision, weight);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中程序中的width是字段宽度，number是待打印的数值。</p><p>scanf（）中的用法就和printf（）不同，把* 放在%和转换字符之间时，会使得scanf（）跳过相应的输出项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter three integers:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%*d %*d %d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The last integer was %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="printf（）用法提示"><a href="#printf（）用法提示" class="headerlink" title="printf（）用法提示"></a>printf（）用法提示</h2><p>在输出时想把数据打印成列，指定固定的字段宽度是很有用的，若是不指定的话，会显得数据显示的很杂乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, val1, val2, val3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%9d %9d %9d\n&quot;</span>, val1, val2, val3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>         <span class="number">234</span>        <span class="number">1222</span></span><br><span class="line"> <span class="number">4</span>           <span class="number">5</span>          <span class="number">23</span></span><br><span class="line"> <span class="number">6</span>          <span class="number">22</span>          <span class="number">34</span></span><br></pre></td></tr></table></figure><p>这样就会显得整齐不少，在两个转换说明之间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟一起输出。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此我们结束了对于这两个函数的使用包括修饰符等，也对数据类型进行了巩固，下一篇将进入运算符和表达式包括语句的学习。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>故障修复-虚拟机USB口不识别U盘</title>
      <link href="/2023/04/16/%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D-%E8%99%9A%E6%8B%9F%E6%9C%BAUSB%E5%8F%A3%E4%B8%8D%E8%AF%86%E5%88%ABU%E7%9B%98/"/>
      <url>/2023/04/16/%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D-%E8%99%9A%E6%8B%9F%E6%9C%BAUSB%E5%8F%A3%E4%B8%8D%E8%AF%86%E5%88%ABU%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>前因：在学习Linux系统管理命令时想尝试一下用 mount 命令将U盘挂载到虚拟机中，然而将U盘插入电脑后，虚拟机并无任何反应，开始百度查找原因，基本可以确定是VMware USB Arbitration Service 服务未开启的问题。</p><p>找到疑似原因，就开始尝试修复，首先win + r 键，输入service.msc，回车进入服务，找到上述的USB服务并开启服务，在这里我们遇到了第一个问题：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161433611.png"></p><p>接着在百度上查找原因，大部分说的是AMD主板这类的问题，尝试过后发现效果并不是很理想，本着除根需除净的原则，还是选择将VM虚拟机卸载重装。</p><p>在尝试过程中有个使用exe文件重装修复的方法，尝试之后会出现以下的问题：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161438609.png"></p><p>这也是博主尝试的最后一种方法，实在修不动，选择重装大法了。（当然重装之后还是使用修复的方法对USB接口服务进行修复）</p><p><strong>Tip：VMx86驱动程序的版本不匹配，基本就是以前安装过的VM虚拟机卸载的不干净导致脚本文件产生冲突。</strong></p><p>重装VM虚拟机的过程中，又出现了一个问题：无法安装服务，请确保您有足够的权限安装系统文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161442321.png"></p><p>这个问题解决详情可见<a href="https://blog.csdn.net/qq_55868479/article/details/124046593">无法安装服务“VMware Authorization Service” ，请确保您有足够的权限安装系统，如何解决？_神偷克星的博客-CSDN博客</a></p><p>最后博主也是用CCleaner清除干净注册表之后成功安装。</p><p><strong>Tip：在清除注册表之后最重要的一点：重启电脑！重启电脑！重启电脑！</strong></p><p>然而在重新安装完成之后，插入U盘仍然没有任何反应，这时候就可以使用上面修复的手段了：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161449782.png"></p><p>点击修复，再次进入服务启用VMware USB Arbitration Service 服务即可：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161451393.png"></p><p>可以看到该服务已经启动成功了。</p><p>此时我们将U盘插入电脑，就会看到以下画面：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161452158.png"></p><p>圆满修复。</p><p><strong>在这篇博客完成之前，博主Picgo出现图片上传的网络问题，一开始以为是VPN的故障，查完发现Github的token有时长限制，具体修复如下：</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161455368.png"></p><p>将Expiration的期限改为无限制，重新生成令牌即可。</p>]]></content>
      
      
      <categories>
          
          <category> 系统故障 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-数据类型总结</title>
      <link href="/2023/04/14/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/14/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中我们详细介绍了C语言中的基础数据类型和相关转换说明的原理剖析，那么这一篇博客对数据类型的具体使用作简单介绍和总结。</p><h1 id="使用数据类型"><a href="#使用数据类型" class="headerlink" title="使用数据类型"></a>使用数据类型</h1><p>我们在编写程序的时候，应当注意合理选择所需的变量及其类型，通常来说，使用int或者float类型来选择数字，char类型表示字符。</p><p><strong>Tip：使用变量之前必须先声明，且选择有意义的变量名，若是需要初始化变量，应当与类型匹配。</strong></p><p>声明（初始化）方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> apple = <span class="number">3</span>；<span class="comment">/*正确*/</span></span><br><span class="line"><span class="type">int</span> bananas = <span class="number">4.0</span>;<span class="comment">/*不好的方式*/</span></span><br></pre></td></tr></table></figure><p>若是我们使用一个类型的数值初始化给不同类型的变量的时候，编译器会首先把值转换成与变量匹配的类型，会导致数据错误以及丢失。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost = <span class="number">12.99</span>;<span class="comment">/*用double类型值初始化整型变量*/</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926536</span>;<span class="comment">/*用double类型的值初始化单精度浮点型*/</span></span><br></pre></td></tr></table></figure><p>上述程序cost的值是12，第二个声明会损失一些精度，因为在C语言中只能保证单精度浮点型前6位的精度，一般来说编译器会对这样的初始化产生警报。</p><h1 id="参数和陷阱"><a href="#参数和陷阱" class="headerlink" title="参数和陷阱"></a>参数和陷阱</h1><p>对于printf（）函数的使用主要是需要注意函数中的参数，在格式化字符串中有多少个转换说明，就说明后面需要几个参数，我们需要做的就是确保转换说明数量、类型与后面参数的数量、类型是否一致。</p><p><strong>但是这对于printf（）和scanf（）函数来说并不起作用，因为这两个函数的参数个数是可变的。</strong></p><p>在下一篇博客中会对printf（）和scanf（）这两个函数进行具体的分析，这里就简单的做个说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">7.0f</span>;</span><br><span class="line">    <span class="type">float</span> g = <span class="number">8.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n, m);<span class="comment">/*参数太多*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, n);<span class="comment">/*参数太少*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f, g);<span class="comment">/*值的类型不匹配*/</span></span><br><span class="line">    </span><br><span class="line">    retuen <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是基本会出现的多数问题，在编译器中大部分也会有提醒，然而C标准对此并未作出要求，若是程序正常运行，这些细小的错误会很难察觉。</p><h1 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h1><p>对于转义序列来说，我们主要可以看看退格（\b）、水平制表符（\t）、回车（\r）的工作方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\aEnter your desired monthly salary:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; $_______\b\b\b\b\b\b\b&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;salary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\t$%.2f a month is %.2f a year.&quot;</span>, salary, salary * <span class="number">12.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\rGee!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的薪资询问系统（简单交互），其中含有许多的转义序列。</p><h2 id="刷新输出"><a href="#刷新输出" class="headerlink" title="刷新输出"></a>刷新输出</h2><p>printf（）函数在什么时候会把输出发送到屏幕上呢？<br>最初，printf（）会把内容发送到缓冲区的中间存储区域，然后缓冲区的内容再不断被发送到屏幕上。在C标准中规定了什么时候把缓冲区的内容发送到屏幕：</p><p>1.缓冲区满</p><p>2.遇到换行字符</p><p>3.需要输入的时候</p><p><strong>Tip：还有一种刷新缓冲区的方法就是使用fflush（）函数。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的char，即unsigned char或signed char。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有short、int、long和long long类型。C规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存0或1，分别代表false和true。</p><p>下一篇博客将对字符串和printf（）、scanf（）两个函数做详细解析。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-文件与目录列表2</title>
      <link href="/2023/04/13/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%952/"/>
      <url>/2023/04/13/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<p>接上篇博客，这篇我们开始讲述Linux命令行中关于文件目录的最后一小点内容–目录。</p><h1 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h1><p>在Linux之中，有许多的命令对文件和目录都有效，而有些只对目录有效，那么首先我们来说说怎么创建一个新的目录：</p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>命令：mkdir  -  make directories</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413100027.png"></p><p>我们可以使用 ls命令来查看，可以注意到新目录列表是以d开头，这表示New_dir1是一个目录而不是一个文件。</p><p>单一的 mkdir命令只能创建一个一个目录，若是我们想要创建多个目录或者子目录，就需要在命令后加入-p的参数。如果我们在创建目录出现错误或者建错地方，我们又应该如何去删除呢</p><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>命令：rmdir   -  remove directories</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413100717.png"></p><p>上图可以看到我在一个目录下又创建了一个目录，我想要删除，延续了rm命令的 -i习惯，但是在 rmdir命令中并没有 -i选项来询问是否要删除目录。</p><p><strong>Tips：在默认的情况下，rmdir命令只能删除空目录，若是目录下含有文件等，rmdir命令是无法执行的。</strong></p><p>虽然rmdir命令只能删除空目录，但是不代表删除目录会有很大的麻烦，我们还可以在非空目录上使用rm命令，使用-r参数使得命令可以向下进入目录，删除其中的文件，删除文件之后并且删除目录。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413101811.png"></p><p>上图这种方法同样可以向下进入多个子目录，当需要大量删除目录和文件，这一点尤为有效。若是文件达到一定量级这种方法的弊端也随之显现出来，因为我们要确认每一个文件，这时最终的方法就是使用 -r 和 -f 同时使用的rm命令。</p><p><strong>Tip：在使用 rm -rf 命令之前最好先确认操作是否符合预期，务必谨慎使用该指令。</strong></p><h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><p>Linux中还有几个命令可以查看文件的内容，而不需要调用其他的文本编辑器。</p><h2 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h2><p>命令：file （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413102933.png"></p><p>这个命令是一个随手可得的便捷工具，它可以探测文件的内部，并决定文件是什么类型。也可以作为我们区分文件与目录的又一种方法，其次该命令还可以在查询符号链接文件的时候，可以告诉我们它究竟链接到了那个文件上。</p><h2 id="查看整个文件"><a href="#查看整个文件" class="headerlink" title="查看整个文件"></a>查看整个文件</h2><p>若是我们手头有一个很大的文本文件，我们会希望看看里面的内容，在Linux中有三个不同的命令能完成这个任务。</p><p>命令1：cat  (option)</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413103904.png"></p><p>cat命令是显示文本文件中所有数据的得力工具，没有什么特别的内容。还有一些和该命令搭配使用的参数：</p><p>参数：-n </p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413104310.png"></p><p>该参数会给所有的内容的行加上行号。（在检查脚本的时候很有用）</p><p>若是只想给有文本的加上行号可以使用 - b 参数。</p><p>若是不想制表符出现，可以使用 -T 参数。</p><p><strong>Tip：对于大型文件来说，cat命令有些繁琐，文件的文本会一晃而过。下面的命令可以解决这个问题。</strong></p><p>命令2：more  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413105421.png"></p><p>more命令是为了解决cat命令一旦运行，无法控制后面的操作，more命令可以在显示一页数据之后停下来，more命令是分页工具，正如前面提到过的man命令一样，可以通过空格键和回车键逐行浏览文件，浏览完之后按q键退出。</p><p><strong>Tip：不过more命令只支持文本文件最基本的移动，有些高级功能可以使用less命令。</strong></p><p>命令3 ：less  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413110115.png"></p><p>上图就是通过 less 命令进入一个源代码文件。less命令与more命令基本一样，除此之外还包括很多其他的命令集。</p><h2 id="查看部分文件"><a href="#查看部分文件" class="headerlink" title="查看部分文件"></a>查看部分文件</h2><p>上面的命令都是查看完整文件，但其实有些时候我们只需要查看文件的开头或者结尾就满足需求了，这个时候用cat、more或者less就显得没这么便捷了，好在Linux中有两个专用的命令</p><p>命令1：tail  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413111736.png"></p><p>该命令正如它的名字，会显示文件内容的最后几行的内容。在系统默认情况下，它会显示文件的末尾10行。</p><p>参数：-n  number</p><p>在-n后面加上想要的行数就可以指定该命令的显示行数了。</p><p>参数：-f</p><p>该参数是tail命令的一个突出特性，该参数允许我们在其他进程使用该文件的时候查看文件的内容，tail命令会保持不断活动的状态，这是实时监测系统日志的良好方法。</p><p>命令2：head filename</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413112342.png"></p><p>与上同理，该命令会显示文件开头的行内容，默认情况下，会显示前10行的内容。该命令也支持参数 -n 。</p><p><strong>Tip：因为一般来说文件的开头不会轻易改变，head命令并不像tail命令一样支持参数 -f 。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于在文件系统中切换目录以及处理文件和目录的基本知识到这里就结束了。下面就是正式开始脚本编程之前的最后准备–系统管理命令（如何通过命令行探查Linux系统的内部信息）。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-数据类型</title>
      <link href="/2023/03/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型简介"><a href="#数据类型简介" class="headerlink" title="数据类型简介"></a>数据类型简介</h1><p>在上一篇博客中，已经结束了对于C语言最基本的了解，这篇我们来对关键字中的最为重要且最多的数据类型关键字，他们包括：int、short、long、unsigned、char、float、double、_ Bool、_ Complex、_ Imaginary。</p><p>每一个程序都离不开数据，我们把数字，字母和文字输入进电脑，希望电脑通过这些数据完成某些任务，我们要学会怎么读取数据以及如何操控数据。</p><p>C语言提供两大系列的数据类型：整数类型and浮点数类型。</p><p><strong>Tip：以上关键字大都可以分为这两个类型 。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230331131221.png"></p><p>上述程序的功能是将体重转换为白金价值，其中，我们一改往日的变量定义，在本例中使用了浮点型的float变量，用于处理更大范围的数据，float类型可以储存带小数的数字。</p><h1 id="变量与常量数据"><a href="#变量与常量数据" class="headerlink" title="变量与常量数据"></a>变量与常量数据</h1><p>在一个程序运行过程中没有发生变化的，称之为常量（constant），那么在程序运行过程中可能会被改变或者被赋值的，则称之为变量（variable)。</p><p>在上述程序中，weight就是一个变量，14.5833是一个常量。</p><h1 id="数据类型关键字"><a href="#数据类型关键字" class="headerlink" title="数据类型关键字"></a>数据类型关键字</h1><p>当然不仅是变量与常量不同，不同的数据类型之间也有差异，一些数据类型表示数字，一些数据类型表示字母。如果数据是常量，编译器一般通过程序中的书写形式来识别；但是对于变量而言，我们在程序的开头就要指定它的类型，下图是C语言中的数据类型关键字：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230331140122.png"></p><p>其中，int关键字用来表示基本的整数类型，long、short、unsigned三个关键字，包括新增的signed用于提供整数类型的变式，unsigned short int等；char关键字用于指定字母和其他字符（#￥%*），char类型也可以表示较小的整数；float、double、long double表示带小数点的数；_ Bool类型表示布尔值（true or false）， _ Complex 表示复数， _ Imaginary 表示虚数。</p><p><strong>Tip：位、字节和字是指计算机数据单元或者存储单元的术语：</strong></p><p><strong>位（bit）：可以储存0或1，是构建计算机内存的基本模块。</strong></p><p><strong>字节（byte）：对于几乎所有机器，1字节均为8位，这是字节的标准定义。</strong></p><p><strong>字（word）：是设计计算机时给定的自然存储单位，会随着计算机的进步而进步，现在基本都是64位。</strong></p><h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>整数：与数学的概念一样，在C语言中，整数是没有小数部分的数，我们需要做的是把十进制的数转换到计算机中的二进制，在8位字节中储存该数字，例如7在二进制中就是00000111。</p><p>浮点数：与数学中的实数概念差不多，注意，在一个值后面加上一个小数点，该值就变成一个浮点值了。所以，7是整数，7.00就是浮点数了。显而易见，书写浮点数的方式有很多种，我们主要学习e记数法。</p><p>3.16E7表示的是3.16*10^7，7是10的指数。计算机中把浮点数分成小数部分和指数部分来表示，并且分开存储。</p><p>我们主要需要理解浮点数和整数的储存方案的不同。</p><h1 id="C语言基本数据类型"><a href="#C语言基本数据类型" class="headerlink" title="C语言基本数据类型"></a>C语言基本数据类型</h1><h2 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h2><p>C语言中提供了许多的整数类型，为的是方便程序员针对不同的情况选择不同的类型。特别是，C语言中的整数类型可以表示不同的取值范围和正负值，一般大部分情况使用int类型即可。</p><p>int类型是有符号整型，其值必须为正负整数或零，一般而言，一个int类型需要占用一个机器字长。早期的16位IBM机一般使用16位来储存一个int值，取值范围（-32768-32767）。现在的个人计算机已经发展到了64位，不过ISO C 规定int的取值范围最小为-32768-32767。</p><p><strong>Tip：若是占据16位，为什么不是（-65536-65535），因为一般来说，系统会用首位表示有符号整数的正负号。</strong></p><p>声明int变量在此就不再赘述了，以上已经使用很多了。那么在定义了变量之后，就要对其提供对应的值，变量获取值的方法：第一种就是赋值，利用 &#x3D; 即可；第二种途径是通过函数来获得值（scanf（）等函数），最重要的就是第三种方法：初始化变量！</p><p>初始化变量就是在定义变量的同时就赋予一个初始值，在int 语句后加上一个 &#x3D; 和对应的值即可。</p><p>简单来说，声明变量就是给变量创建和标记存储空间，并为其指定初始值。</p><p>int的常量就比较简单了，一般来说不带小数点的就是int型常量；之后还有long常量和long long常量。</p><p><strong>Tip：最好在初始化时不要把初始化的变量和未初始化的变量放在同一条声明中。</strong></p><p>printf（）函数可以打印int类型的值，%d表明了在一行里打印整数的位置，%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。</p><h3 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h3><p>一般来说，C语言都是假定整型常量是一个十进制数。然而，由于底层是二进制作为基础，实际应用中还是使用八进制和十六进制数，因为8和16都2的幂，但是计算机是无法自行分别各个进制之间的区别的，在C语言中，用特定的前缀表示使用哪种进制。0x或0X前缀表示十六进制值，所以十进制数16表示成十六进制是0x10或0X10。与此类似，0前缀表示八进制。在之后的内容中会详细的讲述进制相关的内容。</p><p><strong>Tip：无论使用那种进制来表示，都不会影响数据的存储方式，因为计算机内部还是二进制进行编码。</strong></p><p>八进制与十六进制的显示：与%d用来显示十进制类似，以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。</p><p>**Tip：在C语言中，八进制和十六进制的常量属于无符号整型（unsigned int）。</p><h2 id="其他整数类型"><a href="#其他整数类型" class="headerlink" title="其他整数类型"></a>其他整数类型</h2><p>我们初学C语言时，int类型能够满足大多数程序的需求了，当然这小节内容为的是留一个印象。C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。</p><p>short int类型（或者简写为short）：占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。short类型属于有符号类型。</p><p>long int类型（long）：占用的存储空间可能比int多，适用于较大数值的场合。long也属于有符号类型。</p><p>long long int或long long（C99标准加入）：占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。</p><p>unsigned int或unsigned：只用于非负值的场合。这种类型与有符号类型表示的范围不同。若是16位unsigned，取值范围则是0-65535。</p><p>声明方式：这些整数类型的声明方式与int类型并无任何不同。</p><p><strong>Tip：八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。</strong></p><p>本小节中我们值得注意的一个问题就是整数是否会溢出的问题。要对我们使用的机器的int类型的位数时刻注意。</p><p>短整型，长整型等的显示：打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。</p><p><strong>Tip：注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。</strong></p><h2 id="字符：char类型"><a href="#字符：char类型" class="headerlink" title="字符：char类型"></a>字符：char类型</h2><p>char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。现在使用最主流的编码系统就是ASCII码，在ASCII码中，整数65代表大写字母A。因此，储存字母A实际上储存的是整数65。</p><p>C语言把1字节（8位）定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。</p><p>声明方式：char类型变量的声明方式与其他类型变量的声明方式相同。</p><p>字符常量的书写方式：在C语言中，用单引号括起来的单个字符被称为字符常量，<strong>单引号必不可少，若是双引号则是字符串。</strong>也可以使用ASCII码中的对应数字来进行赋值（最好不要这样做）。</p><p>单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。比如像退格，换行，蜂鸣等，在C语言中提供了三种方法表示这些字符。</p><p>第一种就是利用数字代码的方式，定义蜂鸣字符的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> beep = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>第二种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列，如下表：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402114259.png"></p><p>最后两个转义序列（\0oo和\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\）并用单引号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beep = <span class="string">&#x27;\007&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述代码等同于 \a;</p><p>十六进制就是将前缀从0改为x即可，记得带上单引号。</p><p>我们在使用数字和数字字符的时候需要注意，字符 ‘4’ 在ASCII码中是52，而不是数字4。</p><p><strong>Tip：无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。</strong></p><p>字符打印方式：printf()函数用%c指明待打印的字符，如果用%d转换说明打印 char类型变量的值，打印的是一个整数。下图清楚显示了数据的显示过程：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402120020.png"></p><h2 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h2><p>_ Bool类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。通常来说布尔类型只占用一位存储空间，在以后会对这个类型进行展开讲解。</p><h2 id="可移植类型：stdint-h和inttypes-h"><a href="#可移植类型：stdint-h和inttypes-h" class="headerlink" title="可移植类型：stdint.h和inttypes.h"></a>可移植类型：stdint.h和inttypes.h</h2><p>在C99标准中新增了两个头文件stdint.h和inttypes.h，以确保C语言的类型在各系统中的功能相同。在stdint.h头<br>文件中，int32_t表示32位有符号整数类型，在使用32位系统中，头文件会把int32_t作为int的别名，若是在16位的系统中，int32_t会被作为long的别名，使用stdint.h的头文件编写程序是为了方便在不同的系统进行匹配。</p><p>不过我们还可能碰到计算机底层系统不能匹配int32_t的情况。这个时候一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型，这组类型集合被称为最小宽度类型。如int_least8_t是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。若是系统最小的整数类型是16位也并不妨碍int_least8_t的使用。</p><p>仅作为了解。</p><h2 id="浮点型：float、double、long-double"><a href="#浮点型：float、double、long-double" class="headerlink" title="浮点型：float、double、long double"></a>浮点型：float、double、long double</h2><p>在C语言的标准中，float类型的必须至少能表示6位的有效数字，取值范围在10^-37~10^37。一般来说，浮点型通常要占用32位，其中8位用于指数部分的值和符号，剩余的24位是使用于非指数部分的值和符号。</p><p>另外一个浮点型double（双精度），double类型和float类型的最小取值范围相同，但是double必须能表示10位有效数字，一般情况下双精度占用的是64位，一些系统是将多余的32位均用于非指数的部分，从而达到更高的精度。</p><p>第三个浮点型long double是用于满足比double类型更高的精度要求，C语言中只保证long double和double的精度相同。</p><p>声明方式：同其他数据类型。</p><p>浮点型常量的书写方式：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。</p><p>2.87E3，-1.56E12等</p><p>正号可以省略。可以没有小数点或者指数部分，但是不能同时省略两者，可以省略小数部分或整数部分，但是不能同时省略两者。</p><p><strong>Tip：不要在浮点型常量中间加空格</strong></p><p>在默认情况下，浮点型常量是double类型的精度，若是在浮点数后面加上f或F的后缀即可覆盖默认的设置，加上l或L的话就是long double的类型。</p><p>在C99标准中还有一种新的浮点型常量的格式，用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂。</p><p>0xa.1fp10 &#x3D; 10364.0（了解）</p><p>浮点数的打印：printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La转换说明。</p><p>浮点数的上溢和下溢：上溢和整数类型的溢出原理基本类似，而下溢则是在计算过程中由于计算符导致有效数字丢失位置的情况。</p><p>下溢例子：以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。</p><h2 id="复数和虚数类型"><a href="#复数和虚数类型" class="headerlink" title="复数和虚数类型"></a>复数和虚数类型</h2><p>C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型float_Imaginary、double _Imaginary和long double _Imaginary。如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。</p><h2 id="类型大小"><a href="#类型大小" class="headerlink" title="类型大小"></a>类型大小</h2><p>sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。</p><p>下图是源码展示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402133219.png"></p><p>以下是输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402133353.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是对C语言中数据类型的基本学习和介绍。 </p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-文件与目录列表</title>
      <link href="/2023/03/26/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/03/26/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="文件与目录-ls命令"><a href="#文件与目录-ls命令" class="headerlink" title="文件与目录-ls命令"></a>文件与目录-ls命令</h1><p>上篇我们已经知道了如何遍历系统和验证当前的工作目录，接下来就可以开始探索各种目录中的文件了。</p><p>要想知道目录中有那些文件，可以使用列表命令（ls）。</p><p>ls命令最基本的形式会显示当前目录下的文件和目录，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326150508.png"></p><p>ls命令带上-F参数的ls命令轻松区分文件和目录。使用-F参数可以得到如下输出：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326150758.png"></p><p>基本的ls命令在某种意义上有点容易让人误解。它显示了当前目录下的文件和目录，但并没有将全部都显示出来。Linux经常采用隐藏文件来保存配置信息。在Linux上，隐藏文件通常是文件名以点号开始的文件。要把隐藏文件和普通文件及目录一起显示出来，就得用到-a参数。</p><p>ls命令中的-R参数是ls命令可用的另一个参数，叫作递归选项。它列出了当前目录下包含的子目录中的文件。如果目录很多，这个输出就会很长。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326151353.png"></p><p><strong>Tip：输入参数时可以不用像图片中一样，ls -F -R，可以进行合并 ls -FR。</strong></p><p>在基本的输出列表中，ls命令并未输出太多每个文件的相关信息。要显示附加信息，另一个常用的参数是-l。-l参数会产生长列表格式的输出，包含了目录中每个文件的更多相关信息。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326151751.png"></p><p>在这些相关信息中主要分为以下这些：</p><p>文件类型，比如目录（d）、文件（-）、字符型文件（c）或块设备（b）；<br>文件的权限（参见第6章）；<br>文件的硬链接总数；<br>文件属主的用户名；<br>文件属组的组名；<br>文件的大小（以字节为单位）；<br>文件的上次修改时间；<br>文件名或目录名。</p><p><strong>Tip：在shell中输入man ls 可以查看ls命令的各种参数，man命令同样适用于其他指令。</strong></p><p>前面的例子可知，默认情况下，ls命令会输出目录下的所有非隐藏文件。有时这个输出会显得过多，当你只需要查看单个少数文件信息时更是如此。ls命令还支持在命令行中定义过滤器，它会用过滤器来决定应该在输出中显示哪些文件或目录。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326152853.png"></p><p>当用户指定特定文件的名称作为过滤器时，ls命令只会显示该文件的信息。有时你可能不知道要找的那个文件的确切名称。ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配：<br>问号（?）代表一个字符；<br>星号（*）代表零个或多个字符。<br>问号可用于过滤器字符串中替代任意位置的单个字符。</p><p>在过滤器中使用星号和问号被称为文件扩展匹配（file globbing），指的是使用通配符进行模式匹配的过程。通配符正式的名称叫作元字符通配符（metacharacter wildcards）。除了星号和问号之外，还有更多的元字符通配符可用于文件扩展匹配。可以使用中括号。下面是中括号的两种用法：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326153254.png"></p><p>另外，可以使用感叹号（!）将不需要的内容排除在外。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326154001.png"></p><p><strong>Tip：在使用 (!) 时，也需要在外面加上中括号。</strong></p><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><h2 id="创建文件-touch命令"><a href="#创建文件-touch命令" class="headerlink" title="创建文件-touch命令"></a>创建文件-touch命令</h2><p>我们在学习的过程时不时会遇到创建空文件的情况，这时可以使用touch命令创建空文件，注意文件的大小是0。而且touch命令还可以用来改变文件的修改时间，这个操作并不会改变文件的内容。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326155341.png"></p><p>那么touch命令与mkdir命令的区别在什么地方？</p><p>touch命令：</p><p>语法：touch [options] filename<br>           -a：改变访问时间<br>           -m：改变改动时间<br>           -t timestamp：改变访问时间和改动时间为timestamp</p><p>mkdir命令：</p><p>语法：mkdir [options] dirname<br>           -p：递归创建文件夹<br>           -mmode：新建文件夹，并设置文件夹的文件访问模式为mode</p><p>总结来说，一个是创建文件，一个是创建文件夹。</p><h2 id="复制文件-cp命令"><a href="#复制文件-cp命令" class="headerlink" title="复制文件-cp命令"></a>复制文件-cp命令</h2><p>在最基本的用法里，cp命令需要两个参数——源对象和目标对象：<br>cp source destination<br>当source和destination参数都是文件名时，cp命令将源文件复制成一个新文件，并且以destination命名。新文件就像全新的文件一样，有新的修改时间。</p><p><strong>Tip：如果目标文件已经存在，cp命令可能并不会提醒这一点。最好是加上-i选项，强制shell询问是否需要覆盖已有文件。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327131534.png"></p><p>另外，cp命令的-R参数威力强大。可以用它在一条命令中递归地复制整个目录的内容。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327131921.png"></p><p><strong>Tip：cp命令中也可以使用通配符，除了单点符和通配符之外，还可以使用shell的另一特性，那就是制表键自动补全。</strong></p><h2 id="制表键自动补全"><a href="#制表键自动补全" class="headerlink" title="制表键自动补全"></a>制表键自动补全</h2><p>在我们日常使用命令行时，由于繁多且复杂，很容易输错命令、目录名和文件名，这正是制表键自动补全挺身而出的时候。制表键自动补全允许你在输入文件名或目录名时按一下制表键，让shell帮忙将内容补充完整。</p><p><strong>Tip：使用制表键自动补全的的技巧在于要给shell足够的文件名信息，使其能够将需要文件同其他<br>文件区分开。假如有另一个文件名也是以really开头，那么就算按了制表键，也无法完成文件名<br>的自动补全。这时候你会听到嘟的一声。要是再按一下制表键，shell就会列出所有以really开头的<br>文件名。这个特性可以让你观察究竟应该输入哪些内容才能完成自动补全。</strong></p><h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>链接文件是Linux文件系统的一个优势。如需要在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。链接是目录中指向文件真实位置的占位符。在Linux中有两种不同类型的文件链接：<br><strong>符号链接：ln -s filename</strong><br><strong>硬链接：ln filename</strong></p><p>符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。</p><p>硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。</p><p>符号链接类似于C语言的指针！若是想要验证是否为不同的文件，可以使用 ls -i 命令查看incode编号。</p><p><strong>Tip：复制链接文件的时候，产生的是源文件的副本，容易弄混乱，不如创建源文件的另一个链接，一个源文件可以有多个链接，千万不要创建软链接的软链接，容易造成断裂。</strong></p><h2 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h2><p>在Linux中，重命名文件称为移动。mv命令可以将文件和目录移动到另一个位置或重新命名。</p><p>​                               <img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327134310.png"></p><p><strong>Tip：移动文件会将文件名进行更改，但inode编号和时间戳保持不变。这是因为mv只影响文件名。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327135136.png"></p><p>我们可以看到在重命名目录之后，原来的目录名已经不存在了。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Linux中，删除（deleting）叫作移除（removing）。bash shell中删除文件的命令是rm。rm命令的基本格式非常简单。</p><p><strong>rm -i filename</strong></p><p><strong>Tip：-i命令参数提示你是不是要真的删除该文件。ubuntu中虽然有回收站或垃圾箱，但是，在使用rm命令时，我们仍要养成总是加入-i参数的好习惯。</strong></p><p>rm命令的另外一个特性是，如果要删除很多文件且不受提示符的打扰，可以用-f参数强制删除。</p><p>下篇将介绍mkdir命令的使用场景–目录。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学</title>
      <link href="/2023/03/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6/"/>
      <url>/2023/03/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="多个函数"><a href="#多个函数" class="headerlink" title="多个函数"></a>多个函数</h1><p>截至目前，所有的程序都只使用了printf（）函数。接下来我们来演示如何把自己的函数加入程序中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* two_func.c -- 一个文件中包含两个函数 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void butler(void); /* C函数原型 */</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;I will summon the butler function.\n&quot;);</span><br><span class="line">butler();</span><br><span class="line">printf(&quot;Yes. Bring me some tea and writeable DVDs.\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void butler(void) /* 函数定义的开始 */</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;You rang, sir?\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>butler()函数在程序中出现了3次。第1次是函数原型（prototype），告知编译器在程序中要使用该函数；第 2 次以函数调用（function call）的形式出现在 main()中；最后一次出现在函数定义（function definition）中，函数定义即是函数本身的源代码。</p><p>在 main()中调用 butler()很简单，写出函数名和圆括号即可。当butler()执行完毕后，程序会继续执行main()中的下一条语句。</p><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><p>在我们自己编写程序的过程中，会因为粗心大意犯一些错误，程序的错误通常叫做 bug，找出并修正错误的过程叫做调试（debug）。</p><p>通常来说程序的错误主要集中在三个方面：语法错误，语义错误，程序状态。</p><p>语法错误：C语言的语法错误指的是，把有效的C符号放在错误的地方。</p><p>语义错误：在C语言中，如果遵循了C规则，但是结果不正确，那就是犯了语义错误。</p><p>Tip：编译器无法检测语义错误，因为这类错误并未违反 C语言的规则。</p><p>程序状态：程序状态是在程序的执行过程中，某给定点上所有变量值的集合。它是计算机当前状态的一个快照。</p><h1 id="关键字和保留标识符"><a href="#关键字和保留标识符" class="headerlink" title="关键字和保留标识符"></a>关键字和保留标识符</h1><p>关键字是C语言的词汇。它们对C而言比较特殊，不能用它们作为标识符（如，变量名）。许多关键字用于指定不同的类型，如 int。还有一些关键字（如，if）用于控制程序中语句的执行顺序。如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230323141935.png"></p><p>保留标识符包括那些以下划线字符开头的标识符和标准库函数名，如printf（）。</p><p>对C语言的了解在此篇结束，接下来开始学习C语言中的数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言回顾</title>
      <link href="/2023/03/18/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/"/>
      <url>/2023/03/18/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言初识"><a href="#C语言初识" class="headerlink" title="C语言初识"></a>C语言初识</h1><p>C语言属于编译型语言，所以编写C程序的过程大致可以分为7个步骤：</p><ol><li>定义程序目标</li><li>设计程序</li><li>编写代码</li><li>编译</li><li>运行程序</li><li>测试和调试程序</li><li>维护和修改程序</li></ol><p>在理想状态下，完成7个步骤即可，但在一些大型项目中，需要我们做一些重复的工作。7个步骤中，我认为最重要的是1，2两个步骤，当我们接到一个项目时，无论简单与否，不是拿起电脑就开始敲代码，而是应该确定我们这个项目的目标，这样我们才能将心无旁骛地前进；而设计程序是为了扫除项目中无关紧要的细枝末节，使得程序最大程度上得到精简。</p><p>完成以上的工作之后，我们就可以开始编写代码了，以我们最常见的Hello world.c为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello world!\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是编译的过程，编者主要使用Linux系统编写的C程序，有关编译过程可以找博客中关于命令行的编译知识。在编译过程中，编译器会检查C程序是否有效，如果发现错误，那么编译器会报告相应的错误，理解报错也是我们应当掌握的技能。</p><p>第5-7步就是得出结果和维护的过程，C程序是以能否运行为首要前提，而在此之后，我们就要对自己写的程序进行不断优化，编者相信不管什么时候都要抱有一颗学徒的心，为了使程序变得更好，剩下的步骤显得格外珍贵。</p><h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1><p>一般来说，C程序是以.c作为文件的扩展名，以满足当前系统对文件名的要求，下面是一个简单的C程序，分块查看一个程序包含那些部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)                           /* 一个简单的C程序 */</span><br><span class="line">&#123;</span><br><span class="line">int num;                             /* 定义一个名为num的变量 */</span><br><span class="line">num = 1;                             /* 为num赋一个值 */</span><br><span class="line"></span><br><span class="line">printf(&quot;I am a simple&quot;);             /* 使用printf()函数 */</span><br><span class="line">printf(&quot;computer.\n&quot;);</span><br><span class="line">printf(&quot;My favorite number is d% because it is first.\n&quot;,num);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对任意一个C程序，我们都可以对它进行拆解，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230319153816.png"></p><p>头文件和include指令本质就是在程序执行前将准备工作做完，无需赘述。</p><p>main()函数，C程序一般都是从main()函数开始执行，因为该例中没有传递任何信息，因此圆括号内是void。</p><p>&#x2F;* ………….. *&#x2F; 是程序的注释，并不会执行，写注释可以让看程序者更容易明白程序要表达的意思。</p><p>{</p><p>…</p><p>} 是标记函数体的开始和结束。</p><p>int num 表示对num这个变量进行声明，说明num是一个整数变量。</p><p>数据类型包括整数、字符和浮点数等，变量声明是一个程序的必要步骤，命名只能是字母、数字和下划线，且第一个字符必须是字母或者下划线。</p><p>\n 是换行的意思，换行符是转义序列，例如 \t 表示Tab键，\b 表示Backspace键，每一个转义序列都是以反斜()开始，以后再来细说。</p><p>d% 是一个占位符，作用是指明num值输出的位置，在语句最后要将num加上。</p><p>return 0 就是程序的结尾。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行初识</title>
      <link href="/2023/03/17/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/2023/03/17/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux命令行"><a href="#Linux命令行" class="headerlink" title="Linux命令行"></a>Linux命令行</h1><p>linux系统使用时有别于windows系统，没有完美的图形界面，所以命令行成为了使用linux系统的基础。</p><p>Tips：linux系统在使用时一般使用正斜线（&#x2F;），而不是反斜线（\），linux中反斜线表示转义字符。</p><p>首先是进入控制台使用的快捷键：Ctrl+Alt+t：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230317133117.png"></p><p>进入控制台后我们就可以开始学习命令行了。</p><p>正如window中一样，我们首先要知道怎么打开一个文件夹，在linux中使用的cd命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$cd /home                     进入名为home的目录</span><br></pre></td></tr></table></figure><p>cd命令的参数可以用两种方法表示：一种是使用绝对文件路径，另一种是使用相对文件路径。</p><p>绝对文件路径较为简单，同windows理，在执行上述代码后，~会变成&#x2F;home，这时就处于home的目录下了。若是没有配置好提示符来显示当前shell会话的绝对文件路径，可以使用pwd命令显示出来，如下图。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317142148.png"></p><p>相对文件路径是允许用户指定一个基于当前位置的目标文件路径。相对文件路径不以代表根目录的正斜线（&#x2F;）开头，而是以目录名或是一个特殊字符开始。假如位于home目录中，并希望切换到代码子目录，那么可以使用cd命令加上一个相对文件路径：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317142732.png"></p><p>上图并没有使用正斜线（&#x2F;），而是采用了相对文件路径将大大减少输入内容。</p><p>另有两个特殊字符可用于相对文件路径中</p><p>单点符（.），表示当前目录；</p><p>双点符（..），表示当前目录的父目录。</p><p>双点符在目录层级的移动时非常便利，如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317143139.png"></p><p>从home目录下的代码文件夹移动到视频文件夹。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/18/hello-world/"/>
      <url>/2022/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
