<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux命令行-环境变量</title>
      <link href="/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在上一篇关于shell，子shell，进程相关介绍结束之后，接下来将要学习Linux中的环境变量。</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>bash shell 会用一个叫作环境变量的特性来存储shell会话和工作环境的信息，这项特性允许我在内存中存储数据，这也是存储持久数据的方法。</p><p>一般来说，环境变量分为两类：全局变量和局部变量</p><p>虽然bash中会有使用一致的专用环境变量，但是不同的版本Linux经常会添加自有的环境变量。</p><h2 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h2><p>全局环境变量顾名思义就是对于shell和子shell都是可见的，而局部变量则只是对创建它们的shell可见。系统环境变量基本上都是大写的。</p><p>查看全局变量命令：env 或者 printenv</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051618054.png"></p><p>这里只是其中一部分的全局环境变量，其中有很多都是在登录过程中设置的，另外，我们的登录方式也会影响到所设置的环境变量。</p><p>若是需要显示个别环境变量的值，使用printenv命令，但是不要使用env命令。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051622854.png"></p><p>当然我们也可以使用echo来显示变量的值，不过在这种情况下使用某个环境变量时，必须要在变量前加上 $ 。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051628360.png"></p><p><strong>Tip：在echo命令中，在变量名前加上$ 可不仅仅是要显示变量当前的值，它能够让变量作为命令行参数。</strong></p><p>那么是否可以用所有的子shell，当然是可以的。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051649985.png"></p><p>上面我们可以看出，在子shell中显示的HOME环境变量的值和父shell中是一摸一样的。</p><h2 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h2><p>局部环境变量是只能在定义它们的进程中可见，虽然它是局部的但是和全局环境变量同等重要。事实上，Linux系统也默认定义了标准的局部环境变量，不过我们自己也可以定义自己的局部变量，这些被称为用户定义局部变量。</p><p>但是在Linux中并没有一个只显示局部环境变量的命令。set命令会显示特定进程设置的所有的环境变量，包括局部、全局和用户定义变量。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051712915.png"></p><p>这只是set命令显示出来的部分环境变量，包含了全局环境变量。</p><p><strong>Tip：命令env、printenv和set之间的差异很细微，set不仅仅会显示全部的环境变量还会按照字母的顺序进行排序，而env和printenv并没有这个功能，但是env相较于printenv来说还多出一个功能。</strong></p><h1 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h1>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-C控制语句：循环</title>
      <link href="/2023/06/03/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-C%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BE%AA%E7%8E%AF/"/>
      <url>/2023/06/03/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-C%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>此篇我们将对循环进行更加深入的学习，while、for以及do while三种。</p><h1 id="深入while循环"><a href="#深入while循环" class="headerlink" title="深入while循环"></a>深入while循环</h1><p>在上篇中我们已经初步接触过了这个循环，主要是对条件语句进行判断，接下来通过一个程序来进一步了解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> num;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to be sunmmed &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(q to quit): &quot;</span>);</span><br><span class="line">    status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (status == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter next integer (q to quit): &quot;</span>);</span><br><span class="line">        status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Those integers sum to %ld.\n&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是根据键入的整数求和，那么while的循环判断语句是什么呢，从上诉程序中我们可以看出就是scanf的返回值，在之前的学习，我们知道scanf的返回值是读取的数字项数，在这个程序中可知返回值只有0和1两种可能性。</p><h2 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h2><p>我们先来看看while循环中的测试条件，是一个完全等于的表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status == <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>在这个判断表达式中，&#x3D;&#x3D; 运算符是一个相等运算符，用来判断是否等于1，而不是赋值表达式，把1赋值给status，要让程序正常运行，每次都要获取一个num，并且重置status的值。</p><p>其实我们在这里可以思考一个问题，循环的停止是否只能利用scanf 的返回值呢，若是scanf 没有返回值，我们是否可以利用别的方法来暂停循环，例如将测试条件改为num &gt;0，或者是num !&#x3D; 0。（经过测试，这种方法是可行的！）也可以在循环中添加代码，询问用户是否接着循环，但是这样会增加代码的复杂性，且减慢了输入的速度。</p><p>while循环作为入口条件循环，程序必须在进入循环体之前必须获取输入的数据并检查status的值。</p><h2 id="C风格读取循环"><a href="#C风格读取循环" class="headerlink" title="C风格读取循环"></a>C风格读取循环</h2><p>根据伪代码的设计思路，我们可以对上述程序进行改进：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, num);</span><br><span class="line"><span class="keyword">while</span> (status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 循环体具体行为 */</span></span><br><span class="line">    status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一小节可以改成如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, num) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 循环体具体行为 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，每次迭代之前都会判断循环的条件，只有当获取值和判断值都成功的时候，才会对值进行处理。</p><h1 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h1><p>通用形式：</p><p>while（expression）</p><p>statement</p><p>其中，statement可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。</p><p>在目前接触到的while循环里，对于expression部分都是使用关系表达式，进行真假值的判断，更一般的说法其实就是判断是不是等于1（非零）。只要是非零，循环就会一直执行，每次循环都被称为一次迭代。</p><h2 id="终止while循环"><a href="#终止while循环" class="headerlink" title="终止while循环"></a>终止while循环</h2><p>while循环有一点很重要：必须让测试表达式的值有所变化，表达式最终需要为假。（其实在后面可以使用break和if语句来终止循环）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">while</span> (index &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good morning!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序会一直输出早上好，因为index的值始终为1，不曾变过，条件一直满足所以一直循环。</p><p><strong>Tip：在循环中我们一定要记住就是不能陷入死循环，对于条件判断表达式的值一定谨慎的选择和变化。</strong></p><h2 id="何时终止循环"><a href="#何时终止循环" class="headerlink" title="何时终止循环"></a>何时终止循环</h2><p>对于这个问题，只有在对测试条件求值时，才决定是终止还是继续循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n = %d&quot;</span>, n);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now n = %d&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The loop has finished.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这个程序，在第二次循环时首次获得了值7，但此时程序还没有退出，只有在对测试条件的再次判断之后才退出了循环。（所以总共是2次循环，3次判断）</p><h2 id="while：入口条件循环"><a href="#while：入口条件循环" class="headerlink" title="while：入口条件循环"></a>while：入口条件循环</h2><p>while循环是使用入口条件的有条件循环。有条件：语句的部分执行取决于测试表达式的条件，必须满足条件才能进入循环体，因为条件一开始就是假的话，根本进入不了循环。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">10</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (index++ &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Have a fair day or better.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一小段程序，把第一行改成 index &#x3D; 3 就可以开始运行循环了。</p><h2 id="语法要点"><a href="#语法要点" class="headerlink" title="语法要点"></a>语法要点</h2><p>我们在使用while的时候，还有另外一点我们需要记住：只有在测试条件后面的单独语句才是循环部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n is %d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all program does\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，虽然n++ 这行缩进了，但是并未把它和上一条语句括在花括号内，因此只有直接跟在测试条件之后的一条语句是循环的一部分，导致这个循环会变成一个死循环的程序。（若是没有外部干涉就不会退出）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n++ &lt; <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n is %d\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all program does\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是将上述程序改为第二版，并且在while循环后面加上分号，那么这个程序的输出结果就会变得不一样，因为这个时候while循环的语句就变成了单独语句而不是一个判断入口语句。（后面这个分号的作用表示空语句）</p><p>但是这个形式最好改为下面的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">/* 跳过整数输入 */</span></span><br></pre></td></tr></table></figure><p>处理这种情况更好的方法是使用下一章介绍的continue语句。</p><h1 id="用关系运算符和表达式比较大小"><a href="#用关系运算符和表达式比较大小" class="headerlink" title="用关系运算符和表达式比较大小"></a>用关系运算符和表达式比较大小</h1><p>while循环经常使用依赖测试表达式作比较，这样的表达式被称为关系表达式，出现在关系表达式中的运算符叫做关系运算符。</p><p>下图是一些关系运算符：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306091305022.png"></p><p>关系运算符常用于构造while语句和其他C语句中用到的关系表达式，会检查这些关系式的真假。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (number &lt; <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Your number is too small.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">sum = sum + num;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这三个例子，我们需要注意的是第二个，关系表达式是可以用于比较字符的，比较的时候使用的是ASCII码，但是不能使用关系运算符来比较字符串，后面会对比较字符串进行介绍。</p><p>在对浮点数进行比较的时候，尽量使用大于号或者小于号，因为有些小数位数的误差会导致原本应该相等的两个数最终不相等，或者也可以使用 fabs（）函数来返回一个浮点数的绝对值。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">double</span> response;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What is the value of pi?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;response);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Try it again!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Close enough!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306091334450.png"></p><h2 id="何为真"><a href="#何为真" class="headerlink" title="何为真"></a>何为真</h2><p>在C语言中什么是真这并不难讨论，关系表达式更是如此，只有一个真一个假，类似于布尔值。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> true_val, flase_val;</span><br><span class="line">    </span><br><span class="line">    true_val = (<span class="number">10</span> &gt; <span class="number">2</span>);</span><br><span class="line">    flase_val = (<span class="number">10</span> &lt; <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;true is %d and flase is %d\n&quot;</span>, true_val, flase_val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这个例子我们就可以看出关系式的返回值就可以是逻辑判断真假。所以有时候可以使用 while（1）使得循环一直进行。</p><h2 id="其他真值"><a href="#其他真值" class="headerlink" title="其他真值"></a>其他真值</h2><p>从上面我们可以知道 1 和 0 可以作为测试表达式，那么是否可以使用其他数字呢？</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is true\n&quot;</span>, n--);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is false\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    n = <span class="number">-3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is true\n&quot;</span>, n++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is false\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306091442981.png"></p><p>这个程序对 while 的使用提升了一个层次，不添加 {} ，那么在条件为真时就是接着下一个语句输出，若是为假，则会跳出循环，来到下一个句子。（设计思路听巧妙）。</p><p>一般来说，在C语言中只有0会被认为是假，其余的数字都是真，也可以说，使得测试条件的值为非零即为真，所以有时候会把 while （goats）改成 while （goats !&#x3D; 0），第一种形式对初学者来说比较清楚，但是一般来说，第二种形式为多数程序员使用。</p><h2 id="真值的问题"><a href="#真值的问题" class="headerlink" title="真值的问题"></a>真值的问题</h2><p>虽然C语言对真值的概念约束太少有一定的好处，但是事物都是有两面性的，约束少同时也会带来一些麻烦。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> num;</span><br><span class="line"><span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to be summed &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(q to quit): &quot;</span>);</span><br><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (status = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter next integer (q to quit): &quot;</span>);</span><br><span class="line">    status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Those integers sum to %ld.\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序其实是6.1程序改变而来，而我们改变的就是将 status &#x3D;&#x3D; 1 改为 status &#x3D; 1 ，将原来的等于改为了赋值语句，这会导致我们即使输入了q 改变了status的值，在执行循环测试条件的时候又重新赋值为1，所以while （status &#x3D; 1）其实就是 while（1），外加scanf （）函数读取指定形式的输入失败，它会把 q 留下，在下一次循环的时候继续读取，这样就会形成一个无限失败的循环。</p><p><strong>Tip：这就提醒了我们不要在本应该使用 &#x3D;&#x3D; 的地方使用 &#x3D; ，等于和赋值是两个完全不同的概念。</strong></p><p>为了避免这样的错误，有经验的程序员在构建比较是否相等的表达式时，都会习惯把常量放在左侧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>； <span class="comment">//赋值</span></span><br><span class="line">a == <span class="number">5</span>; <span class="comment">//a是否等于5</span></span><br><span class="line"><span class="number">5</span> = a； <span class="comment">//语法错误</span></span><br><span class="line"><span class="number">5</span> == a； <span class="comment">//效果等于第二行</span></span><br></pre></td></tr></table></figure><p>总之，关系运算符用于构成关系表达式，真时值为1，假时值为0。通常用关系表达式作为测试语句条件，非零为真，零为假。</p><h2 id="新的-Bool类型"><a href="#新的-Bool类型" class="headerlink" title="新的_Bool类型"></a>新的_Bool类型</h2><p>在C语言中，一般来说是使用int类型的变量表示真假值，之前也介绍过新的标准中新增了_Bool类型，但是布尔类型只能存储0和1，如果把其他数值赋值给布尔类型，变量都会被设置为1。</p><p>若是我们使用布尔类型对上面的程序进行更改优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> num;</span><br><span class="line"><span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="type">_Bool</span> input_is_good;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to be summed &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(q to quit): &quot;</span>);</span><br><span class="line">input_is_good = (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (input_is_good)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter next integer (q to quit): &quot;</span>);</span><br><span class="line">input_is_good = (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Those integers sum to %ld.\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的优化在于把容易出错的测试表达式转换到了对于布尔值的赋值，所以这个 scanf(“%ld”, &amp;num) &#x3D;&#x3D; 1 式子只能输出0 和 1 的值，这是为了防止输入多个数字出现错误，但根据C语言的约束条件其实 &#x3D;&#x3D; 1 也可以去掉（根据我自己的实验），加上是为了更加严谨的逻辑。</p><p><strong>Tip：最新的标准中提供了stdbool.h 的头文件，该头文件让bool成为了_Bool的别名，还把true和false定义为1和0的符号常量，最关键的是写出来的代码可以和C++兼容，因为C++把bool、true、false定义为了关键字</strong></p><h2 id="优先级和关系运算符"><a href="#优先级和关系运算符" class="headerlink" title="优先级和关系运算符"></a>优先级和关系运算符</h2><p>关系运算符的优先级比算数运算符（+ -）低，比赋值运算符要高。说明 x &gt; y +2 等同于 x  &gt; （y + 2），x &#x3D; y &gt; 2 等同于 x &#x3D; （y &gt; 2）。</p><p>在关系运算符之中也有两种不同的优先级：</p><p>高优先级组：&lt; 、&lt;&#x3D; 、&gt;、 &gt;&#x3D;</p><p>低优先级组：&#x3D;&#x3D;、!&#x3D;</p><p>和大部分的运算符一样，关系运算符的结合律也是从左往右。</p><p>所以 ex !&#x3D; wye &#x3D;&#x3D;zee这个式子就是先判断ex和wye是否相等然后使用得出来的0或1和zee进行比较，但是这种写法不是首选推荐。</p><p>我们下面列出现在已经学习过的运算符的优先级的表格：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306131357679.png"></p><p>while语句小结：while语句创建了一个循环，一直会重复执行到测试表达式为假或0为止，循环体可以是简单语句，也可以是复合语句。</p><h1 id="不确定循环和计数循环"><a href="#不确定循环和计数循环" class="headerlink" title="不确定循环和计数循环"></a>不确定循环和计数循环</h1><p>在实际的运用之中，一些while循环是不确定循环，所谓的不确定循环是指在测试表达式为假之前，不知道需要执行多少次循环，就像前面一个和用户交互计算整数之和的程序；还有另外一类就是计数循环，提前设定好需要循环的次数。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">22</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (count &lt; NUMBER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Be my Valentine!\n&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成之后，得到如下结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306131414274.png"></p><p>从上面这个程序中，我们可以知道创建一个重复执行固定次数的循环涉及三个要点：</p><p>1.必须初始化计数器</p><p>2.计数器和有限值做比较</p><p>3.每次循环时递增计数器</p><p>while循环的测试条件执行比较，递增运算符执行递增，上述程序把递增放在最后会避免忘记，比将测试条件和更新组合放到一起要更好，但是计数器的初始化放在循环外，就很有可能会忘记初始化，实践告诉我们可能会发生的事终究还是会发生。下面来学习另外一种循环：for循环。</p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>上面说到了三个行为（初始化、测试和更新），for循环把这三个行为组合在了一处，先来使用for循环对上面这个程序进行优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">22</span>;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; NUMBER; count++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Be my Valentine!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序实现的效果和之前的一摸一样，for关键字后面的圆括号中有三个表达式，分别使用两个分号隔开，第一个表达式是初始化，只会在循环开始时执行一次，第二个是测试条件，第三个是执行更新，for循环语句后面还有简单语句和复合语句，for圆括号中的表达式也叫做控制表达式，都是完整表达式，每个表达式的副作用都发生在对下一个表达式求值之前。</p><p>接下来使用for循环来创建一个立方表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nn cubed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (num = <span class="number">1</span>; num &lt;= <span class="number">6</span>; num++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d %5d\n&quot;</span>, num, num*num*num)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个数字1-6的立方表。</p><p>for循环的第一行包含了循环的所需的信息：初值，终值，每次循环所需的增量。</p><h2 id="利用for循环的灵活性"><a href="#利用for循环的灵活性" class="headerlink" title="利用for循环的灵活性"></a>利用for循环的灵活性</h2><p>for循环相较于while循环拥有更多的灵活性主要取决于for循环的三个表达式，除了像上面一样进行递增的计数器，for循环还有其他的九种用法：</p><p>1.将递增运算符换成递减运算符变成递减计数器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> secs;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (secs = <span class="number">5</span>; secs &gt; <span class="number">0</span>; secs--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d seconds!\n&quot;</span>, secs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;we have ignition!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.可以让计数器递增2、10等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &lt; <span class="number">60</span>; n += <span class="number">13</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.可以使用字符代替数字计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ch = <span class="string">&#x27;a&#x27;</span>; ch &lt; <span class="string">&#x27;z&#x27;</span>; ch++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The ASCII value for %c is %d.\n&quot;</span>, ch, ch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序本质上还是使用整数来计数的。</p><p>对于控制的条件我们可以根据自己的需求进行特殊的更改：</p><p>4.让递增的量几何增长</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> debt;</span><br><span class="line">    <span class="keyword">for</span> (debt = <span class="number">100.0</span>; debt &lt; <span class="number">150.0</span>; debt = debt * <span class="number">1.1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Your debt is now $%.2f.\n&quot;</span>, debt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多其他的例子在这里就不逐个展示了，其中在for循环中也可以省略一个或者多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。</p><p><strong>Tip：顺带一提，省略第2个表达式被视为真，所以下面的循环会一直运行：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; ; )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I want some action\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>在第一个表达式不一定是给变量赋初值，也可以使用 printf（）。在执行循环的其他部分之前，只对第一个表达式求值一次或执行一次。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">printf</span>(<span class="string">&quot;Keep entering numbers!\n&quot;</span>); num != <span class="number">6</span>;)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s the one I want!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306151508104.png"></p><p>上面是程序的执行结果。</p><p>但是若是我们创建了以下的循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(n = <span class="number">1</span>; n &lt; <span class="number">10000</span>; n = n + delta)</span><br></pre></td></tr></table></figure><p>这句话经过几次迭代后会发现delta太小或者太大了，循环中的if语句才可以改变delta的大小，但是这样做也会有危险的一面，就是把delta设置为0了。</p><p>小结：</p><p>for语句使用3个表达式控制循环过程，分别使用分号隔开，initialize表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真（或非零），执行循环一次；接着对update表达式求值，并再次检查test表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。</p><p>形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( initialize; test; update )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>在test为0或者假之前，重复执行statement的内容。</p><h1 id="其他赋值运算符：-x3D-，-x3D-，-x3D-，-x2F-x3D-，-x3D"><a href="#其他赋值运算符：-x3D-，-x3D-，-x3D-，-x2F-x3D-，-x3D" class="headerlink" title="其他赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;"></a>其他赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</h1><p>C语言有许多赋值运算符，最基本、最常用的是&#x3D;，它属于赋值运算符，其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306211645228.png"></p><h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><p>逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FIRST_OZ = <span class="number">46</span>; <span class="comment">// 2013邮资</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NEXT_OZ = <span class="number">20</span>; <span class="comment">// 2013邮资</span></span><br><span class="line"><span class="type">int</span> ounces, cost;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ounces cost\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ounces = <span class="number">1</span>, cost = FIRST_OZ; ounces &lt;= <span class="number">16</span>;</span><br><span class="line">ounces++, cost += NEXT_OZ)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d $%4.2f\n&quot;</span>, ounces, cost / <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序在初始化表达式和更新表达式中使用了逗号运算符，初始化表达式中的逗号使得ounces和cost都进行了初始化，绝大多数计算都在for循环头中进行。逗号运算符并不局限于在for循环，但是这是它常用的地方。</p><p>例子：house &#x3D; 249，500; 其实等同于house &#x3D; 249;</p><p>​    house &#x3D; （249，500）; 也是赋值表达式，得到最终的结果是500。</p><p>逗号也可以作为分隔符号，在下面的语句中就是分隔符，不是逗号运算符。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch，date；</span><br><span class="line"><span class="built_in">printf</span>（<span class="string">&quot;%d%d\n&quot;</span>, chimps,chumps）;</span><br></pre></td></tr></table></figure><p>小结：</p><p>赋值运算符：</p><p>+&#x3D; 把右侧的值加到左侧的变量上<br>-&#x3D; 从左侧的变量中减去右侧的值<br>*&#x3D; 把左侧的变量乘以右侧的值<br>&#x2F;&#x3D; 把左侧的变量除以右侧的值<br>%&#x3D; 左侧变量除以右侧值得到的余数</p><p><strong>Tips：这些组合赋值运算符与普通赋值运算符的优先级相同，都比算术运算符的优先级低。</strong></p><h2 id="当zeno遇到for循环"><a href="#当zeno遇到for循环" class="headerlink" title="当zeno遇到for循环"></a>当zeno遇到for循环</h2><p>我们运用for循环和逗号表达式来解决Zeno悖论：</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t_ct; </span><br><span class="line"><span class="type">double</span> time, power_of_2;</span><br><span class="line"><span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of terms you want: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;limit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (time = <span class="number">0</span>, power_of_2 = <span class="number">1</span>, t_ct = <span class="number">1</span>; t_ct &lt;= limit;</span><br><span class="line">t_ct++, power_of_2 *= <span class="number">2.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">time += <span class="number">1.0</span> / power_of_2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;time = %f when terms = %d.\n&quot;</span>, time, t_ct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要输入限制的次数，即可得到次数限制内时间之和，通过for循环和逗号表达式更加减少了变量赋值的过程，构建完循环程序之后就相当于完成了程序的编写，大大简化了程序。</p><h1 id="出口条件循环：do-while"><a href="#出口条件循环：do-while" class="headerlink" title="出口条件循环：do while"></a>出口条件循环：do while</h1><p>while循环和for循环都是入口条件循环，就是在每次迭代之前检查测试条件，所以会出现不执行循环体的内容，C语言还有出口条件循环，就是在迭代之后再来检查测试条件，这就保证了循环体至少执行一次，被称为do while循环。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> secret_code = <span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> code_entered;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To enter the triskaidekaphobia therapy club,\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter the secret code number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code_entered);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (code_entered != secret_code);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Congratulations! You are cured!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306270011783.png"></p><p>当然我们使用while循环也可以得到相同的效果，但是代码相较于使用do while的程序就会复杂不少，首先多出来的一段代码就是do while循环提前输出的这段。</p><p>while循环下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> secret_code = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> code_entered;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;To enter the triskaidekaphobia therapy club,\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter the secret code number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code_entered);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (code_entered != secret_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To enter the triskaidekaphobia therapy club,\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter the secret code number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code_entered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulations! You are cured!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序相较于上一个程序来说就复杂的多了。</p><p>那么do while循环的通用形式：</p><p>do</p><p>statement</p><p>while（expression）；</p><p>statement是一条简单语句或者是复合语句。do while循环最适合那些至少要迭代一次的循环（比较适合密码锁这类场合），若是询问类的则没有这么适合，因为这类都是需要先决条件，使用do while循环的话会迟滞结果的得出。</p><p>总的来说，需要注意的点就是do while循环无论条件判定如何，都会执行一次，这也是它和while循环和for循环的不同之处。</p><h1 id="如何选择循环"><a href="#如何选择循环" class="headerlink" title="如何选择循环"></a>如何选择循环</h1><p>上面我们介绍了while循环，for循环，do while循环三种不同的循环，三个循环各有特点和优势，那么应该如何最大化的提高效率去使用就是这一小结需要学习的了。</p><p>首先我们需要确定的是需要入口条件循环还是出口条件循环，一般来说，入口条件循环用的多一些，因为在执行循环前还是先测试条件比较好，其次，测试条件放在开头会使得程序的可读性更高。</p><p>若是选择入口条件循环，for循环和while循环其实都可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ,test, ) <span class="comment">//其实就是while循环</span></span><br><span class="line"><span class="keyword">while</span> (test) <span class="comment">//这两个式子本质相同</span></span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line"><span class="keyword">while</span> (测试)</span><br><span class="line">&#123;</span><br><span class="line">    其他语句；</span><br><span class="line">    更新语句；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (初始化;测试;更新语句)</span><br><span class="line">&#123;</span><br><span class="line">    其他语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是两者之间的互相转换，主要是看使用者的习惯。当然一般而言，当我们的循环涉及到初始化和更新变量时，使用for循环比较合适，而其他情况下还是while循环更合适。</p><h1 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h1><p>嵌套循环是指在一个循环内包含另外一个循环，嵌套循环主要常用于按行和按列显示数据。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; ROWS; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ch = <span class="string">&#x27;A&#x27;</span>; ch &lt; (<span class="string">&#x27;A&#x27;</span> + CHARS); ch++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序中，第10行的循环属于是外层循环，第12行开始是属于内层循环，内层循环10次打印了A到 J ，外层循环接着换行，进行下一次的外层循环，一共会打印出6行10列的字母。</p><p>嵌套循环的变式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ROWS <span class="number">6</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> CHARS <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; ROWS; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ch = (<span class="string">&#x27;A&#x27;</span> + row); ch &lt; (<span class="string">&#x27;A&#x27;</span> + CHARS); ch++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实本质并未改变，只是添加了打印需要参考行数的变化。</p><h1 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h1><p>在C语言中，数组很重要，可以作为一种储存多个相关项的便利方式，之后会详细学习数组，但是在循环中会使用数组，先在这里简单进行介绍。</p><p>数组是按顺序储存的一系列类型相同的值，比如10个char类型的字符或者15 int类型的值。整个数组有一个数组名，通过整数下标来访问数组中单独的项。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> debts[<span class="number">20</span>]; <span class="comment">//这就是创建了一个浮点型的数组</span></span><br><span class="line">debts[<span class="number">5</span>] = <span class="number">3.14159</span>; <span class="comment">//数组的第六个元素的值是3.14159</span></span><br><span class="line">debts[<span class="number">9</span>] = <span class="number">0.915814</span>; <span class="comment">//数组的第十个元素是0.915814</span></span><br></pre></td></tr></table></figure><p>实际上，使用数组元素和使用同类型的变量一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;debts[<span class="number">6</span>]); <span class="comment">//将读入的数据放到第七个位置上</span></span><br></pre></td></tr></table></figure><p>**Tips：这里需要注意一个潜在的陷阱，C编译器一般不会检查数组的下标是否正确:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debts[<span class="number">20</span>] = <span class="number">88.32</span>; <span class="comment">//这其实是不正确的</span></span><br></pre></td></tr></table></figure><p>但是面对上述错误，编译器不会查找出来，当程序运行时会导致数据被放置在已经被其他数据占用的地方，会破坏程序的正常运行。</p><p>数组的数据类型可以是任意的数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nannies[<span class="number">22</span>]; <span class="comment">//可储存22个int类型整数的数组</span></span><br><span class="line"><span class="type">char</span> actors[<span class="number">26</span>]; <span class="comment">//可储存26个字符的数组</span></span><br><span class="line"><span class="type">long</span> big[<span class="number">500</span>]; <span class="comment">//可储存500个long类型整数的数组</span></span><br></pre></td></tr></table></figure><p>说到数组就不得不提到在字符串那篇中，可以把字符串储存在char类型的数组中，若是在末尾加上空字符 \0，那么就是字符串了。</p><p>用于识别数组元素的数字被称为是下标，下标必须是整数，而且要从0开始计数，数组的元素被依次存在内存相邻的位置。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306271421616.png"></p><h2 id="数组在for循环中的应用"><a href="#数组在for循环中的应用" class="headerlink" title="数组在for循环中的应用"></a>数组在for循环中的应用</h2><p>程序许多地方都要使用到数组，下面是一个比较简单的例子。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAR 72</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index, score[SIZE];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> average;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter %d golf scores:\n&quot;</span>, SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score[index]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The scores read in are as follows:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, score[index]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index++)</span><br><span class="line">        sum += score[index];</span><br><span class="line">    average = (<span class="type">float</span>)sum/SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of scores = %d, average = %.2f\n&quot;</span>, sum, average);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s a handicap of %.0f.\n&quot;</span>, average - PAR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序大大简化了取数值的麻烦，不用再一个一个的取读，而且在程序开头就采用了明示常量方便以后对数组进行扩展的操作，当然在在读取时数组下角标的方式就是int类型的变量，也需要我们注意，当然这个程序还可以进行优化，可以发现这个程序的三个独立循环都是使用一个条件，可以进行合并和简化使得结构更加紧凑。</p><h1 id="利用返回值的循环"><a href="#利用返回值的循环" class="headerlink" title="利用返回值的循环"></a>利用返回值的循环</h1><p>最后一个程序是要利用一个函数计算数的整数次幂（math.h库中提供了一个强大的幂函数pow()）。</p><p>既然是需要计算数的整数次幂，那么循环就是必不可少的，设计一个循环将 n 相乘p 次就可以得到整数次幂：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p; i++)</span><br><span class="line"><span class="built_in">pow</span> *= n; <span class="comment">//pow的初值设为1</span></span><br></pre></td></tr></table></figure><p>要编写一个有返回值的函数，我们需要完成以下的内容：</p><p>1.定义函数时，确定函数的返回类型。</p><p>2.使用关键字return表明待返回的值。</p><p>接下来我们尝试写一下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> n, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p; i++)</span><br><span class="line">        <span class="built_in">pow</span> *= n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序展示的是名为power的函数，返回值可以一个变量的值，也可以是表达式的值。</p><p>接下来我们来使用这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> n, <span class="type">int</span> p)</span>; <span class="comment">// ANSI函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> x, xpow;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a number and the positive integer power&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; to which\nthe number will be raised. Enter q&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; to quit.\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lf%d&quot;</span>, &amp;x, &amp;<span class="built_in">exp</span>) == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">xpow = power(x, <span class="built_in">exp</span>); <span class="comment">// 函数调用</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3g to the power %d is %.5g\n&quot;</span>, x, <span class="built_in">exp</span>, xpow);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter next pair of numbers or q to quit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hope you enjoyed this power trip -- bye!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> n, <span class="type">int</span> p)</span> <span class="comment">// 函数定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line"><span class="built_in">pow</span> *= n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">// 返回pow的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个程序中的main（）函数是一个测试函数，就是被设计用来测试函数的小程序，程序的while循环的判断条件是之前讨论过的形式，利用scanf（）函数的返回值进行判断，读取两个数就能够进入循环，剩下的就是power（）函数的内容了，一共出现了三次，第一次是声明，第二次是使用，第三次是函数定义，power（）函数有两个形参，一个是double类型，一个是int类型。</p><p><strong>Tip：函数定义的末尾没有分号，而函数原型的末尾有分号。在函数头后面花括号中的内容，就是power()完成任务的代码。</strong></p><p>在我们使用带返回值的函数时，声明函数、调用函数、定义函数、使用关键字return都是其中的基本要素。</p><p>对于定义中说明了power（）函数的返回类型是double，为什么还要提前声明，其实如果把函数定义放在main（）函数之前，就可以不用前置声明了，但是这不是很符合C语言的习惯，所以前置声明是必不可少的。那为什么scanf（）函数就可以直接使用，是因为在头文件中包含了函数的原型表明。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-shell进程</title>
      <link href="/2023/05/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-shell%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/05/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-shell%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中，已经介绍了些许系统管理员和程序员用到的一些高级bash指令，那么这篇我们将介绍shell进程的技巧。</p><h1 id="shell类型"><a href="#shell类型" class="headerlink" title="shell类型"></a>shell类型</h1><p>一般来说，系统启动什么样的shell进程取决于个人的ID设置，在&#x2F;etc&#x2F;passwd文件中我们可以看到ID的记录，只要登录，默认的虚拟shell程序就会运行。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301250891.png"></p><p>在现在使用的ubuntu版本上，默认的系统shell和默认的交互shell并不一致，默认的交互shell是&#x2F;bin&#x2F;bash，但是作为系统的默认shell却是&#x2F;bin&#x2F;sh被设置成dash shell。</p><p><strong>Tip：对bash shell脚本来说，这两种不同的shell（默认的交互shell和默认的系统shell）会造成问题。</strong></p><p>我们可以直接采用&#x2F;bin&#x2F;dash的指令进入dash shell程序，$提示符是dash的标志，若是需要退出，我们只需要键入exit指令即可。</p><p>在下一节将探究shell程序和新启动的shell程序之间的关系。</p><h1 id="shell的父子关系"><a href="#shell的父子关系" class="headerlink" title="shell的父子关系"></a>shell的父子关系</h1><p>了解关系之前，需要知道什么是父shell，一般来说用于登录控制器终端或者在终端仿真器所启动的默认shell就是一个父shell，然后等待命令的输入。</p><p>在命令行输入&#x2F;bin&#x2F;dash的命令之后会创建一个全新的shell程序，那么这个程序就被称为子shell，也同样会等待命令的输入。</p><p>当我们生成子shell的时候，需要使用ps -f命令来帮助我们理清这一切，这个命令显示出显示出现有的进程：<br><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301308271.png"></p><p>在我们输入命令之后，一个子shell就出现了，第二个ps -f 是在子shell中执行的，其实在PID和PPID这两个号码之间，我们也能够看出端倪，现有的ID都是由父shell所创建而成。</p><p>在生成子shell进程时，只有部分的父进程的环境会被复制到子shell环境中，这会对包括变量在内的一些东西造成影响，子shell可以从父shell中创建，也可以从另一个子shell中创建（相当于一个树形结构中的分支）。</p><p>bash shell程序可以使用命令行参数修改shell的启动方式：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301320028.png"></p><p>还有更多的参数可以使用man命令详细查看。</p><h2 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h2><p>为了避免命令过多需要一个又一个的输入，我们可以在一行中一次运行一系列的命令，这就是命令列表，只需要在命令之间加入分号（；）即可。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301326479.png"></p><p>该实例中命令依次执行，不存在任何的问题，但这也仅仅是命令列表，不是进程列表，若是要变成进程列表，这些命令必须包含在括号中。</p><p>多了括号之后，在最终的结果来看并没有什么不同，但是多了括号之后，使得命令列表变成进程列表，生成一个子shell来执行对应的指令。</p><p><strong>Tip：进程列表是一种命令分组（command grouping）。另一种命令分组是将命令放入花括号中，并在命令列表尾部加上分号（;）。语法为{ command; }。使用花括号进行命令分组并不会像进程列表那样创建出子shell。</strong></p><p>在这个实例中最值得关注的就是是否生成子shell，我们需要借助一个环境变量来查看：（echo $BASH_SUBSHELL）。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301338554.png"></p><p>如上图所示，显示的数字是0，说明这些命令不是在子shell中运行的。</p><p>若是使用进程列表的话，最后输出的数字会是1。甚至我们还可以命令列表中嵌套括号来创建子shell。</p><p><strong>Tip：在shell脚本中，经常会使用子shell进行多线程处理，但是利用子shell的成本不菲，会明显的拖慢处理的速度，在一般交互式的shell会话中，子shell同样会存在问题。</strong></p><h2 id="子shell的用法"><a href="#子shell的用法" class="headerlink" title="子shell的用法"></a>子shell的用法</h2><p>在交互式shell中，一个高效的子shell用法就是使用后台模式。</p><p>后台模式：运行命令可以在处理命令的同时让出CLI，以作他用。其中经典命令就是sleep。</p><p>sleep：接受一个参数，参数是希望进程等待的秒数，返回CLI提示符。</p><p>若是我们想要将命令置入后台模式，可以在命令末尾加上字符&amp;。当命令被置入后台，在CLI提示符返回之前会出现两个信息，第一个信息是显示在方括号中的后台作业号，第二个是后台作业的进程ID。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301400631.png"></p><p>后台作业号是2，进程ID是9370。</p><p>在这里我们除了使用ps命令来查看进程信息，也可以使用jobs命令来显示后台作业信息。</p><p>jobs命令：可以显示当前在进行作业的进程的信息。</p><p>方括号中是作业号，第二个是作业状态，以及对应的命令。</p><p>利用jobs命令中的-l选项，还可以看到更多相关的信息，还能显示PID。后台作业结束后就会显示已完成的状态。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301412495.png"></p><p><strong>Tip：需要提醒的是，后台作业的结束状态不是一直等待到合适的时候才会现身，会突然出现在屏幕上。</strong></p><p>上面是将命令置入后台，若是我们将进程列表置入后台会有什么不一样的效果嘛</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301420387.png"></p><p>在CLI中运用子shell较好的方法之一就是将进程列表置入后台模式，既可以在子shell之中进行处理工作，也不会让子shell的I&#x2F;O受制于终端。</p><p>除了将进程列表置入后台模式之外，还有另外一种方法也可以—协程。</p><p>协程：同时做两件事，在后台生成一个子shell，并在这个子shell之中执行命令。</p><p>命令：coproc  command</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301432894.png"></p><p>同样的jobs命令可以显示协程的处理状态。</p><p>从上面的例子我们可以看到，子shell执行的后台指令是coproc COPROC sleep 10。COPROC是coprco命令给进程取的名字，我们自己可以使用扩展语法设置这个名字：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301437168.png"></p><p>当然，使用扩展语法写起来还是有些许的麻烦，必须确保第一个花括号和命令之间有一个空格，结尾亦是如此。</p><p><strong>Tip：协程使用起来非常的方便，只有当我们拥有多个协程的时候才需要对其命名，需要和它们进行通信。</strong></p><p>协程和进程列表结合起来可以产生嵌套的子shell，只需要输入进程列表，然后在列表前加上命令coproc就可以了。</p><p>简单的介绍了子shell的几个用途，接下来我们来研究内建命令和外部命令的差异。</p><h1 id="shell的内建命令"><a href="#shell的内建命令" class="headerlink" title="shell的内建命令"></a>shell的内建命令</h1><p>在shell的学习过程中，我们可能听说过内建命令和非内建命令（外部命令），这两种命令的操作方式也是大不相同。</p><h2 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h2><p>外部命令有时候也被称为文件系统命令，是存在于bash之外的程序，外部命令一般可能存在于&#x2F;bin，&#x2F;usr&#x2F;bin之中。</p><p>ps命令其实就是一个外部命令，可以使用which和type命令来找到它，当外部命令执行的时候，会创建出一个子进程，这种操作被称为衍生，ps命令可以很方便的显示出它的父进程及对应的衍生程序。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031413558.png"></p><p><strong>Tip：就算衍生出子进程或是创建了子shell，仍然可以通过发送信号与其沟通，这一点在命令行和脚本编写都是很有用的。</strong></p><h2 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h2><p>要说内建命令和外部命令的区别主要在于内建命令不需要使用子进程来执行，它们已经和shell编译成一体了，作为shell工具的组成部分，不用借助外部程序文件来运行。</p><p>cd和exit命令都内建于bash shell，也可以使用type命令来进行查看。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031420496.png"></p><p><strong>Tip：既不需要衍生出子进程来执行，也不需要打开程序文件，执行速度更快，效率也更高。</strong></p><p>当然命令也不是这两种的分类，有些命令更是两者兼而有之，例如echo和pwd。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031423099.png"></p><p>有一点需要注意，which命令只能显示外部命令文件，对于有多种实现的命令，我们若是想要外部命令来实现，可以直接输入&#x2F;bin&#x2F;pwd。</p><h3 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h3><p>一个比较有用的内建命令是history命令，shell会跟踪使用过的命令，可以召回这些命令并且再次使用。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031431350.png"></p><p>一般来说记录的命令会非常的多，需要谨慎使用。</p><p><strong>Tip：我们可以设置保存在bash历史记录的命令数，要想实现这一点，需要修改名为HISTSIZE的环境变量。</strong></p><p>若是我们只是需要唤回并使用最近的命令，只需要输入！！即可。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031438986.png"></p><p>命令历史记录是被保存在隐藏的文件.bash_history中，位于主目录里，bash命令是先存放在内存中，当shell退出才写进历史文件。但是我们可以在退出会话之前将命令历史记录写入.bash_history文件，为了实现强制写入，需要使用history中的-a选项。</p><p>history和.bash_history的输出是一样的，除了最近的那条命令。</p><p><strong>Tip：若是打开了多个终端会话，仍然可以使用history -a命令在打开的会话中向文件中添加记录，对于其他的终端会话，该命令却不会向里面添加记录，若是想要更新终端会话，可以使用history -n命令。</strong></p><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>alias命令是另一个shell的内建命令，命令别名允许为常用的命令创建另一个名称，降低输入量。</p><p>一般来说在系统初始会预设一些命令别名：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031514519.png"></p><p>自己也可以创建命令的别名：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031517760.png"></p><p>这个时候，我们就可以使用 li 命令来代替 ls -li 了。这个时候我们随时都可以使用它，在shell脚本中也可以，但是命令别名属于内部命令，一个别名只在被定义的shell进程中才有效。当然是有方法可以解决的，在之后的学习中会讲到。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此篇主要是讨论了shell，包括shell进程及其关系，还有子shell，以及那些能够创建子进程的命令和不能创建子进程的命令。</p><p>1.当我们登录终端时，一般会启动一个交互式shell，系统启动那个主要取决于用户的配置，一般是bash或者dash。</p><p>2.子shell可以利用bash来生成，或者是使用进程列表，coproc命令也会产生shell，子shell也可以嵌套，生成子shell的子shell。</p><p>3.最后学习两种类型的命令：内建命令和外部命令。</p><p>下一篇将会学习linux的环境变量。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-BERT-Bilstm-CRF命名实体识别</title>
      <link href="/2023/05/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-BERT-Bilstm-CRF%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
      <url>/2023/05/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-BERT-Bilstm-CRF%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>这篇博客用来记录导师项目中碰到的问题以及解决方法！</p><p>这周在结束了模型的训练和项目结构的初步理解，问题渐渐转到了获取数据集和对于新的数据集的训练和三元组的提取，下面是项目的结构:</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301517904.png"></p><p>此次的项目主要是为了实现橡胶挤塑机的故障预警和故障溯源，我的想法是希望通过机器运行过程中产生的日志中的文本信息进行命名实体抽取，在形成三元组之后存入图数据库（neo4j）之中，在工业机器出现该故障之后，可以及时查询到整个完整的故障链路和可能出现的分支情况，也能够对新出现的故障进行及时的增删改查。</p><p>那么第一步对于非结构化的文本和半结构化的文本的处理就显得较为重要。</p><p>这周汇报时，针对matlab生成日志问题，导师解答了疑惑，其实需要我自己写txt文件的判断语句，通过生成的数据是否产生偏差可以读取出故障，那么针对这个问题，首先分为两步，首先，提取出的三元组应当是故障——&gt;问题的结构，但是对于此次的文本来说，一个故障的出现可能是2个或者2个以上的变量同时影响而得到的，不过这对于标注来说并不是什么大问题，我采用一个标注软件就能解决：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061651673.png"></p><p>如上图所示，这是一个模糊控制的简单例子中的四条规则，我们将其提炼总结之后可以得到我们的故障文本，其中里面包含故障前因，故障，故障后果，其中的故障f1、f2和f3 如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061656085.png"></p><p>分别是三个故障。</p><p>提炼总结后的中文文本：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061657717.png"></p><p>得到故障文本之后，我们就开始对其进行处理，使用标注软件和脚本对其进行处理，并将其上传到neo4j数据库之中：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061704023.png"></p><p>这样就说明我们提取三元组成功并且上传到数据库里了。那么接下来我们需要从模型中使用具体的数据来看看是否可以从其中提取出不同条件下出现的故障以及是否正确提取。</p><p>在matlab中打开模型，设定好参数后，运行simulink，得到我们需要的数据：</p><p>level.xlsx和flowout.xlsx两个数据文件</p><p>提取数据的命令：xlwrite（’level.xlsx’,level)</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061712729.png"></p><p>如图所示</p><p>接下来我们对数据进行处理，希望可以得到在flowout和level同时满足条件时输出正确的故障。代码如下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061713265.png"></p><p>上述代码还有错误，有待修改。（并未导入level.xlsx的数据），不过上述代码可以得到我想要的结果，那就是在flowout小于0.0032时输出正确的文字，接下来只要加入level的数据再做尝试。</p><p>接下来我们来导入level的数据进行下一步的处理，</p>]]></content>
      
      
      <categories>
          
          <category> 导师项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-运算符、表达式和语句</title>
      <link href="/2023/05/12/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/05/12/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>上一篇博客我们结束了对格式化字符串的输入输出的介绍和学习，这一篇博客我们将学习如何来处理数据，处理方式：算数运算、比较值的大小、修改变量、各种逻辑的组合关系等。</p><p><strong>Tip：此篇中我们还学习循环这个编程中最强大的特性。</strong></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>为什么我们需要使用循环，因为若是完成单一的工作，编写程序的工作量远不如人完成的快速有效率，计算机需要帮助我们完成的就是重复计算的工作，C中有相当多的方法可以去做重复计算，这里先简单的介绍一种——while循环。</p><p>如下所示，在有或没有循环两种情况下的代码的效率：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121448492.png"></p><p>无循环，只能输出单个的结果。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121459096.png"></p><p>加入while循环，可以输出多个结果。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121503058.png"></p><p>从这里我们可以得出结论，在进行重复运算时，计算机相较于人有显著的优势。</p><p>while循环的原理：</p><p>当程序第一次到达循环时，会检查圆括号中的条件是否为真，在上述例子中条件表达式：shoe &lt; 18.5。初始鞋码为3.0，条件为真，程序将进入循环执行，将尺码转化为英寸，进行打印结果，在最后给shoe增加1.0，返回while入口检查条件，while下两个花括号括起来的称为块。返回入口时会再次进行判断，直至循环结束。</p><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><p>在C中使用运算符表示算数运算，除开基本运算符以外，C没有指数运算符，不过C标准库提供一个<strong>pow（）函数</strong>用于指数运算：pow（3.5， 2.2）表示3.5的2.2次幂。</p><p><strong>Tip：在使用Pow（）函数时需先导入math.h的头文件，且在编译时需要在gcc mi.c -o mi 后加上 -lm才能编译成功。（链接math头文件）。</strong></p><h2 id="赋值运算符：-x3D"><a href="#赋值运算符：-x3D" class="headerlink" title="赋值运算符：&#x3D;"></a>赋值运算符：&#x3D;</h2><p>对于这个运算符应该都不陌生，不是常规数学中的等于号意味着相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bmw = <span class="number">2000</span>；</span><br></pre></td></tr></table></figure><p>上述语句就是把2000这个数值赋给bmw这个变量，赋值行从右往左进行。</p><p>变量名和变量值的区别看似区别不大，那么下面这个语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>这在数学上来说是完全行不通的，但是在赋值语句中就是常规的对变量加1并且赋值给 原变量的过程。在编写代码的过程中，&#x3D; 号左侧必须是一个变量名，右侧是一个常量或者表达式。</p><p><strong>几个术语：数据对象、左值、右值和运算符</strong></p><p>数据对象：存储值的数据存储区域称为数据对象。一般使用变量名来标识对象，还有指定数组的元素、结构的成员、使用指针表达式等。（房间）</p><p>左值：用于标识特定数据对象的名称或者表达式。（房间号）</p><p>前篇提到过的 const 限定符也是变量名却不能被赋值，所以左值就变成了可修改的左值。</p><p>右值：指能赋值给可修改左值的量，且本身不是左值。可以是常量、变量或者可求值的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ex;</span><br><span class="line"><span class="type">int</span> why;</span><br><span class="line"><span class="type">int</span> zee;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TWO = <span class="number">2</span>;</span><br><span class="line">why = <span class="number">42</span>;</span><br><span class="line">zee = why;</span><br><span class="line">ex = TWO * (why + zee);</span><br></pre></td></tr></table></figure><p>一般来说其他语言会回避程序的三重赋值，但是在C中完全没问题。</p><h2 id="加法运算符："><a href="#加法运算符：" class="headerlink" title="加法运算符：+"></a>加法运算符：+</h2><p>用于加法运算，使得两侧的值相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">4</span> + <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>输出的是24，而不是表达式 4 + 20。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">income = salary + bribes;</span><br></pre></td></tr></table></figure><p>这样的表达式也是可以的，程序会读取右边变量的值并将其相加，然后把和赋值给income。</p><h2 id="减法运算符："><a href="#减法运算符：" class="headerlink" title="减法运算符：-"></a>减法运算符：-</h2><p>同加法运算符理，这两个运算符被称为二元运算符，即需要两个运算符才能完成操作。</p><h2 id="符号运算符"><a href="#符号运算符" class="headerlink" title="符号运算符"></a>符号运算符</h2><p>减号还可以用于标记一个值的代数符号。例如，执行下面的语句后，值会变成12：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rocky = <span class="number">-12</span>;</span><br><span class="line">smokey = -rocky;</span><br></pre></td></tr></table></figure><p>以这种方式使用的负号被称为一元运算符。</p><p><strong>Tip：在最新的标准中，增加了+的一元运算符，仅仅是编译不会报错。</strong></p><h2 id="乘法运算符："><a href="#乘法运算符：" class="headerlink" title="乘法运算符：*"></a>乘法运算符：*</h2><p>符号*表示乘法，并将结果进行赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cm = <span class="number">2.54</span> * inch;</span><br></pre></td></tr></table></figure><p>在C中没有平方函数，我们就可以使用乘法来计算平方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d %6d\n&quot;</span>, num, num * num);</span><br><span class="line">        num = num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另外一个在棋盘中放麦粒也是类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARES 64 <span class="comment">// 棋盘中的方格数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> CROP = <span class="number">2E16</span>; <span class="comment">// 世界小麦年产谷粒数</span></span><br><span class="line"><span class="type">double</span> current, total;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;square grains total &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fraction of \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; added grains &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world total\n&quot;</span>);</span><br><span class="line">total = current = <span class="number">1.0</span>; <span class="comment">/* 从1颗谷粒开始 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d %13.2e %12.2e %12.2e\n&quot;</span>, count, current,</span><br><span class="line">total, total / CROP);</span><br><span class="line"><span class="keyword">while</span> (count &lt; SQUARES)</span><br><span class="line">&#123;</span><br><span class="line">count = count + <span class="number">1</span>;</span><br><span class="line">current = <span class="number">2.0</span> * current; <span class="comment">/* 下一个方格谷粒翻倍 */</span></span><br><span class="line">total = total + current; <span class="comment">/* 更新总数 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d %13.2e %12.2e %12.2e\n&quot;</span>, count, current,</span><br><span class="line">total, total / CROP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中还运用到了while循环。</p><h2 id="除法运算符：-x2F"><a href="#除法运算符：-x2F" class="headerlink" title="除法运算符：&#x2F;"></a>除法运算符：&#x2F;</h2><p>C中使用符号&#x2F;来表示除法，左侧属于被除数，右侧属于除数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four = <span class="number">12.0</span>/<span class="number">3.0</span>；</span><br></pre></td></tr></table></figure><p><strong>Tip：在C语言中，整数除法结果会有小数部分被丢弃，这一过程被称为截断。</strong></p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 5/4 is %d \n&quot;</span>, <span class="number">5</span> / <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 6/3 is %d \n&quot;</span>, <span class="number">6</span> / <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 7/4 is %d \n&quot;</span>, <span class="number">7</span> / <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;floating division: 7./4. is %1.2f \n&quot;</span>, <span class="number">7.</span> / <span class="number">4.</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mixed division: 7./4 is %1.2f \n&quot;</span>, <span class="number">7.</span> / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip：C语言中对于负数的截断一般会舍弃小数部分，称为趋零截断，如-3.8会变成-3。</strong></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>在日常数学运算中，我们都知道要先乘除后加减，那么在C语言中的运算符也有对应的优先级。基本规则差距不大，如下表所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305131429823.png"></p><p><strong>Tip：我们只需要注意+、-的两种不同用法即可</strong></p><h2 id="优先级和求值顺序"><a href="#优先级和求值顺序" class="headerlink" title="优先级和求值顺序"></a>优先级和求值顺序</h2><p>用一个简单的程序就能解释清楚这个问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> top, score;</span><br><span class="line">top = score = -(<span class="number">2</span> + <span class="number">5</span>) * <span class="number">6</span> + (<span class="number">4</span> + <span class="number">3</span> * (<span class="number">2</span> + <span class="number">3</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;top = %d, score = %d\n&quot;</span>, top, score);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的输出结果应当为-23，这和我们在实际数学应用上并无不同。</p><h1 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h1><p>上面介绍的都是C语言中最常用的运算符，接下来我们介绍一些比较有用的运算符。</p><h2 id="sizeof-运算符和size-t类型"><a href="#sizeof-运算符和size-t类型" class="headerlink" title="sizeof 运算符和size_t类型"></a>sizeof 运算符和size_t类型</h2><p>在数据类型那篇文章里最后就介绍了这个运算符。</p><p>功能：以字节为单位返回运算对象大小。</p><p>运算对象：具体的数据对象（变量名）或者类型。</p><p><strong>Tip：若是类型必须使用圆括号括起来。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> intsize;</span><br><span class="line">        intsize = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n = %d, n has %zd bytes; all ints have %zd bytes.\n&quot;</span>,n ,<span class="keyword">sizeof</span> n, intsize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序就展示了这个运算符的功能以及size_t类型的数据。</p><p>在C语言中，sizeof 返回的就是size_t类型，属于无符号整型，不是一个新类型。</p><p><strong>Tip：C还有一个typedef类型，可以允许使用者为现有的类型创建别名，后续再详细介绍。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> real;</span><br></pre></td></tr></table></figure><p>这样一来，real 就是double的别名了，real 类型的变量本质就是double类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">real deal；<span class="comment">//使用typedef</span></span><br></pre></td></tr></table></figure><p><strong>Tip：在最新的标准中，%zd 转换说明用于printf（）显示size_t 类型，若是系统不支持，则可以使用%u 或者%lu来代替%zd。</strong></p><h2 id="求模运算符："><a href="#求模运算符：" class="headerlink" title="求模运算符：%"></a>求模运算符：%</h2><p>功能：给出其左侧整数除以右侧整数的余数。</p><p>例：13%5，得3。</p><p>局限：只能用于整数，不能用于浮点数。</p><p>该运算符在有公约数且需要取余的程序中用处很大。(例如年月分秒)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEC_PER_MIN 60 <span class="comment">// 1分钟60秒</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sec, min, left;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Convert seconds to minutes and seconds!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the number of seconds (&lt;=0 to quit):\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sec); <span class="comment">// 读取秒数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sec &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = sec / SEC_PER_MIN; <span class="comment">// 截断分钟数</span></span><br><span class="line">left = sec % SEC_PER_MIN; <span class="comment">// 剩下的秒数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d seconds is %d minutes, %d seconds.\n&quot;</span>, sec, min, left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter next value (&lt;=0 to quit):\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序是对正数进行求模，那么怎么对负数进行求模呢？</p><p>在最新的标准中，有了趋零截断的规则之后，第一个运算对象是负数，那么求模结果也是负数，若为正数，求模也为正数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> / <span class="number">5</span>得<span class="number">2</span>，<span class="number">11</span> % <span class="number">5</span>得<span class="number">1</span>；</span><br><span class="line"><span class="number">11</span> / <span class="number">-5</span>得<span class="number">-2</span>，<span class="number">11</span> % <span class="number">-5</span> 得<span class="number">1</span>；</span><br><span class="line"><span class="number">-11</span> / <span class="number">5</span>得<span class="number">-2</span>，<span class="number">-11</span> % <span class="number">5</span>得<span class="number">-1</span>；</span><br><span class="line"><span class="number">-11</span> /<span class="number">-5</span>得<span class="number">2</span>，<span class="number">-11</span> % <span class="number">-5</span>得<span class="number">-1</span>；</span><br></pre></td></tr></table></figure><p>若是系统不支持最新的标准，但是只要两个数是整数，就可以使用a - (a&#x2F;b)*b来计算 a % b。</p><h2 id="递增运算符："><a href="#递增运算符：" class="headerlink" title="递增运算符：++"></a>递增运算符：++</h2><p>功能：将其运算对象递增1。</p><p>使用方式：</p><p>1.出现在其作用的变量前面，属于前缀模式</p><p>2.出现在其作用的变量后面，属于后缀模式</p><p>有了这个运算符，我们可以对前面出现的鞋码测脚长的程序进行优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shoe = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">while</span> (shoe &lt; <span class="number">18.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">foot = SCALE * size + ADJUST;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10.1f %20.2f inches\n&quot;</span>, shoe, foot);</span><br><span class="line">++shoe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是将shoe &#x3D; shoe + 1 转换成 ++shoe，还可以进行进一步的精简:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shoe = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">while</span> (++shoe &lt; <span class="number">18.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">foot = SCALE*shoe + ADJUST;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10.1f %20.2f inches\n&quot;</span>, shoe, foot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在这里我们需要注意的是，由于是循环外的递增，所以我们需要将shoe的初始值改成2.0，这样我们的第一个输入值才会是3.0。</p><p><strong>Tip：这样虽然精简了程序，但是也降低了程序的可读性，同时也使得后续排查错误显得更加难。</strong></p><p>当然这两种的使用方式也有区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a_post, pre_b;</span><br><span class="line"></span><br><span class="line">    a_post = a++; <span class="comment">// 后缀递增</span></span><br><span class="line">pre_b = ++b; <span class="comment">// 前缀递增</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a a_post b pre_b \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%1d %5d %5d %5d\n&quot;</span>, a, a_post, b, pre_b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305131553448.png"></p><p>在两个运算符单独使用时，并没有区别，但是在运算表达式中时，后缀是先赋值后递增，而前缀是先递增后赋值。为了避免这样的错误，一般解决方法就是不要这样使用他们，换一种方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = i++；<span class="comment">//不好</span></span><br><span class="line">i++；</span><br><span class="line">b = i; <span class="comment">//较好（换成++i也不会影响b的值）</span></span><br></pre></td></tr></table></figure><h2 id="递减运算符：–"><a href="#递减运算符：–" class="headerlink" title="递减运算符：–"></a>递减运算符：–</h2><p>基本同递增运算符的理，每个++都可以用–来代替。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">101</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (--count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bottles of spring water on the wall, &quot;</span> <span class="string">&quot;%d bottles of spring water!\n&quot;</span>, count, count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Take one down and pass it around,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bottles of spring water!\n&quot;</span>, count<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip：在这个程序中，&lt; &gt;这两个符号表示的是大于号和小于号，都属于关系运算符。</strong></p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>和代数运算一样，递增递减运算符也拥有很高的结合优先级，只有圆括号的优先级比他们高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">2</span>；</span><br><span class="line">n = <span class="number">3</span>；</span><br><span class="line">nextnum = （y + n++）*<span class="number">6</span>；</span><br></pre></td></tr></table></figure><p>上述程序的值应当是30，因为n++是先使用了3而后再进行加1的操作。</p><h2 id="贴心提示"><a href="#贴心提示" class="headerlink" title="贴心提示"></a>贴心提示</h2><p>在同一个程序中，不要一次使用过多的递增运算符，否则会被程序弄晕。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%10d %10d\n&quot;</span>, num, num*num++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序有可能会出现先递增再计算的后果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">25</span> <span class="comment">//原来的结果</span></span><br><span class="line"><span class="number">6</span>  <span class="number">25</span> <span class="comment">//现实的结果</span></span><br></pre></td></tr></table></figure><p>而且同一个语句也可能因为编译器不会按照预想的顺序来执行，所以最好的办法就是不要在一个语句中过多使用递增运算符。</p><p><strong>Tip：1.如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或<br>递减运算符；<br>          2.如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减<br>运算符。</strong></p><h1 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h1><p>C的基本程序步骤由语句组成，而大多数语句都由表达式构成。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式（expression）由运算符和运算对象组成（前面介绍过，运算对象是运算符操作的对象）。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">-6</span></span><br><span class="line"><span class="number">4</span>+<span class="number">21</span></span><br><span class="line">a*(b + c/d)/<span class="number">20</span></span><br><span class="line">q = <span class="number">5</span>*<span class="number">2</span></span><br><span class="line">x = ++q % <span class="number">3</span></span><br><span class="line">q &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>每一个表达式都有一个值，若是有&#x3D;（赋值运算符）即是按照符号的优先级进行计算得出最后的数值；若是&gt;&lt;这些关系运算符，那么这些表达式的值最后都是0或者1，用以表示真假。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句（statement）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">legs = <span class="number">4</span> <span class="comment">//表达式</span></span><br><span class="line">legs = <span class="number">4</span>；<span class="comment">//语句</span></span><br></pre></td></tr></table></figure><p>最简单的语句是空语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">；<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><p><strong>Tip一条完整的指令不一定是一条语句。</strong></p><p>常见语句实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> count, sum;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count++ &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sum = sum + count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序中包含了声明和表达式语句和迭代语句和跳转语句。</p><p><strong>Tip：特殊的就是声明，它不是表达式语句，若是去掉分号也不是一个表达式。</strong></p><p>while语句是一种迭代语句，也被称为结构化语句，相较于简单的赋值表达式语句更加复杂。</p><h3 id="副作用和序列点"><a href="#副作用和序列点" class="headerlink" title="副作用和序列点"></a>副作用和序列点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>上述的语句的副作用就是将变量的值设置为50，其实我也没理解为啥是副作用，书上这么写的，说是对数据对象或文件的修改就叫副作用。</p><p>类似的，我们调用printf（）函数时，显示信息其实是副作用，返回值是显示字符的个数。</p><p>序列点：程序执行的点。</p><p>作用：在该点上，所有的副作用都在进入下一步之前发生。</p><p>在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。</p><p>完整表达式：这个表达式不是另外一个更大表达式的子表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (guests++ &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, guests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此段代码在运行打印函数之前，guests变量就已经递增了，后缀++只是保证了guests是在完成了与10的比较之后才进行递增。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = （<span class="number">4</span> + x++）+ （<span class="number">6</span> + x++）;</span><br></pre></td></tr></table></figure><p>这个式子就会引发歧义，因为4 + x++ 不是一个完整的表达式，所以C无法保证在子表达式求值之后立马递增x，应当避免编写类似的语句。</p><h2 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h2><p>复合语句：用花括号括起来的一条或多条语句，也称为块。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index++ &lt; <span class="number">10</span>)</span><br><span class="line">sam = <span class="number">10</span> * index + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sam = %d\n&quot;</span>, sam);</span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index++ &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">sam = <span class="number">10</span> * index + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sam = %d\n&quot;</span>, sam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然看上去就只差了一对花括号，但是效果却是天差地别。</p><p>代码1：while循环结束之后，printf（）函数只会被调用一次。</p><p>代码2：花括号的存在确保了两条语句都是循环的一部分，每次循环都会执行一次printf（）函数。</p><p>总的来说：</p><p>表达式：由运算符和运算对象组成，最简单的表达式是不带运算符的一个常量或变量。</p><p>语句：主要分为简单语句和复合语句，简单语句就是以一个分号结尾；复合语句是由花括号括起来的一条或者多条语句构成。</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>一般来说，在语句和表达式中应当使用类型相同的变量和常量，若是我们使用混合类型，C语言会采用自己的一套规则进行自动的类型转换，我们应当对此做出了解。</p><p>规则：</p><p>1.当类型转换出现在表达式中时，无论是无符号还是有符号的char或short都会被自动转成int，如有必要会被转换成无符号整型，这些都是从较小类型转换成较大类型，一般被称为升级。</p><p>2.涉及两种类型的运算，两个值一般会被转换成两种类型的更高级别。</p><p>3.类型的级别从高到低依次是是long double、double、float、unsignedlong<br>long、long long、unsigned long、long、unsigned int、int。short和char类型已经被升级为int或者unsigned int了。</p><p>4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型，可能会导致降级。</p><p>5.当作为函数参数传递时，char和short会被自动转换成int，float会被自动转换成为double。</p><p><strong>Tip：一般来说升级不会导致问题，类型降级才会引发一系列的问题。</strong></p><p>若是待转换的值与目标类型不匹配时有以下规则：</p><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256。</p><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> fl;</span><br><span class="line">    </span><br><span class="line">    fl = i = ch = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c, i = %d, fl = %2.2f\n&quot;</span>,ch ,i, fl);</span><br><span class="line">    ch = ch + <span class="number">1</span>;</span><br><span class="line">    i = fl + <span class="number">2</span> * ch;</span><br><span class="line">    fl = <span class="number">2.0</span> * ch + i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c, i = %d, fl = %2.2f\n&quot;</span>,ch ,i ,fl);</span><br><span class="line">    ch = <span class="number">1107</span>;</span><br><span class="line">    pritnf(<span class="string">&quot;Now ch = %c\n&quot;</span>,ch);</span><br><span class="line">    ch = <span class="number">80.89</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now ch = %c\n&quot;</span>,ch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h2><p>一般来说，我们应当避免自动类型转换，尤其是类型降级；但是小心使用，类型转换也是很方便的，前面提到的类型转换都是自动完成的。有时候，我们需要精确的类型转换，我们就需要用到强制类型转换（cast），即在某个量前置圆括号括起来的类型名。</p><p>通用形式：（type），type就是我们需要更改的类型名。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mice = <span class="number">1.6</span> + <span class="number">1.7</span>; <span class="comment">//mice是int类型</span></span><br><span class="line">mice = (<span class="type">int</span>)<span class="number">1.6</span> + (<span class="type">int</span>)<span class="number">1.7</span>; <span class="comment">//根据程序的需要来做取舍。</span></span><br></pre></td></tr></table></figure><p><strong>Tip：一般来说，不应该使用混合类型，偶尔这样做也是有用的，也需要我们自己来承担后果。</strong></p><p>总结运算符：</p><p>赋值运算符：</p><p>&#x3D; 将其右侧的值赋给左侧的变量</p><p>算术运算符：</p><p>+将其左侧的值与右侧的值相加</p><p>-将其左侧的值减去右侧的值</p><p>-作为一元运算符，改变其右侧值的符号</p><p>*将其左侧的值乘以右侧的值</p><p>&#x2F;  将其左侧的值除以右侧的值，如果两数都是整数，计算结果将被截断</p><p>% 当其左侧的值除以右侧的值时，取其余数（只能应用于整数）</p><p>++ 对其右侧的值加1（前缀模式），或对其左侧的值加1（后缀模式）</p><p>– 对其右侧的值减1（前缀模式），或对其左侧的值减1（后缀模式）</p><p>其他运算符：</p><p>sizeof 获得其右侧运算对象的大小（以字节为单位），运算对象可以是一个被圆括</p><p>号括起来的类型说明符，如sizeof(float)，或者是一个具体的变量名、数组名等如</p><p>sizeof foo。</p><p>(类型名) 强制类型转换运算符将其右侧的值转换成圆括号中指定的类型，如(float)9</p><p>把整数9转换成浮点数9.0。</p><h1 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h1><p>带参数的函数应当是比较熟悉了，为了之后自己编写函数，我们需要进一步学习。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pound</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">6.0f</span>;</span><br><span class="line">    </span><br><span class="line">    pound(times);</span><br><span class="line">    pound(ch);</span><br><span class="line">    pound(f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pound</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305211501043.png"></p><p>最终的结果</p><p>我们可以看到在函数头出现的是（int n），这就说明该函数是要接受整型参数，参数名应当遵循C语言的命名规则。</p><p>在声明参数的过程中就创建了形式参数的变量，在该例中，形式参数就是整型变量n，我们称函数调用传递的值为实际参数，简称为实参，函数在调用时就是把实参的值拷贝给了形参n。</p><p><strong>Tip：实参和形参，形参是变量，实参是函数调用提供的值，实参被赋给相应的形参，另外变量名是函数私有的，若是使用times代替pound中的n，对后续使用整型变量times也不会产生影响，最好不要这样做。</strong></p><p>从pound（）函数的原型说明了两点：</p><p>1.该函数没有返回值（<strong>函数名前面有void关键字</strong>）</p><p>对void关键字的解释详见</p><p><a href="https://blog.csdn.net/m0_69909682/article/details/128485569">C语言学习之void关键字_void是c语言关键字吗_忆梦初心的博客-CSDN博客</a></p><p>简单点说就是void前置表示函数可以没有return 0；这句话，若是void出现在参数位置，则说明函数是没有参数传入的。</p><p>2.该函数有一个int类型的参数。</p><p>现在函数声明越来越规范，但是以前的版本可以不用指明参数类型，所以C语言中还存在着void pound（）；这样的函数声明形式，但是这种形式在使用在pound（f）会出现错误，float会被升级为double，虽然能运行，但是输出结果不正确，这个时候只能使用pound（（int）f）；可以解决。</p><h1 id="实例程序"><a href="#实例程序" class="headerlink" title="实例程序"></a>实例程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S_PER_M = <span class="number">60</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S_PER_H = <span class="number">3600</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> M_PER_K = <span class="number">0.62137</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> distk, distm;</span><br><span class="line">    <span class="type">double</span> rate;</span><br><span class="line">    <span class="type">int</span> min, sec;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="type">double</span> mtime;</span><br><span class="line">    <span class="type">int</span> mmin, msec;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program converts your time for a metric race to a time for running a mile and to your average speed in miles per hour.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter, in kilometers, the distance run.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;distk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Next enter the time in minutes and seconds.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Begin by entering the minutes.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;min);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now enter the seconds.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sec);</span><br><span class="line">    </span><br><span class="line">    time = S_PER_M * min + sec; </span><br><span class="line">distm = M_PER_K * distk; </span><br><span class="line">rate = distm / time * S_PER_H;</span><br><span class="line">mtime = (<span class="type">double</span>) time / distm; </span><br><span class="line">mmin = (<span class="type">int</span>) mtime / S_PER_M; </span><br><span class="line">msec = (<span class="type">int</span>) mtime % S_PER_M;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You ran %1.2f km (%1.2f miles) in %d min, %d</span></span><br><span class="line"><span class="string">sec.\n&quot;</span>, distk, distm, min, sec);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That pace corresponds to running a mile in %d</span></span><br><span class="line"><span class="string">min, %d sec.\n&quot;</span>, mmin, msec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your average speed was %1.2f mph.\n&quot;</span>, rate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305211607417.png"></p><p>最后所呈现的效果。</p><h1 id="关键概念和小结"><a href="#关键概念和小结" class="headerlink" title="关键概念和小结"></a>关键概念和小结</h1><p>在C语言的环境中有大量的运算对象的优先级和结合律，主要是在共享一个运算对象时需要注意。</p><p>虽然C语言允许编写混合数值的表达式，尽管如此，不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样可以避免出现不必要的类型转换。</p><p>一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个<br>运算对象的运算符（如负号和 sizeof）称为一元运算符，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为二元运算符。</p><p>在C语言中，许多类型转换都是自动进行的。当char和short类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为int类型；float类型在函数参数中时，会被升级为double类型。</p><p>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。</p><p>到此就结束了对运算符、表达式和语句相关知识的介绍，下一篇将具体学习C语言的控制语句：循环。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-系统管理命令</title>
      <link href="/2023/04/24/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/04/24/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中我们总结了处理文件和目录的指令学习，接下来我们来对Linux的系统管理命令展开学习，这也是我们在开始脚本编程之前需要学习的，如何通过命令行的命令来探查系统内部信息。</p><h1 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h1><p>在Linux系统中最复杂的任务就是跟踪已经在运行的程序，如何探查？</p><h2 id="探查进程"><a href="#探查进程" class="headerlink" title="探查进程"></a>探查进程</h2><p>当程序在Linux系统运行时，我们称之为进程（process）。</p><p>命令：ps </p><p>功能：输出运行在系统上的所有程序的许多信息。</p><p>缺点：稳健而带来的就是复杂性，参数过多（详见man ps），只能显示特定时间点的信息。</p><p>默认情况下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300049523.png"></p><p>例子解析：输出显示了程序的进程ID（process ID，PID），运行的终端（TTY），进程已使用的CPU时间。</p><p><strong>Tip：ps 命令叫人头疼的地方在于它曾经有两个版本。每个版本都有自己的命令行参数集，这些参数控制着输出什么信息以及如何显示。最近，Linux开发人员已经将这两种ps命令格式合并到了单个ps命令中。</strong></p><p>Linux系统主要支持3种类型的命令行参数：</p><p>1.Unix风格的参数，前面加破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300057824.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300058087.png"></p><p>一般来说，我们并不需要记住所有的参数，常用的是ps -ef ；ps -l 这两个命令。</p><p>2.BSD风格的参数，前面不加破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300105635.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300107591.png"></p><p>如上所示，Unix和BSD类型的参数有很多重叠的地方。使用其中某种类型参数得到的信息也同样可以使用另一种获得。大多数情况下，你只要选择自己所喜欢格式的参数类型就行了。</p><p>3.GNU风格的参数，前面是双破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301344251.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301345346.png"></p><p>在GNU长参数中一个着实让人喜爱的功能就是–forest参数。它会显示进程的层级信息，并用ASCII字符绘出可爱的图表。如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301346827.png"></p><p>以上就是对三种风格的参数的简单介绍，我们只需要记住常用的几个命令即可。</p><p>ps -ef 所展示的扩展的信息包含以下几个方面：</p><p>UID：启动这些进程的用户。<br>PID：进程的进程ID。<br>PPID：父进程的进程号（如果该进程是由另一个进程启动的）。<br>C：进程生命周期中的CPU利用率。<br>STIME：进程启动时的系统时间。<br>TTY：进程启动时的终端设备。<br>TIME：运行进程需要的累计CPU时间。<br>CMD：启动的程序名称。</p><p>ps -l 指令多出的那些列：</p><p>F：内核分配给进程的系统标记。<br>S：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止）。<br>PRI：进程的优先级（越大的数字代表越低的优先级）。<br>NI：谦让度值用来参与决定优先级。<br>ADDR：进程的内存地址。<br>SZ：假如进程被换出，所需交换空间的大致大小。<br>WCHAN：进程休眠的内核函数的地址。</p><h2 id="实时监测进程"><a href="#实时监测进程" class="headerlink" title="实时监测进程"></a>实时监测进程</h2><p>ps命令虽然在收集运行在系统的进程信息时非常有用，缺点如上所述，为了解决特定时间点的问题，另一个命令就刚好合适：</p><p>命令：top</p><p>功能：实时显示进程信息</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301358009.png"></p><p>总体来说和ps命令并没有太大的不同，只是从特定时间点变成了实时。在默认情况下，top命令在启动的时候会按照使用CPU时间比例进行排序，键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。键入q可以退出top。</p><p>当我们找到了占用系统大部分资源的进程之后，我们就要开始结束这些进程了。</p><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>接上节所讲，作为系统的管理员，我们应该具备何时以及如何结束一个进程，在Linux进程中大多数是通过信号来通信：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301412584.png"></p><p>命令：kill </p><p>功能：该命令可以通过PID给进程发出信号终止进程。</p><p>缺点：默认情况下，kill会向命令行发送一个TERM信号，只能使用PID而不是命令名。</p><p>TERM信号告诉进程尽可能停止，若是有不服管教的进程需要我们强制终止，可以使用 -s 参数。若是要检查是否有效，可以再次运行ps 和 top 命令。</p><p>命令：killall</p><p>功能：该命令可以通过进程名而不是PID来结束进程，也支持通配符，在系统因为负载过大而变慢时很有用。</p><p>命令：kill -9 进程ID</p><p>功能：强制结束该进程。</p><h1 id="监测磁盘空间"><a href="#监测磁盘空间" class="headerlink" title="监测磁盘空间"></a>监测磁盘空间</h1><p>系统管理员的另一个重要任务就是要监测系统磁盘的使用情况（也就是空间）。在Linux系统上有几个命令行命令用来帮助存储媒体：</p><h2 id="挂载存储媒体"><a href="#挂载存储媒体" class="headerlink" title="挂载存储媒体"></a>挂载存储媒体</h2><p>在文件管理中曾介绍Linux文件系统将所有的磁盘都并入一个虚拟目录下，在使用新的存储媒体之前需要把它放在虚拟目录下，这就叫做挂载。</p><p>现在大多数的系统都能自动挂载，若是用的发行版不支持自动挂载，就必须手动挂载了。</p><p>命令：mount</p><p>功能：挂载媒体，默认情况下也可以用来显示挂载的设备列表</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301427346.png"></p><p>mount命令主要提供四部分信息：</p><p>1.媒体的设备文件名</p><p>2.媒体挂载到虚拟目录的挂载点</p><p>3.文件系统类型</p><p>4.已挂载媒体的访问状态</p><p>手动挂载设备，需要以root用户登录，或者是以root用户运行sudo命令</p><p>手动命令：mount -t type device directory</p><p>type参数指定了磁盘被格式化的文件系统类型。</p><p><strong>Tip：手动挂载的磁盘要先格式化才能进行挂载。</strong></p><p>mount命令的参数：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301444408.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301444867.png"></p><p>命令：umount</p><p>功能：从Linux系统上移除一个可移动设备，就要先卸载。</p><p>实际格式：umount  [directory | device]</p><p>若是有任何程序正在使用设备上的文件，系统是不会允许我们卸载它。</p><h2 id="df命令的使用"><a href="#df命令的使用" class="headerlink" title="df命令的使用"></a>df命令的使用</h2><p>学习挂载之后，我们需要查看设备还剩余多少的磁盘空间，df命令就显得很方便。</p><p>命令：df</p><p>功能：显示每个有数据的已挂载文件系统。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301504380.png"></p><p><strong>Tip：Linux系统后台一直有进程来处理文件或使用文件。df命令的输出值显示的是Linux系统认为的当前值。有可能系统上有运行的进程已经创建或删除了某个文件，但尚未释放文件。这个值是不会算进闲置空间的。</strong></p><h2 id="du命令的使用"><a href="#du命令的使用" class="headerlink" title="du命令的使用"></a>du命令的使用</h2><p>df命令只能告诉我们宏观的磁盘的存储空间，并不能告诉我们细分的文件或者特定的目录，这个时候就要用到du命令来显示具体的占用的空间的文件。</p><p>命令：du</p><p>功能：显示当前目录下的所有文件和目录。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301621919.png"></p><p>du命令的几个参数：</p><p>-c：显示所有已列出文件总的大小。<br>-h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。<br>-s：显示每个输出参数的总计。</p><p>在我们查看了具体的文件之后就是要对它们使用文件处理命令进行处理。</p><h1 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h1><p>结合上节所述，当我们有大量的数据时，一般来说很难提取到有用的信息，但是Linux系统提供了命令行工具来处理大量的数据，这些命令可以帮助我们更好的应对。</p><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p>命令：sort</p><p>功能：sort命令是对数据进行排序的。默认情况下，sort命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301630992.png"></p><p>缺点：默认情况下，sort命令会把数字当做字符来执行标准的字符排序，产生的输出可能根本就不是你要的。解决这个问题可用-n参数。</p><p>另一个常用的参数是 -M，按月排序，Linux的日志中经常会有时间戳来表明事件是什么时候发生的。</p><p>其他参数：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301636268.png"></p><p><strong>Tip：管道命令（|）将du命令的输出重定向到sort命令。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301643408.png"></p><h2 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h2><p>在海量的数据背景下，我们通常需要在大文件中找到一行或几行数据即可，这个时候我们就需要搜索数据了。</p><p>命令：grep  pattern  file</p><p>功能：在文件中查找数据。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301650375.png"></p><p>若是要进行反向搜索，加入参数 -v 即可。</p><p>显示匹配模式的行的行号，加入 -n 参数即可。</p><p>若想知道有多少行含有匹配模式，加入参数 -c 。</p><p>若要指定多个匹配模式，可使用 -e 模式。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301653653.png"></p><p><strong>Tip：在默认模式下，也可使用正则表达式来定义查找匹配的模式。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301655071.png"></p><h2 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h2><p>在windows系统中我们经常使用的压缩文件就是zip文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301700599.png"></p><p><strong>Tip：compress文件压缩已经很少在Linux系统中见到了，基本现在都是使用gzip。</strong></p><p>命令：gzip；gzcat；gunzip</p><p>功能：压缩文件；查看压缩文件的内容；解压文件。</p><p>缺点：该命令只能压缩一个文件，不能将多个文件压缩进一个压缩包。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301703112.png"></p><p>gzip命令可以一次性指定多个文件名，也可以使用通配符来一次性批量压缩文件。</p><h2 id="归档数据"><a href="#归档数据" class="headerlink" title="归档数据"></a>归档数据</h2><p>为了解决压缩数据中不能同时压缩多个文件的缺点，还有另外的命令来解决这个问题。</p><p>命令：tar function [options] objects1 objects2</p><p>功能：能将多个文件在磁带设备中归档到一个文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301713823.png"></p><p><strong>Tip：文件名以.tgz结尾。这些是gzip压缩过的tar文件可以用命令tar -zxvf filename.tgz来解压。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301718385.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此篇博客是学完系统管理之后一些要点的总结，下一篇将是对Linux shell及其使用。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-字符串的格式化输入输出</title>
      <link href="/2023/04/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2023/04/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在总结完数据类型之后，我们就开始对printf（）和scanf（）中都有的格式化字符串进行学习和探讨。</p><h1 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h1><p>字符串是一个或多个字符的序列，一般使用双引号将内容括起来，正如单引号对于字符一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Zing went the strings of my heart!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="char类型数组和null字符"><a href="#char类型数组和null字符" class="headerlink" title="char类型数组和null字符"></a>char类型数组和null字符</h2><p>在C语言中没有专门用于储存字符串的变量类型，一般被储存在char类型的数组中，每个单元储存一个字符。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304191340852.png"></p><p>上述数组的末尾的字符\0，这是空字符（null字符），C语言用它标记字符串的结束，空字符不是数字0，它是非打印字符，其ASCII码值是0。C的字符串一定是以空字符结束，也就是说数组的容量至少要比存储字符串的字符数多一。</p><p>数组：一行连续的多个储存单元，同类型数据元素的有序序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">40</span>];</span><br></pre></td></tr></table></figure><p>char是声明变量的数据类型，name是数组的名字，方括号表明这是一个数组，40则是说明该数组的数量。</p><h2 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h2><p>转换说明：%s</p><p>我们不需要把空字符放到字符串结尾，scanf（）在读取输入时就已经完成这项工作了，编译器也会在末尾加上空字符。</p><p><strong>Tip：scanf（）只会读取连续的字符，从第一个非空白字符起到空白字符结束。下面将会进行详尽阐述</strong></p><p>字符串和字符的区别：”x” 和 ‘x’ 就是不一样的，前者是char数组，后者是char类型；前者在末尾还有空字符，而后者则没有。</p><h2 id="Strlen（）函数"><a href="#Strlen（）函数" class="headerlink" title="Strlen（）函数"></a>Strlen（）函数</h2><p>在数据类型的博客中我们介绍了一个sizeof运算符，它以字节为单位给出对象的大小。strlen（）函数给出字符串的字符长度，因为一个字节储存一个字符，但其实这两种方法应用字符串的结果并不相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRAISE <span class="string">&quot;You are an extraordinary being.&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">40</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK, %s.%s\n&quot;</span>, name, PRAISE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your name of %zd letters occupies %zd memory cells.\n&quot;</span>, <span class="built_in">strlen</span>(name), <span class="keyword">sizeof</span>(name));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The phrase of praise has %zd letters &quot;</span>, <span class="built_in">strlen</span>(PRAISE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;and occpies %zd memory cells.\n&quot;</span>, <span class="keyword">sizeof</span>(PRAISE));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中 sizeof 运算符报告name数组有40个存储单元，但是只有前11个用来存储，所以strlen（）得出的结果是11。一般来说 sizeof 运算符给出的数更大，因为它要把字符串末尾的空字符也计算在内。</p><p><strong>Tip：sizeof 运算符使用圆括号的场景，取决于运算对象是类型还是特定量。运算对象是类型，则必不可少；若是特定量则可以省略，但还是建议在所有情况加上（）。</strong></p><h1 id="常量和预处理器"><a href="#常量和预处理器" class="headerlink" title="常量和预处理器"></a>常量和预处理器</h1><p>在程序中，我们使用一个常量一般都是直接键入，虽然无需声明，但是不够好，我们可以使用符号常量。一般使用符号常量有两种方法：</p><p>1.声明一个变量，给变量赋予所需的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> tax;</span><br><span class="line">tax = <span class="number">0.015</span>;</span><br></pre></td></tr></table></figure><p>虽然这样做提供了一个符号名，但是 tax 本质是一个变量，复杂的程序在运行中可能会无意改变它的值。</p><p>2.C预处理器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAX 0.015</span></span><br></pre></td></tr></table></figure><p>在前面博客介绍过预处理器是如何使用 #include 包含其他文件信息，但同时预处理器也可以用来定义常量。</p><p>通用格式：#define <em>NAME</em>  <em>value</em></p><p>#define 指令还可以定义字符和字符串常量，前者单引号，后者双引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BEEP &#x27;\a&#x27;</span><br><span class="line">#define TEE &#x27;T&#x27;</span><br><span class="line">#define ESC &#x27;\033&#x27;</span><br><span class="line">#define OOPS &quot;Now you have done it!&quot;</span><br></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>在C90标准中新增了const关键字，用于限定一个变量为只读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>num 这个值成为一个只读值，不能更改。</p><p><strong>Tip：const 定义的是一个只读变量，而不是常量。</strong></p><p>后面的博客再来详细介绍。</p><h2 id="明示常量"><a href="#明示常量" class="headerlink" title="明示常量"></a>明示常量</h2><p>C头文件limits.h 和 floar.h 分别提供了整数类型和浮点类型大小限制相关的详细信息。</p><p>在limits.h头文件中包含以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX +32767</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MIN -32768</span></span><br></pre></td></tr></table></figure><p>下表是limits.h中一些明示常量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201515931.png"></p><p>类似的，下表是一些float.h中的一些明示常量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201519224.png"></p><h1 id="printf（）和scanf（）"><a href="#printf（）和scanf（）" class="headerlink" title="printf（）和scanf（）"></a>printf（）和scanf（）</h1><p>这个两个函数对于C语言学习者来说并不陌生，一个输入函数，一个输出函数；工作原理几乎相同，都是使用格式化字符串和参数列表。</p><h2 id="printf（）函数"><a href="#printf（）函数" class="headerlink" title="printf（）函数"></a>printf（）函数</h2><p>在请求printf（）函数打印数据的指令要与待打印数据的类型相匹配。打印整数使用%d，打印字符要用%c，这些符号被称为转换说明：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201529890.png"></p><h2 id="printf（）函数的使用"><a href="#printf（）函数的使用" class="headerlink" title="printf（）函数的使用"></a>printf（）函数的使用</h2><p>打印输出函数的使用就需要在这里赘述了，简单说一下格式即可：</p><p>格式：printf（格式化字符串，待打印项1，待打印项2，…）;</p><p>其中待打印项1等都是需要打印的，它们可以是变量，常量，甚至是打印之前要计算的表达式，前提是格式化字符串应当包含每个待打印项对应的转换说明；数量和类型都要对应。</p><p>若是只打印短语或句子，就不需要使用任何转换说明；如果只打印数据，也不用加入说明文字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%d\n&quot;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="number">2</span> * cost);</span><br></pre></td></tr></table></figure><p><strong>Tip：由于%在printf（）函数中拿来标识转换说明了，因此打印%符号就需要用别的方法，然而我们之前有使用过 \ （反斜杠）的转义字符来表示符号，但在这里并不适用，我们只需要使用%%即可。</strong></p><h2 id="printf（）的转换说明修饰符"><a href="#printf（）的转换说明修饰符" class="headerlink" title="printf（）的转换说明修饰符"></a>printf（）的转换说明修饰符</h2><p>在%和转换字符之间插入修饰符可以修饰基本的转换说明，下面列出一些可作为修饰符的合法字符，若要同时插入多个字符，也得与下表顺序相同。（并非所有的组合都可行）</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201600738.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201602465.png"></p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGES 959</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%2d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%-10d*\n&quot;</span>, PAGES);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展示的是对于字段宽度以及修饰符的作用。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201614801.png"></p><p>上面是对于整型来说的，下面我们看看对于浮点型来说，修饰符又有那些作用呢:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> RENT <span class="number">3852.99</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%e*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%4.2f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%3.1f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10.3f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10.3E*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%+4.2f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%010.2f*\n&quot;</span>, RENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序输出结果如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304211740883.png"></p><p>该程序中使用了const 关键字，限定变量为只读。</p><p>第一个转换说明%f ，在这种情况下，字段宽度和小数点后面的位数均为系统默认设置，小数点后打印6位数字。</p><p>第二个转换说明%e 无需过多的赘述，在数据类型的博客中有详细讲解。</p><p>第四个和第六个例子分别对输出结果进行四舍五入。</p><p>第七个转换说明中包含了+标记，这使得打印的值前面多了一个代数符号；最后一个转换说明的 0 标记使得打印的值前面用 0 填充来满足字段的要求。</p><p>剩下的一些其他格式的数据在这里就不逐个展示了。</p><p><strong>Tip：在整型数据中使用精度（%5.3d）生成足够的前导0 用来满足最小位数的要求，若是精度和 0 同时出现，0 标记会被忽略。</strong></p><p>对于字符串格式来说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLURB <span class="string">&quot;Authentic imitation&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%2s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%24s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%24.5s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%-24.5s]\n&quot;</span>, BLURB);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然第一个转换说明是%2s ，但是字段会被扩大为可容纳所有字符的格式，另 . 5是告诉打印函数只打印5个字符，- 号则是使得文本左对齐输出。</p><h2 id="转换说明的意义"><a href="#转换说明的意义" class="headerlink" title="转换说明的意义"></a>转换说明的意义</h2><p>在介绍了这么多转换说明和修饰符之后，我们应该深入了解一下转换说明的存在意义，实际上转换说明就是把电脑中存储的二进制格式的值转换成我们所需的一系列字符。转换本质上是翻译说明，而非替换；无论输出格式如何多种多样，数据存储的方式都只有二进制一种。</p><p>转换说明会碰到的问题：</p><h3 id="1-转换不匹配："><a href="#1-转换不匹配：" class="headerlink" title="1.转换不匹配："></a>1.转换不匹配：</h3><p>通常我们打印一个 int 类型的值，我们可以使用%d ，%x ，%o ，类似的，打印float 类型的值，我们可以使用%f ，%e ，%g 。</p><p>在这个转换说明中可以着重看一下原码，反码和补码的概念，但是我们同样需要注意%u 不会把数字和符号进行区分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGES 336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORDS 65618</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">short</span> num = PAGES;</span><br><span class="line"><span class="type">short</span> mnum = -PAGES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num as short and unsigned short: %hd %hu\n&quot;</span>, num,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-num as short and unsigned short: %hd %hu\n&quot;</span>, mnum,mnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num as int and char: %d %c\n&quot;</span>, num, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WORDS as int, short, and char: %d %hd %c\n&quot;</span>,WORDS,WORDS,WORDS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码说的都是整型数据中的错误，若是错误出现在浮点型中时，出现的结果会更令人意想不到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n1 = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">double</span> n2 = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">long</span> n3 = <span class="number">2000000000</span>;</span><br><span class="line"><span class="type">long</span> n4 = <span class="number">1234567890</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1e %.1e %.1e %.1e\n&quot;</span>, n1, n2, n3, n4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld %ld\n&quot;</span>, n3, n4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld %ld %ld %ld\n&quot;</span>, n1, n2, n3, n4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行中除了n1和n2两个值之外，n3和n4这两个值输出都并不正常，这里我们就需要说到在printf（）函数中，float类型（4位字节）会变成double类型（8位字节）进行输出，使用%e 打印long类型（4位字节），除了查看本身的4位之外，还会额外查看相邻的4位字节，共同组成解释浮点数。即使n3 位数正确，最终得到的结果也是无意义的值。</p><p>在第三行中输出显示，printf（）函数即使使用正确的转换说明也可能会生成虚假的结果，其中的问题就出在了C语言的信息传递过程中。参数传递过程会因为系统和编译器的实现方式而出现变化。</p><p>上面程序的第三句输出，n1是作为double类型存储到栈的内存区域占8位字节，n2 同样也是占8位，n3 和 n4 各自占据了4位字节，然后才是函数根据不同的转换说明进行数据的读取，%ld 说明应该读取4个字节，然而前4个字节是n1 的前半部分，这样的读取就出现错误。n2 则是读取了n1 的后半部分。虽然用对了转换说明，却读不出正确的值。</p><p><strong>Tip：从这里可以看出计算机其实非常的死板，只能按部就班的完成指令</strong></p><h3 id="2-printf（）的返回值："><a href="#2-printf（）的返回值：" class="headerlink" title="2.printf（）的返回值："></a>2.printf（）的返回值：</h3><p>在C语言起始那篇博客中，我们介绍过大部分C语言函数都会有一个返回值，这是函数计算并且返回给主调程序的值，总之程序中可以把返回值像其他值一样使用。printf（）的返回值是函数打印之后的附带用途，一般很少用的到，一般是检查错误用到比较多。（写入文件的时候比较常用），若是一张CD拒绝写入时，程序采取相应的行动。要实现需要先了解 if 语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bph2o = <span class="number">212</span>;</span><br><span class="line"><span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">    rv = <span class="built_in">printf</span>(<span class="string">&quot;%d F is water&#x27;s boiling point.\n&quot;</span>, bph2o);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The printf() function printed %d characters.\n&quot;</span>,</span><br><span class="line">rv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序就展示了printf（）在正常运行时的返回值。计算了所有的字符数包括空格和不可见的换行符。</p><h3 id="3-打印较长的字符串"><a href="#3-打印较长的字符串" class="headerlink" title="3.打印较长的字符串"></a>3.打印较长的字符串</h3><p>在打印字符串时，我们经常会碰到较长的语句，在屏幕上不方便阅读，若是有空格、制表符、换行符等用于分隔不同的部分，C编译器会忽略他们，所以一条语句可以写成很多行，在不同部分之间输入空白即可。</p><p><strong>Tip：切记不能在双引号括起来的字符串中间断行，会产生报错。</strong></p><p>给字符串断行的三种方法：</p><p>1.我们可以使用多个printf（）语句，因为第一个字符串没有以\n字符结束，所以第二个字符串会紧跟第一个字符串的末尾。</p><p>2.用反斜杠（\）和Enter键组合的方式来断行，这使得光标移到下一行，而且字符串不会包含换行符。</p><p>3.ANSI C 引入的字符串连接，在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作一个字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s one way to print a &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;long string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s another way to print a \</span></span><br><span class="line"><span class="string">long string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s the newest way to print a &quot;</span></span><br><span class="line"><span class="string">&quot;long string.\n&quot;</span>); <span class="comment">/* ANSI C */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231633510.png"></p><h2 id="scanf（）的使用"><a href="#scanf（）的使用" class="headerlink" title="scanf（）的使用"></a>scanf（）的使用</h2><p>结束了printf（）函数的学习，接下来介绍一下scanf（）函数，C语言库中包含很多的输出函数，scanf（）是其中最通用的一个，因为它可以读取不同格式的数据，但是从键盘输入的都是文本字符：字母，数字和标点符号，要把字符依次转换成数值就是scanf（）函数需要做的事情，与printf（）所做的事情正好相反。</p><p><strong>Tip：printf（）整数、浮点数、字符串–&gt; 文本</strong></p><p>​           <strong>scanf（） 文本 –&gt; 整数、浮点数、字符串</strong></p><p>这两个函数的核心本质都是格式化字符串。</p><p>scanf（）函数中用的最多的是指向变量的指针，关于指针的内容后续再详细介绍，这里我们只需要知道两条规则：</p><p>1.如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;。</p><p>2.如果用scanf()把字符串读入字符数组中，不要使用&amp;。</p><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age; <span class="comment">// 变量</span></span><br><span class="line"><span class="type">float</span> assets; <span class="comment">// 变量</span></span><br><span class="line"><span class="type">char</span> pet[<span class="number">30</span>]; <span class="comment">// 字符数组，用于储存字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your age, assets, and favorite pet.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %f&quot;</span>, &amp;age, &amp;assets); <span class="comment">// 这里要使用&amp;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pet); <span class="comment">// 字符数组不使用&amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d $%.2f %s\n&quot;</span>, age, assets, pet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面包含了整型、浮点型和字符串三个数据类型。</p><p><strong>Tip：在scanf（）函数中唯一的例外是%c 转换说明，根据%c ，scanf（）会读取每个字符，包括空白。</strong></p><p>scanf（）函数所用的转换说明与printf（）函数几乎相同，主要的区别是对于float类型和double类型，printf（）都使用%f ，%e ，%g。而scanf（）函数仅仅把这几个用于float类型，对于double类型需要加上l 修饰符。</p><p>具体的转换说明如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231700976.png"></p><p>修饰符如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231702651.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231702338.png"></p><p><strong>Tip：若要同时使用多个修饰符需要严格按照修饰符的顺序。</strong></p><h3 id="从scanf（）看输入"><a href="#从scanf（）看输入" class="headerlink" title="从scanf（）看输入"></a>从scanf（）看输入</h3><p>scanf（）函数读取输入若是%d ，一开始会跳过所有的空白字符，直至遇到第一个非空白字符才开始读取，若是遇到数字或符号，继续读取，若还是数字继续，反之暂停。然后会把非数字字符返回给输入，也意味着下次读取会是上次丢弃的字符，这点很重要。</p><p>若是%d 遇到第一个非空白字符是A而不是数字，那么scanf（）函数就会一直卡在第一个转换说明这里。若是多个转换说明，C语言规定会在第一个出错处停止读取输入。</p><p>如果使用的是%s 转换说明，scanf（）会读取除了空白以外的所有字符。即非空白字符起，空白字符止。</p><p>C语言还有其他的输入函数，如 getchar（）和 fgets（）等。这两个函数更适合特殊的处理情况，未来碰到在详细介绍。</p><h3 id="格式化字符串中的普通字符"><a href="#格式化字符串中的普通字符" class="headerlink" title="格式化字符串中的普通字符"></a>格式化字符串中的普通字符</h3><p>scanf（）函数可以把普通字符放在格式化字符串里，除了空格字符外的普通字<br>符必须与输入字符串严格匹配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;n, &amp;m);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">88</span>,<span class="number">121</span></span><br><span class="line"><span class="number">88</span>, <span class="number">121</span></span><br><span class="line"><span class="number">88</span>,</span><br><span class="line"><span class="number">121</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d ,%d&quot;</span>, &amp;n, &amp;m);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">88</span>,<span class="number">121</span></span><br><span class="line"><span class="number">88</span> ,<span class="number">121</span></span><br><span class="line"><span class="number">88</span> , <span class="number">121</span></span><br></pre></td></tr></table></figure><p>上述代码就是输入一个数字，逗号，一个数字，逗号必须紧跟第一个数字，后面的间隔和空白并没有具体的要求。格式化字符串的空白意味着跳过下一个输入项前面的所有的空白。（所有的空白包括没有空格的情况）。</p><p><strong>Tip：那么对于%c 来说，在格式化字符串中添加一个空格字符会有所不同，如果把空格放到格式化字符串的%c之前，scanf（）会跳过非空白字符。若没有空格，那么会读取空白字符。</strong></p><h3 id="scanf（）的返回值"><a href="#scanf（）的返回值" class="headerlink" title="scanf（）的返回值"></a>scanf（）的返回值</h3><p>scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0。当scanf()检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。</p><h2 id="printf（）和scanf（）的-修饰符"><a href="#printf（）和scanf（）的-修饰符" class="headerlink" title="printf（）和scanf（）的*修饰符"></a>printf（）和scanf（）的*修饰符</h2><p>在这两个函数的修饰符中都有*修饰符，但是作用却完全不同。</p><p>在printf（）中，若是不想预先指定字段宽度，希望通过程序来指定，可以使用* 修饰符来代替字段宽度，但是需要一个参数告诉函数，字段宽度是多少，也就是说转换说明%*d，参数列表应包含 *和d对应的值。这同样适用于浮点数的指定精度和字段宽度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> width, precision;</span><br><span class="line"><span class="type">int</span> number = <span class="number">256</span>;</span><br><span class="line">    <span class="type">double</span> weight = <span class="number">242.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a field width:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;width);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The number is :%*d:\n&quot;</span>, width, number);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now enter a width and a precision:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;width, &amp;precision);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Weight = %*.*f\n&quot;</span>, width, precision, weight);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中程序中的width是字段宽度，number是待打印的数值。</p><p>scanf（）中的用法就和printf（）不同，把* 放在%和转换字符之间时，会使得scanf（）跳过相应的输出项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter three integers:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%*d %*d %d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The last integer was %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="printf（）用法提示"><a href="#printf（）用法提示" class="headerlink" title="printf（）用法提示"></a>printf（）用法提示</h2><p>在输出时想把数据打印成列，指定固定的字段宽度是很有用的，若是不指定的话，会显得数据显示的很杂乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, val1, val2, val3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%9d %9d %9d\n&quot;</span>, val1, val2, val3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>         <span class="number">234</span>        <span class="number">1222</span></span><br><span class="line"> <span class="number">4</span>           <span class="number">5</span>          <span class="number">23</span></span><br><span class="line"> <span class="number">6</span>          <span class="number">22</span>          <span class="number">34</span></span><br></pre></td></tr></table></figure><p>这样就会显得整齐不少，在两个转换说明之间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟一起输出。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此我们结束了对于这两个函数的使用包括修饰符等，也对数据类型进行了巩固，下一篇将进入运算符和表达式包括语句的学习。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>故障修复-虚拟机USB口不识别U盘</title>
      <link href="/2023/04/16/%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D-%E8%99%9A%E6%8B%9F%E6%9C%BAUSB%E5%8F%A3%E4%B8%8D%E8%AF%86%E5%88%ABU%E7%9B%98/"/>
      <url>/2023/04/16/%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D-%E8%99%9A%E6%8B%9F%E6%9C%BAUSB%E5%8F%A3%E4%B8%8D%E8%AF%86%E5%88%ABU%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>前因：在学习Linux系统管理命令时想尝试一下用 mount 命令将U盘挂载到虚拟机中，然而将U盘插入电脑后，虚拟机并无任何反应，开始百度查找原因，基本可以确定是VMware USB Arbitration Service 服务未开启的问题。</p><p>找到疑似原因，就开始尝试修复，首先win + r 键，输入service.msc，回车进入服务，找到上述的USB服务并开启服务，在这里我们遇到了第一个问题：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161433611.png"></p><p>接着在百度上查找原因，大部分说的是AMD主板这类的问题，尝试过后发现效果并不是很理想，本着除根需除净的原则，还是选择将VM虚拟机卸载重装。</p><p>在尝试过程中有个使用exe文件重装修复的方法，尝试之后会出现以下的问题：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161438609.png"></p><p>这也是博主尝试的最后一种方法，实在修不动，选择重装大法了。（当然重装之后还是使用修复的方法对USB接口服务进行修复）</p><p><strong>Tip：VMx86驱动程序的版本不匹配，基本就是以前安装过的VM虚拟机卸载的不干净导致脚本文件产生冲突。</strong></p><p>重装VM虚拟机的过程中，又出现了一个问题：无法安装服务，请确保您有足够的权限安装系统文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161442321.png"></p><p>这个问题解决详情可见<a href="https://blog.csdn.net/qq_55868479/article/details/124046593">无法安装服务“VMware Authorization Service” ，请确保您有足够的权限安装系统，如何解决？_神偷克星的博客-CSDN博客</a></p><p>最后博主也是用CCleaner清除干净注册表之后成功安装。</p><p><strong>Tip：在清除注册表之后最重要的一点：重启电脑！重启电脑！重启电脑！</strong></p><p>然而在重新安装完成之后，插入U盘仍然没有任何反应，这时候就可以使用上面修复的手段了：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161449782.png"></p><p>点击修复，再次进入服务启用VMware USB Arbitration Service 服务即可：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161451393.png"></p><p>可以看到该服务已经启动成功了。</p><p>此时我们将U盘插入电脑，就会看到以下画面：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161452158.png"></p><p>圆满修复。</p><p><strong>在这篇博客完成之前，博主Picgo出现图片上传的网络问题，一开始以为是VPN的故障，查完发现Github的token有时长限制，具体修复如下：</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161455368.png"></p><p>将Expiration的期限改为无限制，重新生成令牌即可。</p>]]></content>
      
      
      <categories>
          
          <category> 系统故障 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-数据类型总结</title>
      <link href="/2023/04/14/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/14/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中我们详细介绍了C语言中的基础数据类型和相关转换说明的原理剖析，那么这一篇博客对数据类型的具体使用作简单介绍和总结。</p><h1 id="使用数据类型"><a href="#使用数据类型" class="headerlink" title="使用数据类型"></a>使用数据类型</h1><p>我们在编写程序的时候，应当注意合理选择所需的变量及其类型，通常来说，使用int或者float类型来选择数字，char类型表示字符。</p><p><strong>Tip：使用变量之前必须先声明，且选择有意义的变量名，若是需要初始化变量，应当与类型匹配。</strong></p><p>声明（初始化）方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> apple = <span class="number">3</span>；<span class="comment">/*正确*/</span></span><br><span class="line"><span class="type">int</span> bananas = <span class="number">4.0</span>;<span class="comment">/*不好的方式*/</span></span><br></pre></td></tr></table></figure><p>若是我们使用一个类型的数值初始化给不同类型的变量的时候，编译器会首先把值转换成与变量匹配的类型，会导致数据错误以及丢失。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost = <span class="number">12.99</span>;<span class="comment">/*用double类型值初始化整型变量*/</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926536</span>;<span class="comment">/*用double类型的值初始化单精度浮点型*/</span></span><br></pre></td></tr></table></figure><p>上述程序cost的值是12，第二个声明会损失一些精度，因为在C语言中只能保证单精度浮点型前6位的精度，一般来说编译器会对这样的初始化产生警报。</p><h1 id="参数和陷阱"><a href="#参数和陷阱" class="headerlink" title="参数和陷阱"></a>参数和陷阱</h1><p>对于printf（）函数的使用主要是需要注意函数中的参数，在格式化字符串中有多少个转换说明，就说明后面需要几个参数，我们需要做的就是确保转换说明数量、类型与后面参数的数量、类型是否一致。</p><p><strong>但是这对于printf（）和scanf（）函数来说并不起作用，因为这两个函数的参数个数是可变的。</strong></p><p>在下一篇博客中会对printf（）和scanf（）这两个函数进行具体的分析，这里就简单的做个说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">7.0f</span>;</span><br><span class="line">    <span class="type">float</span> g = <span class="number">8.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n, m);<span class="comment">/*参数太多*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, n);<span class="comment">/*参数太少*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f, g);<span class="comment">/*值的类型不匹配*/</span></span><br><span class="line">    </span><br><span class="line">    retuen <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是基本会出现的多数问题，在编译器中大部分也会有提醒，然而C标准对此并未作出要求，若是程序正常运行，这些细小的错误会很难察觉。</p><h1 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h1><p>对于转义序列来说，我们主要可以看看退格（\b）、水平制表符（\t）、回车（\r）的工作方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\aEnter your desired monthly salary:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; $_______\b\b\b\b\b\b\b&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;salary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\t$%.2f a month is %.2f a year.&quot;</span>, salary, salary * <span class="number">12.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\rGee!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的薪资询问系统（简单交互），其中含有许多的转义序列。</p><h2 id="刷新输出"><a href="#刷新输出" class="headerlink" title="刷新输出"></a>刷新输出</h2><p>printf（）函数在什么时候会把输出发送到屏幕上呢？<br>最初，printf（）会把内容发送到缓冲区的中间存储区域，然后缓冲区的内容再不断被发送到屏幕上。在C标准中规定了什么时候把缓冲区的内容发送到屏幕：</p><p>1.缓冲区满</p><p>2.遇到换行字符</p><p>3.需要输入的时候</p><p><strong>Tip：还有一种刷新缓冲区的方法就是使用fflush（）函数。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的char，即unsigned char或signed char。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有short、int、long和long long类型。C规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存0或1，分别代表false和true。</p><p>下一篇博客将对字符串和printf（）、scanf（）两个函数做详细解析。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-文件与目录列表2</title>
      <link href="/2023/04/13/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%952/"/>
      <url>/2023/04/13/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<p>接上篇博客，这篇我们开始讲述Linux命令行中关于文件目录的最后一小点内容–目录。</p><h1 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h1><p>在Linux之中，有许多的命令对文件和目录都有效，而有些只对目录有效，那么首先我们来说说怎么创建一个新的目录：</p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>命令：mkdir  -  make directories</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413100027.png"></p><p>我们可以使用 ls命令来查看，可以注意到新目录列表是以d开头，这表示New_dir1是一个目录而不是一个文件。</p><p>单一的 mkdir命令只能创建一个一个目录，若是我们想要创建多个目录或者子目录，就需要在命令后加入-p的参数。如果我们在创建目录出现错误或者建错地方，我们又应该如何去删除呢</p><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>命令：rmdir   -  remove directories</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413100717.png"></p><p>上图可以看到我在一个目录下又创建了一个目录，我想要删除，延续了rm命令的 -i习惯，但是在 rmdir命令中并没有 -i选项来询问是否要删除目录。</p><p><strong>Tips：在默认的情况下，rmdir命令只能删除空目录，若是目录下含有文件等，rmdir命令是无法执行的。</strong></p><p>虽然rmdir命令只能删除空目录，但是不代表删除目录会有很大的麻烦，我们还可以在非空目录上使用rm命令，使用-r参数使得命令可以向下进入目录，删除其中的文件，删除文件之后并且删除目录。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413101811.png"></p><p>上图这种方法同样可以向下进入多个子目录，当需要大量删除目录和文件，这一点尤为有效。若是文件达到一定量级这种方法的弊端也随之显现出来，因为我们要确认每一个文件，这时最终的方法就是使用 -r 和 -f 同时使用的rm命令。</p><p><strong>Tip：在使用 rm -rf 命令之前最好先确认操作是否符合预期，务必谨慎使用该指令。</strong></p><h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><p>Linux中还有几个命令可以查看文件的内容，而不需要调用其他的文本编辑器。</p><h2 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h2><p>命令：file （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413102933.png"></p><p>这个命令是一个随手可得的便捷工具，它可以探测文件的内部，并决定文件是什么类型。也可以作为我们区分文件与目录的又一种方法，其次该命令还可以在查询符号链接文件的时候，可以告诉我们它究竟链接到了那个文件上。</p><h2 id="查看整个文件"><a href="#查看整个文件" class="headerlink" title="查看整个文件"></a>查看整个文件</h2><p>若是我们手头有一个很大的文本文件，我们会希望看看里面的内容，在Linux中有三个不同的命令能完成这个任务。</p><p>命令1：cat  (option)</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413103904.png"></p><p>cat命令是显示文本文件中所有数据的得力工具，没有什么特别的内容。还有一些和该命令搭配使用的参数：</p><p>参数：-n </p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413104310.png"></p><p>该参数会给所有的内容的行加上行号。（在检查脚本的时候很有用）</p><p>若是只想给有文本的加上行号可以使用 - b 参数。</p><p>若是不想制表符出现，可以使用 -T 参数。</p><p><strong>Tip：对于大型文件来说，cat命令有些繁琐，文件的文本会一晃而过。下面的命令可以解决这个问题。</strong></p><p>命令2：more  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413105421.png"></p><p>more命令是为了解决cat命令一旦运行，无法控制后面的操作，more命令可以在显示一页数据之后停下来，more命令是分页工具，正如前面提到过的man命令一样，可以通过空格键和回车键逐行浏览文件，浏览完之后按q键退出。</p><p><strong>Tip：不过more命令只支持文本文件最基本的移动，有些高级功能可以使用less命令。</strong></p><p>命令3 ：less  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413110115.png"></p><p>上图就是通过 less 命令进入一个源代码文件。less命令与more命令基本一样，除此之外还包括很多其他的命令集。</p><h2 id="查看部分文件"><a href="#查看部分文件" class="headerlink" title="查看部分文件"></a>查看部分文件</h2><p>上面的命令都是查看完整文件，但其实有些时候我们只需要查看文件的开头或者结尾就满足需求了，这个时候用cat、more或者less就显得没这么便捷了，好在Linux中有两个专用的命令</p><p>命令1：tail  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413111736.png"></p><p>该命令正如它的名字，会显示文件内容的最后几行的内容。在系统默认情况下，它会显示文件的末尾10行。</p><p>参数：-n  number</p><p>在-n后面加上想要的行数就可以指定该命令的显示行数了。</p><p>参数：-f</p><p>该参数是tail命令的一个突出特性，该参数允许我们在其他进程使用该文件的时候查看文件的内容，tail命令会保持不断活动的状态，这是实时监测系统日志的良好方法。</p><p>命令2：head filename</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413112342.png"></p><p>与上同理，该命令会显示文件开头的行内容，默认情况下，会显示前10行的内容。该命令也支持参数 -n 。</p><p><strong>Tip：因为一般来说文件的开头不会轻易改变，head命令并不像tail命令一样支持参数 -f 。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于在文件系统中切换目录以及处理文件和目录的基本知识到这里就结束了。下面就是正式开始脚本编程之前的最后准备–系统管理命令（如何通过命令行探查Linux系统的内部信息）。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-数据类型</title>
      <link href="/2023/03/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型简介"><a href="#数据类型简介" class="headerlink" title="数据类型简介"></a>数据类型简介</h1><p>在上一篇博客中，已经结束了对于C语言最基本的了解，这篇我们来对关键字中的最为重要且最多的数据类型关键字，他们包括：int、short、long、unsigned、char、float、double、_ Bool、_ Complex、_ Imaginary。</p><p>每一个程序都离不开数据，我们把数字，字母和文字输入进电脑，希望电脑通过这些数据完成某些任务，我们要学会怎么读取数据以及如何操控数据。</p><p>C语言提供两大系列的数据类型：整数类型and浮点数类型。</p><p><strong>Tip：以上关键字大都可以分为这两个类型 。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230331131221.png"></p><p>上述程序的功能是将体重转换为白金价值，其中，我们一改往日的变量定义，在本例中使用了浮点型的float变量，用于处理更大范围的数据，float类型可以储存带小数的数字。</p><h1 id="变量与常量数据"><a href="#变量与常量数据" class="headerlink" title="变量与常量数据"></a>变量与常量数据</h1><p>在一个程序运行过程中没有发生变化的，称之为常量（constant），那么在程序运行过程中可能会被改变或者被赋值的，则称之为变量（variable)。</p><p>在上述程序中，weight就是一个变量，14.5833是一个常量。</p><h1 id="数据类型关键字"><a href="#数据类型关键字" class="headerlink" title="数据类型关键字"></a>数据类型关键字</h1><p>当然不仅是变量与常量不同，不同的数据类型之间也有差异，一些数据类型表示数字，一些数据类型表示字母。如果数据是常量，编译器一般通过程序中的书写形式来识别；但是对于变量而言，我们在程序的开头就要指定它的类型，下图是C语言中的数据类型关键字：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230331140122.png"></p><p>其中，int关键字用来表示基本的整数类型，long、short、unsigned三个关键字，包括新增的signed用于提供整数类型的变式，unsigned short int等；char关键字用于指定字母和其他字符（#￥%*），char类型也可以表示较小的整数；float、double、long double表示带小数点的数；_ Bool类型表示布尔值（true or false）， _ Complex 表示复数， _ Imaginary 表示虚数。</p><p><strong>Tip：位、字节和字是指计算机数据单元或者存储单元的术语：</strong></p><p><strong>位（bit）：可以储存0或1，是构建计算机内存的基本模块。</strong></p><p><strong>字节（byte）：对于几乎所有机器，1字节均为8位，这是字节的标准定义。</strong></p><p><strong>字（word）：是设计计算机时给定的自然存储单位，会随着计算机的进步而进步，现在基本都是64位。</strong></p><h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>整数：与数学的概念一样，在C语言中，整数是没有小数部分的数，我们需要做的是把十进制的数转换到计算机中的二进制，在8位字节中储存该数字，例如7在二进制中就是00000111。</p><p>浮点数：与数学中的实数概念差不多，注意，在一个值后面加上一个小数点，该值就变成一个浮点值了。所以，7是整数，7.00就是浮点数了。显而易见，书写浮点数的方式有很多种，我们主要学习e记数法。</p><p>3.16E7表示的是3.16*10^7，7是10的指数。计算机中把浮点数分成小数部分和指数部分来表示，并且分开存储。</p><p>我们主要需要理解浮点数和整数的储存方案的不同。</p><h1 id="C语言基本数据类型"><a href="#C语言基本数据类型" class="headerlink" title="C语言基本数据类型"></a>C语言基本数据类型</h1><h2 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h2><p>C语言中提供了许多的整数类型，为的是方便程序员针对不同的情况选择不同的类型。特别是，C语言中的整数类型可以表示不同的取值范围和正负值，一般大部分情况使用int类型即可。</p><p>int类型是有符号整型，其值必须为正负整数或零，一般而言，一个int类型需要占用一个机器字长。早期的16位IBM机一般使用16位来储存一个int值，取值范围（-32768-32767）。现在的个人计算机已经发展到了64位，不过ISO C 规定int的取值范围最小为-32768-32767。</p><p><strong>Tip：若是占据16位，为什么不是（-65536-65535），因为一般来说，系统会用首位表示有符号整数的正负号。</strong></p><p>声明int变量在此就不再赘述了，以上已经使用很多了。那么在定义了变量之后，就要对其提供对应的值，变量获取值的方法：第一种就是赋值，利用 &#x3D; 即可；第二种途径是通过函数来获得值（scanf（）等函数），最重要的就是第三种方法：初始化变量！</p><p>初始化变量就是在定义变量的同时就赋予一个初始值，在int 语句后加上一个 &#x3D; 和对应的值即可。</p><p>简单来说，声明变量就是给变量创建和标记存储空间，并为其指定初始值。</p><p>int的常量就比较简单了，一般来说不带小数点的就是int型常量；之后还有long常量和long long常量。</p><p><strong>Tip：最好在初始化时不要把初始化的变量和未初始化的变量放在同一条声明中。</strong></p><p>printf（）函数可以打印int类型的值，%d表明了在一行里打印整数的位置，%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。</p><h3 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h3><p>一般来说，C语言都是假定整型常量是一个十进制数。然而，由于底层是二进制作为基础，实际应用中还是使用八进制和十六进制数，因为8和16都2的幂，但是计算机是无法自行分别各个进制之间的区别的，在C语言中，用特定的前缀表示使用哪种进制。0x或0X前缀表示十六进制值，所以十进制数16表示成十六进制是0x10或0X10。与此类似，0前缀表示八进制。在之后的内容中会详细的讲述进制相关的内容。</p><p><strong>Tip：无论使用那种进制来表示，都不会影响数据的存储方式，因为计算机内部还是二进制进行编码。</strong></p><p>八进制与十六进制的显示：与%d用来显示十进制类似，以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。</p><p>**Tip：在C语言中，八进制和十六进制的常量属于无符号整型（unsigned int）。</p><h2 id="其他整数类型"><a href="#其他整数类型" class="headerlink" title="其他整数类型"></a>其他整数类型</h2><p>我们初学C语言时，int类型能够满足大多数程序的需求了，当然这小节内容为的是留一个印象。C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。</p><p>short int类型（或者简写为short）：占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。short类型属于有符号类型。</p><p>long int类型（long）：占用的存储空间可能比int多，适用于较大数值的场合。long也属于有符号类型。</p><p>long long int或long long（C99标准加入）：占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。</p><p>unsigned int或unsigned：只用于非负值的场合。这种类型与有符号类型表示的范围不同。若是16位unsigned，取值范围则是0-65535。</p><p>声明方式：这些整数类型的声明方式与int类型并无任何不同。</p><p><strong>Tip：八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。</strong></p><p>本小节中我们值得注意的一个问题就是整数是否会溢出的问题。要对我们使用的机器的int类型的位数时刻注意。</p><p>短整型，长整型等的显示：打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。</p><p><strong>Tip：注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。</strong></p><h2 id="字符：char类型"><a href="#字符：char类型" class="headerlink" title="字符：char类型"></a>字符：char类型</h2><p>char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。现在使用最主流的编码系统就是ASCII码，在ASCII码中，整数65代表大写字母A。因此，储存字母A实际上储存的是整数65。</p><p>C语言把1字节（8位）定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。</p><p>声明方式：char类型变量的声明方式与其他类型变量的声明方式相同。</p><p>字符常量的书写方式：在C语言中，用单引号括起来的单个字符被称为字符常量，<strong>单引号必不可少，若是双引号则是字符串。</strong>也可以使用ASCII码中的对应数字来进行赋值（最好不要这样做）。</p><p>单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。比如像退格，换行，蜂鸣等，在C语言中提供了三种方法表示这些字符。</p><p>第一种就是利用数字代码的方式，定义蜂鸣字符的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> beep = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>第二种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列，如下表：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402114259.png"></p><p>最后两个转义序列（\0oo和\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\）并用单引号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beep = <span class="string">&#x27;\007&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述代码等同于 \a;</p><p>十六进制就是将前缀从0改为x即可，记得带上单引号。</p><p>我们在使用数字和数字字符的时候需要注意，字符 ‘4’ 在ASCII码中是52，而不是数字4。</p><p><strong>Tip：无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。</strong></p><p>字符打印方式：printf()函数用%c指明待打印的字符，如果用%d转换说明打印 char类型变量的值，打印的是一个整数。下图清楚显示了数据的显示过程：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402120020.png"></p><h2 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h2><p>_ Bool类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。通常来说布尔类型只占用一位存储空间，在以后会对这个类型进行展开讲解。</p><h2 id="可移植类型：stdint-h和inttypes-h"><a href="#可移植类型：stdint-h和inttypes-h" class="headerlink" title="可移植类型：stdint.h和inttypes.h"></a>可移植类型：stdint.h和inttypes.h</h2><p>在C99标准中新增了两个头文件stdint.h和inttypes.h，以确保C语言的类型在各系统中的功能相同。在stdint.h头<br>文件中，int32_t表示32位有符号整数类型，在使用32位系统中，头文件会把int32_t作为int的别名，若是在16位的系统中，int32_t会被作为long的别名，使用stdint.h的头文件编写程序是为了方便在不同的系统进行匹配。</p><p>不过我们还可能碰到计算机底层系统不能匹配int32_t的情况。这个时候一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型，这组类型集合被称为最小宽度类型。如int_least8_t是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。若是系统最小的整数类型是16位也并不妨碍int_least8_t的使用。</p><p>仅作为了解。</p><h2 id="浮点型：float、double、long-double"><a href="#浮点型：float、double、long-double" class="headerlink" title="浮点型：float、double、long double"></a>浮点型：float、double、long double</h2><p>在C语言的标准中，float类型的必须至少能表示6位的有效数字，取值范围在10^-37~10^37。一般来说，浮点型通常要占用32位，其中8位用于指数部分的值和符号，剩余的24位是使用于非指数部分的值和符号。</p><p>另外一个浮点型double（双精度），double类型和float类型的最小取值范围相同，但是double必须能表示10位有效数字，一般情况下双精度占用的是64位，一些系统是将多余的32位均用于非指数的部分，从而达到更高的精度。</p><p>第三个浮点型long double是用于满足比double类型更高的精度要求，C语言中只保证long double和double的精度相同。</p><p>声明方式：同其他数据类型。</p><p>浮点型常量的书写方式：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。</p><p>2.87E3，-1.56E12等</p><p>正号可以省略。可以没有小数点或者指数部分，但是不能同时省略两者，可以省略小数部分或整数部分，但是不能同时省略两者。</p><p><strong>Tip：不要在浮点型常量中间加空格</strong></p><p>在默认情况下，浮点型常量是double类型的精度，若是在浮点数后面加上f或F的后缀即可覆盖默认的设置，加上l或L的话就是long double的类型。</p><p>在C99标准中还有一种新的浮点型常量的格式，用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂。</p><p>0xa.1fp10 &#x3D; 10364.0（了解）</p><p>浮点数的打印：printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La转换说明。</p><p>浮点数的上溢和下溢：上溢和整数类型的溢出原理基本类似，而下溢则是在计算过程中由于计算符导致有效数字丢失位置的情况。</p><p>下溢例子：以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。</p><h2 id="复数和虚数类型"><a href="#复数和虚数类型" class="headerlink" title="复数和虚数类型"></a>复数和虚数类型</h2><p>C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型float_Imaginary、double _Imaginary和long double _Imaginary。如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。</p><h2 id="类型大小"><a href="#类型大小" class="headerlink" title="类型大小"></a>类型大小</h2><p>sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。</p><p>下图是源码展示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402133219.png"></p><p>以下是输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402133353.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是对C语言中数据类型的基本学习和介绍。 </p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-文件与目录列表</title>
      <link href="/2023/03/26/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/03/26/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="文件与目录-ls命令"><a href="#文件与目录-ls命令" class="headerlink" title="文件与目录-ls命令"></a>文件与目录-ls命令</h1><p>上篇我们已经知道了如何遍历系统和验证当前的工作目录，接下来就可以开始探索各种目录中的文件了。</p><p>要想知道目录中有那些文件，可以使用列表命令（ls）。</p><p>ls命令最基本的形式会显示当前目录下的文件和目录，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326150508.png"></p><p>ls命令带上-F参数的ls命令轻松区分文件和目录。使用-F参数可以得到如下输出：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326150758.png"></p><p>基本的ls命令在某种意义上有点容易让人误解。它显示了当前目录下的文件和目录，但并没有将全部都显示出来。Linux经常采用隐藏文件来保存配置信息。在Linux上，隐藏文件通常是文件名以点号开始的文件。要把隐藏文件和普通文件及目录一起显示出来，就得用到-a参数。</p><p>ls命令中的-R参数是ls命令可用的另一个参数，叫作递归选项。它列出了当前目录下包含的子目录中的文件。如果目录很多，这个输出就会很长。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326151353.png"></p><p><strong>Tip：输入参数时可以不用像图片中一样，ls -F -R，可以进行合并 ls -FR。</strong></p><p>在基本的输出列表中，ls命令并未输出太多每个文件的相关信息。要显示附加信息，另一个常用的参数是-l。-l参数会产生长列表格式的输出，包含了目录中每个文件的更多相关信息。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326151751.png"></p><p>在这些相关信息中主要分为以下这些：</p><p>文件类型，比如目录（d）、文件（-）、字符型文件（c）或块设备（b）；<br>文件的权限（参见第6章）；<br>文件的硬链接总数；<br>文件属主的用户名；<br>文件属组的组名；<br>文件的大小（以字节为单位）；<br>文件的上次修改时间；<br>文件名或目录名。</p><p><strong>Tip：在shell中输入man ls 可以查看ls命令的各种参数，man命令同样适用于其他指令。</strong></p><p>前面的例子可知，默认情况下，ls命令会输出目录下的所有非隐藏文件。有时这个输出会显得过多，当你只需要查看单个少数文件信息时更是如此。ls命令还支持在命令行中定义过滤器，它会用过滤器来决定应该在输出中显示哪些文件或目录。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326152853.png"></p><p>当用户指定特定文件的名称作为过滤器时，ls命令只会显示该文件的信息。有时你可能不知道要找的那个文件的确切名称。ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配：<br>问号（?）代表一个字符；<br>星号（*）代表零个或多个字符。<br>问号可用于过滤器字符串中替代任意位置的单个字符。</p><p>在过滤器中使用星号和问号被称为文件扩展匹配（file globbing），指的是使用通配符进行模式匹配的过程。通配符正式的名称叫作元字符通配符（metacharacter wildcards）。除了星号和问号之外，还有更多的元字符通配符可用于文件扩展匹配。可以使用中括号。下面是中括号的两种用法：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326153254.png"></p><p>另外，可以使用感叹号（!）将不需要的内容排除在外。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326154001.png"></p><p><strong>Tip：在使用 (!) 时，也需要在外面加上中括号。</strong></p><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><h2 id="创建文件-touch命令"><a href="#创建文件-touch命令" class="headerlink" title="创建文件-touch命令"></a>创建文件-touch命令</h2><p>我们在学习的过程时不时会遇到创建空文件的情况，这时可以使用touch命令创建空文件，注意文件的大小是0。而且touch命令还可以用来改变文件的修改时间，这个操作并不会改变文件的内容。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326155341.png"></p><p>那么touch命令与mkdir命令的区别在什么地方？</p><p>touch命令：</p><p>语法：touch [options] filename<br>           -a：改变访问时间<br>           -m：改变改动时间<br>           -t timestamp：改变访问时间和改动时间为timestamp</p><p>mkdir命令：</p><p>语法：mkdir [options] dirname<br>           -p：递归创建文件夹<br>           -mmode：新建文件夹，并设置文件夹的文件访问模式为mode</p><p>总结来说，一个是创建文件，一个是创建文件夹。</p><h2 id="复制文件-cp命令"><a href="#复制文件-cp命令" class="headerlink" title="复制文件-cp命令"></a>复制文件-cp命令</h2><p>在最基本的用法里，cp命令需要两个参数——源对象和目标对象：<br>cp source destination<br>当source和destination参数都是文件名时，cp命令将源文件复制成一个新文件，并且以destination命名。新文件就像全新的文件一样，有新的修改时间。</p><p><strong>Tip：如果目标文件已经存在，cp命令可能并不会提醒这一点。最好是加上-i选项，强制shell询问是否需要覆盖已有文件。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327131534.png"></p><p>另外，cp命令的-R参数威力强大。可以用它在一条命令中递归地复制整个目录的内容。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327131921.png"></p><p><strong>Tip：cp命令中也可以使用通配符，除了单点符和通配符之外，还可以使用shell的另一特性，那就是制表键自动补全。</strong></p><h2 id="制表键自动补全"><a href="#制表键自动补全" class="headerlink" title="制表键自动补全"></a>制表键自动补全</h2><p>在我们日常使用命令行时，由于繁多且复杂，很容易输错命令、目录名和文件名，这正是制表键自动补全挺身而出的时候。制表键自动补全允许你在输入文件名或目录名时按一下制表键，让shell帮忙将内容补充完整。</p><p><strong>Tip：使用制表键自动补全的的技巧在于要给shell足够的文件名信息，使其能够将需要文件同其他<br>文件区分开。假如有另一个文件名也是以really开头，那么就算按了制表键，也无法完成文件名<br>的自动补全。这时候你会听到嘟的一声。要是再按一下制表键，shell就会列出所有以really开头的<br>文件名。这个特性可以让你观察究竟应该输入哪些内容才能完成自动补全。</strong></p><h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>链接文件是Linux文件系统的一个优势。如需要在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。链接是目录中指向文件真实位置的占位符。在Linux中有两种不同类型的文件链接：<br><strong>符号链接：ln -s filename</strong><br><strong>硬链接：ln filename</strong></p><p>符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。</p><p>硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。</p><p>符号链接类似于C语言的指针！若是想要验证是否为不同的文件，可以使用 ls -i 命令查看incode编号。</p><p><strong>Tip：复制链接文件的时候，产生的是源文件的副本，容易弄混乱，不如创建源文件的另一个链接，一个源文件可以有多个链接，千万不要创建软链接的软链接，容易造成断裂。</strong></p><h2 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h2><p>在Linux中，重命名文件称为移动。mv命令可以将文件和目录移动到另一个位置或重新命名。</p><p>​                               <img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327134310.png"></p><p><strong>Tip：移动文件会将文件名进行更改，但inode编号和时间戳保持不变。这是因为mv只影响文件名。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327135136.png"></p><p>我们可以看到在重命名目录之后，原来的目录名已经不存在了。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Linux中，删除（deleting）叫作移除（removing）。bash shell中删除文件的命令是rm。rm命令的基本格式非常简单。</p><p><strong>rm -i filename</strong></p><p><strong>Tip：-i命令参数提示你是不是要真的删除该文件。ubuntu中虽然有回收站或垃圾箱，但是，在使用rm命令时，我们仍要养成总是加入-i参数的好习惯。</strong></p><p>rm命令的另外一个特性是，如果要删除很多文件且不受提示符的打扰，可以用-f参数强制删除。</p><p>下篇将介绍mkdir命令的使用场景–目录。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学</title>
      <link href="/2023/03/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6/"/>
      <url>/2023/03/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="多个函数"><a href="#多个函数" class="headerlink" title="多个函数"></a>多个函数</h1><p>截至目前，所有的程序都只使用了printf（）函数。接下来我们来演示如何把自己的函数加入程序中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* two_func.c -- 一个文件中包含两个函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">butler</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* C函数原型 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I will summon the butler function.\n&quot;</span>);</span><br><span class="line">butler();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes. Bring me some tea and writeable DVDs.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">butler</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">/* 函数定义的开始 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You rang, sir?\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>butler()函数在程序中出现了3次。第1次是函数原型（prototype），告知编译器在程序中要使用该函数；第 2 次以函数调用（function call）的形式出现在 main()中；最后一次出现在函数定义（function definition）中，函数定义即是函数本身的源代码。</p><p>在 main()中调用 butler()很简单，写出函数名和圆括号即可。当butler()执行完毕后，程序会继续执行main()中的下一条语句。</p><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><p>在我们自己编写程序的过程中，会因为粗心大意犯一些错误，程序的错误通常叫做 bug，找出并修正错误的过程叫做调试（debug）。</p><p>通常来说程序的错误主要集中在三个方面：语法错误，语义错误，程序状态。</p><p>语法错误：C语言的语法错误指的是，把有效的C符号放在错误的地方。</p><p>语义错误：在C语言中，如果遵循了C规则，但是结果不正确，那就是犯了语义错误。</p><p>Tip：编译器无法检测语义错误，因为这类错误并未违反 C语言的规则。</p><p>程序状态：程序状态是在程序的执行过程中，某给定点上所有变量值的集合。它是计算机当前状态的一个快照。</p><h1 id="关键字和保留标识符"><a href="#关键字和保留标识符" class="headerlink" title="关键字和保留标识符"></a>关键字和保留标识符</h1><p>关键字是C语言的词汇。它们对C而言比较特殊，不能用它们作为标识符（如，变量名）。许多关键字用于指定不同的类型，如 int。还有一些关键字（如，if）用于控制程序中语句的执行顺序。如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230323141935.png"></p><p>保留标识符包括那些以下划线字符开头的标识符和标准库函数名，如printf（）。</p><p>对C语言的了解在此篇结束，接下来开始学习C语言中的数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言回顾</title>
      <link href="/2023/03/18/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/"/>
      <url>/2023/03/18/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言初识"><a href="#C语言初识" class="headerlink" title="C语言初识"></a>C语言初识</h1><p>C语言属于编译型语言，所以编写C程序的过程大致可以分为7个步骤：</p><ol><li>定义程序目标</li><li>设计程序</li><li>编写代码</li><li>编译</li><li>运行程序</li><li>测试和调试程序</li><li>维护和修改程序</li></ol><p>在理想状态下，完成7个步骤即可，但在一些大型项目中，需要我们做一些重复的工作。7个步骤中，我认为最重要的是1，2两个步骤，当我们接到一个项目时，无论简单与否，不是拿起电脑就开始敲代码，而是应该确定我们这个项目的目标，这样我们才能将心无旁骛地前进；而设计程序是为了扫除项目中无关紧要的细枝末节，使得程序最大程度上得到精简。</p><p>完成以上的工作之后，我们就可以开始编写代码了，以我们最常见的Hello world.c为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是编译的过程，编者主要使用Linux系统编写的C程序，有关编译过程可以找博客中关于命令行的编译知识。在编译过程中，编译器会检查C程序是否有效，如果发现错误，那么编译器会报告相应的错误，理解报错也是我们应当掌握的技能。</p><p>第5-7步就是得出结果和维护的过程，C程序是以能否运行为首要前提，而在此之后，我们就要对自己写的程序进行不断优化，编者相信不管什么时候都要抱有一颗学徒的心，为了使程序变得更好，剩下的步骤显得格外珍贵。</p><h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1><p>一般来说，C程序是以.c作为文件的扩展名，以满足当前系统对文件名的要求，下面是一个简单的C程序，分块查看一个程序包含那些部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>                           <span class="comment">/* 一个简单的C程序 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;                             <span class="comment">/* 定义一个名为num的变量 */</span></span><br><span class="line">num = <span class="number">1</span>;                             <span class="comment">/* 为num赋一个值 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am a simple&quot;</span>);             <span class="comment">/* 使用printf()函数 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;computer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My favorite number is d% because it is first.\n&quot;</span>,num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对任意一个C程序，我们都可以对它进行拆解，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230319153816.png"></p><p>头文件和include指令本质就是在程序执行前将准备工作做完，无需赘述。</p><p>main()函数，C程序一般都是从main()函数开始执行，因为该例中没有传递任何信息，因此圆括号内是void。</p><p>&#x2F;* ………….. *&#x2F; 是程序的注释，并不会执行，写注释可以让看程序者更容易明白程序要表达的意思。</p><p>{</p><p>…</p><p>} 是标记函数体的开始和结束。</p><p>int num 表示对num这个变量进行声明，说明num是一个整数变量。</p><p>数据类型包括整数、字符和浮点数等，变量声明是一个程序的必要步骤，命名只能是字母、数字和下划线，且第一个字符必须是字母或者下划线。</p><p>\n 是换行的意思，换行符是转义序列，例如 \t 表示Tab键，\b 表示Backspace键，每一个转义序列都是以反斜()开始，以后再来细说。</p><p>d% 是一个占位符，作用是指明num值输出的位置，在语句最后要将num加上。</p><p>return 0 就是程序的结尾。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行初识</title>
      <link href="/2023/03/17/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/2023/03/17/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux命令行"><a href="#Linux命令行" class="headerlink" title="Linux命令行"></a>Linux命令行</h1><p>linux系统使用时有别于windows系统，没有完美的图形界面，所以命令行成为了使用linux系统的基础。</p><p>Tips：linux系统在使用时一般使用正斜线（&#x2F;），而不是反斜线（\），linux中反斜线表示转义字符。</p><p>首先是进入控制台使用的快捷键：Ctrl+Alt+t：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230317133117.png"></p><p>进入控制台后我们就可以开始学习命令行了。</p><p>正如window中一样，我们首先要知道怎么打开一个文件夹，在linux中使用的cd命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$cd /home                     进入名为home的目录</span><br></pre></td></tr></table></figure><p>cd命令的参数可以用两种方法表示：一种是使用绝对文件路径，另一种是使用相对文件路径。</p><p>绝对文件路径较为简单，同windows理，在执行上述代码后，~会变成&#x2F;home，这时就处于home的目录下了。若是没有配置好提示符来显示当前shell会话的绝对文件路径，可以使用pwd命令显示出来，如下图。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317142148.png"></p><p>相对文件路径是允许用户指定一个基于当前位置的目标文件路径。相对文件路径不以代表根目录的正斜线（&#x2F;）开头，而是以目录名或是一个特殊字符开始。假如位于home目录中，并希望切换到代码子目录，那么可以使用cd命令加上一个相对文件路径：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317142732.png"></p><p>上图并没有使用正斜线（&#x2F;），而是采用了相对文件路径将大大减少输入内容。</p><p>另有两个特殊字符可用于相对文件路径中</p><p>单点符（.），表示当前目录；</p><p>双点符（..），表示当前目录的父目录。</p><p>双点符在目录层级的移动时非常便利，如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317143139.png"></p><p>从home目录下的代码文件夹移动到视频文件夹。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/18/hello-world/"/>
      <url>/2022/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
