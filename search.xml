<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言浅学-字符串和字符串函数</title>
      <link href="/2023/09/09/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/"/>
      <url>/2023/09/09/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在结束了</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-数组和指针</title>
      <link href="/2023/09/02/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/"/>
      <url>/2023/09/02/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>在结束了关于函数的学习之后并且对于指针有了初步的了解了之后，这一篇就来进一步学习数组和指针的相关知识。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#初学-</title>
      <link href="/2023/08/28/C#%E5%88%9D%E5%AD%A6/"/>
      <url>/2023/08/28/C#%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alist挂载</title>
      <link href="/2023/08/22/Alist%E6%8C%82%E8%BD%BD/"/>
      <url>/2023/08/22/Alist%E6%8C%82%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>在github上下载压缩包，进行解压，然后在该路径下进入命令行输入：</p><p>alist server</p><p>在启动了alist之后会得到一串密码，然后在浏览器中输入127.0.0.1:5244进入alist的网站，进行登录，一开始的初始名是admin 和默认密码。</p><p>登录之后可以进行更改名字和密码。</p><p>然后就是按照alist文档中进行网盘的添加，添加完成之后加上自启动的vbs脚本：</p><p>这是最后自启动的命令：</p><p>Set ws &#x3D; Createobject(“Wscript.Shell”)<br>ws.run “E:\Alist\alist.exe server”,vbhide</p><p>再将vbs脚本的快捷方式放入启动项中即可，win + R后输入：</p><p>shell: startup 进入文件夹。</p><p>在完成这些步骤之后，搭配Raidrive一起使用就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-函数</title>
      <link href="/2023/08/09/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%87%BD%E6%95%B0/"/>
      <url>/2023/08/09/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>上篇我们结束了关于字符输入&#x2F;输出和输入验证的学习，接下来我们就将展开关于函数的学习，主要学习关键字return 和 一元运算符* 、&amp; 以及函数的定义方式，包括使用参数和返回值、将指针变量用作函数参数、函数类型、递归。</p><p>C语言的设计思想是把函数用作构件块，我们已经使用过C标准库的函数，现在来学习一下怎么创建自己的函数。</p><h1 id="复习函数"><a href="#复习函数" class="headerlink" title="复习函数"></a>复习函数</h1><p>函数是完成特定任务的独立代码程序代码单元，语法规则定义函数的结构和使用方式，虽然C中的函数和其他语言中的函数、子程序作用相同，细节略有不同。一些函数执行某些动作；一些函数找出一个值给程序使用，一般来说，函数可以同时具备以上的两种功能。</p><p>函数的使用可以省去重复编写代码的苦差，若是程序需要多次完成某项任务，只需要编写一个合适的函数，就可以在需要这个函数时，或者是在不同程序使用该函数；其次，即使程序只完成一次任务，也值得使用函数。这样的函数可以让程序的模块化，提高代码的可读性，方便后期修改完善。</p><p>下面来完成一个实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308211717717.png"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 50</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> <span class="built_in">list</span>[SIZE];</span><br><span class="line">    readlist(<span class="built_in">list</span>, SIZE);</span><br><span class="line">    sort(<span class="built_in">list</span>, SIZE);</span><br><span class="line">    average(<span class="built_in">list</span>, SIZE);</span><br><span class="line">    bargraph(<span class="built_in">list</span>, SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然我们还需要编写4个函数：readlist（）、sort（）、average（）和bargraph（）的实现细节和具体代码。描述性的函数名能清晰地表达函数的用途和组织结构。单独对每个函数进行设计和测试，直到每个函数都可以完成任务，若是通用还可以用于别的程序之中。</p><p>一般来说，函数会被看作是一个根据输入及其生成值或是响应的黑盒。若非自己编写的函数，其实无需关心黑盒的内部行为，例如，使用printf（）的时候，我们只需要给这个函数传入格式字符串或一些参数以及printf（）生成的输出，无需了解这个函数的代码。在动手编写代码之前需要先考虑一下代码具体的作用和任务。</p><h2 id="创建并使用简单的函数"><a href="#创建并使用简单的函数" class="headerlink" title="创建并使用简单的函数"></a>创建并使用简单的函数</h2><p>第一个目标是创建一个在一行打印40个星号的函数，并在一个打印表头的程序中使用该函数。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;GIGATHINK, INC.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS <span class="string">&quot;101 Megabuck Plaza&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLACE <span class="string">&quot;Megapolis, CA 94904&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH 40</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">starbar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    starbar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, NAME);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ADDRESS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, PLACE);</span><br><span class="line">    starbar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">starbar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= WIDTH; count++)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h2><p>这个程序中需要注意以下几点，程序在3个地方使用了starbar标识符：函数原型是告诉编译器函数starbar（）的类型；函数调用表明在此处执行函数；函数定义就是把代码要实现的功能完完整整的写下来。</p><p>函数和变量一样，有许多的类型，任何程序在使用函数之前都要声明该函数的类型，因此在main（）函数定义的前面出现了ANSI C风格的函数原型：</p><p>void starbar（void);</p><p>圆括号表明starbar 是一个函数名，第一个void是函数类型，void类型说明这是一个没有返回值的函数，第二个void的意思是说明这个函数不带参数，分号说明这是在声明函数而不是在定义函数，并且告诉编译器在别处查找该函数的定义。</p><p>一般来说，函数原型指明了函数的返回值类型和函数接受的参数类型，这些统称为该函数的签名，对于starbar（）函数来说，签名就是没有返回值，没有参数。对于不识别ANSI C 风格的编译器，只需要声明函数的类型，一些老版本的编译器甚至连void 都识别不了，但是若是这么老的版本最好还是换一个。</p><p>程序把starbar（）原型置于main（）的前面，当然也可以放在main（）里面的声明变量处，放在那个位置都可以，在main（）中，执行到starbar（）；就是调用了这个函数。这是调用void类型函数的一种形式。当计算机执行到该句时，会找到这个函数的定义并执行其中的内容，执行完函数的代码之后，计算机会返回主函数继续执行下一行。</p><p>执行结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308241050627.png"></p><p>程序中starbar（）和main（）的定义形式相同，都包括函数类型、函数名和圆括号，然后是变量声明、函数表达式语句。这是函数头告诉后面没有分号，这是在定义starbar（），而不是在调用函数或声明函数原型。</p><p>程序把starbar（）和main（）放在一个文件中。当然也可以把它们分别放在两个文件中。放在一个文件比较容易编译，使用多个文件可以方便使用同一个函数，如果把函数放在一个单独的文件中，要把#define 和 #include 指令也放在这个文件里，稍后会讨论关于多个文件的情况。</p><p>starbar（）函数中的变量count是局部变量，意思是这个变量只是属于starbar（）函数，可以在程序中的其他地方继续使用count，不会引起名称冲突，属于是同名的不同变量。如果starbar（）函数是一个黑盒，那么行为就是打印一行星号，不需要给函数任何的输入，它也没有返回值，即函数和主调函数没有通信。</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在上面的输出中，若是文字可以居中会更加的美观，可以在打印字符前先打印一些空格，虽然和打印星号功能类似，但是可以写一个更加普适的函数，使用内置的字符和重复的次数来完成。</p><p>改进实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">/* 为strlen()提供原型 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAME <span class="string">&quot;GIGATHINK, INC.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADDRESS <span class="string">&quot;101 Megabuck Plaza&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLACE <span class="string">&quot;Megapolis, CA 94904&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&#x27; &#x27;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_n_char</span><span class="params">(<span class="type">char</span> ch, <span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> spaces;</span><br><span class="line">show_n_char(<span class="string">&#x27;*&#x27;</span>, WIDTH); <span class="comment">/* 用符号常量作为参数 */</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">show_n_char(SPACE, <span class="number">12</span>); <span class="comment">/* 用符号常量作为参数 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, NAME);</span><br><span class="line">spaces = (WIDTH - <span class="built_in">strlen</span>(ADDRESS)) / <span class="number">2</span>; <span class="comment">/* 计算要跳过多少个空格*/</span></span><br><span class="line">show_n_char(SPACE, spaces); <span class="comment">/* 用一个变量作为参数*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ADDRESS);</span><br><span class="line">show_n_char(SPACE, (WIDTH - <span class="built_in">strlen</span>(PLACE)) / <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, PLACE); <span class="comment">/* 用一个表达式作为参数 */</span></span><br><span class="line">show_n_char(<span class="string">&#x27;*&#x27;</span>, WIDTH);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_n_char</span><span class="params">(<span class="type">char</span> ch, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= num; count++)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化效果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308241613737.png"></p><p>在这一段程序中，就编写了一个带形参的函数，那么具体是如何去写并和主调函数完成通信的，接下来进行学习。</p><h2 id="定义带形参的函数"><a href="#定义带形参的函数" class="headerlink" title="定义带形参的函数"></a>定义带形参的函数</h2><p>函数的定义从下面的ANSI C 风格的函数头开始：</p><p>void show_char（char ch，int num）</p><p>这就相当于告诉编译器该函数使用了两个参数ch 和num ，ch 属于是字符型，num是整型，和定义在函数中的变量一样，形参也是局部变量，属于函数的私有，每次调用函数，就会给这些形参赋值。</p><p><strong>Tips：ANSI C要求在每个变量前都声明其类型，就是说不能像声明普通变量一样使用同一类型的变量列表。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dibs</span><span class="params">(<span class="type">int</span> x, y, z)</span> <span class="comment">//无效的函数头</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dibs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> <span class="comment">//有效的函数头</span></span><br></pre></td></tr></table></figure><p>ANSI C 也可以接受之前的形式，但是会将其视为废弃的形式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">show_n_char</span><span class="params">(ch, num)</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> num;</span><br></pre></td></tr></table></figure><p>在这里圆括号中只有参数名列表，但是参数的类型在后面进行声明，值得注意的是，普通的局部变量是在左花括号之后进行声明，这上面的变量是在左花括号之前就声明了，若是变量是同一类型，是可以用逗号进行变量的分隔的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dibs</span><span class="params">(x, y, z)</span></span><br><span class="line"><span class="type">int</span> x, y, z; <span class="comment">//有效</span></span><br></pre></td></tr></table></figure><p>虽然show_n_char（）函数可以接受来自main（）的值，但是这个函数是没有返回值的，所以函数类型是void。</p><h2 id="声明带形参的函数原型"><a href="#声明带形参的函数原型" class="headerlink" title="声明带形参的函数原型"></a>声明带形参的函数原型</h2><p>在使用函数之前，要使用ANSI C 形式声明函数原型：</p><p>void show_n_char（char ch，int num）；</p><p>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型，根据个人喜好，可以省略变量名。</p><p>void show_n_char（char，int）；</p><p>在原型中使用变量名并没有实际创建变量，char 也只是代表了一个字符类型的变量，以此类推。而且ANSI C 也接受过去的函数声明形式，即括号中没有参数列表，虽然这种形式最终会从标准中被剔除，了解是为了以后可以理解之前写的程序。</p><h2 id="调用带实参的函数"><a href="#调用带实参的函数" class="headerlink" title="调用带实参的函数"></a>调用带实参的函数</h2><p>在函数调用中，实际参数提供了ch和num的值，在上面的第二个程序中第一次调用函数：</p><p>show_n_char（SPACE，12）；</p><p>实际参数是 SPACE 和 12，这两个值被赋给了函数中对应的形参ch 和num 。简单说，形参是被调函数的变量，实参是主调函数赋给被调函数的具体值。如上所示，实参是常量、变量或者表达式，无论是那种最终都会被赋值给形参。</p><p>被调函数不知道也不关心传入的数值是来自哪里（变量、常量或是表达式），再次强调，实参是具体的值。但是因为被调函数使用的是从主调函数拷贝来的，所以无论做什么操作，都不会影响原始数据。</p><p>注意实际参数和形式参数：</p><p>实参是在函数调用时圆括号里的表达式，形参是函数定义时的声明的变量，调用函数时，创建了声明为形参的变量并初始化为实参的求值结果。</p><h2 id="黑盒视角"><a href="#黑盒视角" class="headerlink" title="黑盒视角"></a>黑盒视角</h2><p>若是从黑盒的视角来看 show_n_char （），带显示的字符和显示次数是输入；执行的结果是打印指定数量的字符。输入是以参数的形式被传递给函数。这些信息清楚地表明了如何在main（）中使用该函数。</p><p>黑盒方法的核心部分：ch、num和count都是show_n_char（）私有的局部变量，意味着若是主调函数中有一个同名变量，那么它们是相互独立的，互不干涉，也就是说main（）中count变量，改变它的值不会对show_n_char（）中的count产生影响，反之亦然。</p><h2 id="利用return从函数中返回值"><a href="#利用return从函数中返回值" class="headerlink" title="利用return从函数中返回值"></a>利用return从函数中返回值</h2><p>前面说明了怎么把信息从主调函数传递给被调函数，那么反过来函数的返回值也可以从被调函数传回给主调函数，为了进一步说明，创建一个返回两个参数中较小值的函数，由于函数被设计用来处理整型的值，可以命名为imin（）。还需要创建一个简单的main（），用于检查imin（）是否能正常工作。这种一般被称为驱动程序，该驱动程序调用一个函数。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">imin</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> evil1, evil2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a pair of integers (q to quit):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;evil1, &amp;evil2) == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The lesser of %d and %d is %d.\n&quot;</span>, evil1, evil2, imin(evil1, evil2));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a pair of integers (q to quit):\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">imin</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个版本</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">imin</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m &lt; n) ? m : n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个版本</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">imin</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; n)</span><br><span class="line">        min = m;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        min = n;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三个版本</span></span><br></pre></td></tr></table></figure><p>scanf（）函数返回成功读数据的个数，若是输入不是两个整数就会导致循环终止。下面是一个运行实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308251110801.png"></p><p>关键字return 后面的表达式的值就是函数的返回值。在该实例里该函数的返回值就是我们所需要的int类型值。所以imin（）函数的类型也是int。返回值属于imin（）函数私有，但是return语句把min的值传回了主调函数，下面的语句把imin（）的返回值赋给lesser：</p><p>lesser &#x3D; imin（n，m）；</p><p>是否能写成下面这样：</p><p>imin（n，m）；</p><p>lesser &#x3D; min；</p><p>自然是不能，因为主调函数甚至不知道min的存在。imin（）中的变量是imin（）的局部变量。函数调用imin（evil1，evil2）只是把两个变量的值拷贝一份。返回值不仅可以赋值给变量，也可以被用作表达式的一部分。</p><p>实例：</p><p>answer &#x3D; 2 * imin（z，star）+ 25；</p><p>printf（”%d\n”，imin（-32 + answer，LIMIT））；</p><p>返回值不一定是变量的值，也可以是任意表达式的值。就像是上面程序中的第二个版本，条件表达式的值是n 和 m 中的较小者，该值要被返回给主调函数，虽然这里不要求用圆括号把返回值括起来，若是为了条理清楚可以放在圆括号里。</p><p>如果函数返回值的类型与声明类型不匹配则会按照函数类型返回对应的值。return 语句还有另外一个作用就是终止函数并将控制返回给主函数的下一条语句。就像是上面的第一个版本。</p><p>多数程序员认为只在函数末尾使用一次return 语句比较好，这样做更方便人理解函数的控制流。但是，在函数中使用多个return 语句也是对的，所以函数的功能一样，实现细节是可以优化的。其次，return 语句之后的不会执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//这个语句可以终止函数，并且返回主函数，只有在void函数会用到这形式。</span></span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>声明函数必须声明函数的类型，带返回值的函数类型当与返回值的类型相同，没有返回值的声明为void ，最新的标准中不再支持老式的int类型假定。</p><p>类型声明是函数定义的一部分。要知道函数类型指的是返回值的类型，不是函数参数的类型：</p><p>double klink（int a，int b）</p><p>即是两个整型变量，返回值是双精度浮点型。要正确地使用函数，程序在第一次使用函数之前需要知道其类型。把完整的函数定义放在第一次调用函数的前面，但是这样的方法会增加阅读难度。所以一般来说需要提前声明函数原型，将信息告知编译器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">imin</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> evil1, evil2, lesser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">imin</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line">    <span class="type">int</span> evil1, evil2, lesser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种方式</span></span><br></pre></td></tr></table></figure><p>上述两种情况，函数原型都声明在使用函数之前。ANSI C 标准库里，函数被分成几个系列，每一个系列都有自己的头文件。这些头文件除了其他内容，还包含了本系列所有函数的声明。例如，stdio.h 头文件包含了标准I&#x2F;O库函数的声明。math.h头文件包含了各种数学函数的声明。</p><p>sqrt（）函数的声明就是：double sqrt（double）；</p><p>告知编译器sqrt（）函数有一个double类型的形参，且返回的也是double类型的值，不要混淆函数的声明和定义，函数声明告知编译器函数的类型，而函数定义则提供实际的代码。在程序中包含math.h头文件告知编译器：sqrt（）返回double类型，但是函数的代码在另一个库函数的文件。</p><h1 id="ANSI-C函数原型"><a href="#ANSI-C函数原型" class="headerlink" title="ANSI C函数原型"></a>ANSI C函数原型</h1><p>在ANSI C 标准之前，声明函数的方案有缺陷，因为只需要声明函数类型，不用声明任何参数，下面看看旧式函数会导致什么问题。旧式函数声明：</p><p>int imin（）；</p><p>但是上面的函数声明并没有给出imin（）函数的参数个数和类型，所以，若是调用imin（）时使用的参数个数不对或是类型不对，编译器是不会察觉的。</p><h2 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h2><p>我们看看和imax（）函数相关的例子，这个函数和imin（）函数关系密切。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">imax</span><span class="params">()</span>;<span class="comment">//旧式函数声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The max number from %d or %d is %d\n&quot;</span>, <span class="number">3</span>, <span class="number">5</span>, imax(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The max number from %d and %d is %d&quot;</span>, <span class="number">3</span>, <span class="number">5</span>, imax(<span class="number">3.0</span>, <span class="number">5.0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">imax</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m &gt; n ? m : n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序展示的是定义了一个旧式函数并且错误的使用它，第一次调用printf（）时省略imax（）的一个参数，第二次调用时printf（）用了两个浮点参数而不是整数参数，虽然有些问题，但是程序仍然可以编译运行。</p><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308261048142.png"></p><p>这两个编译器都运行正常，之所以输出错误的结果就是因为程序没有使用函数原型。由于不同的系统，出现问题的具体情况也不一样，主调函数把它的参数储存在被称为栈的临时存储区，被调函数从栈中读取这些参数。在这个例子里面，两个过程并没有相互协调，主调函数根据调用的实际参数决定传递的类型，而被调函数根据形参读取值。</p><p>第一次imax（3）把整数3放入栈中，当imax（）函数开始执行时，它从栈中读取两个整数，但实际上栈中只存放了一个待读取的整数，读取的第二个值是在栈中的其他值。</p><p>第二次使用imax（）函数时，它传递的是float类型的值，这次把两个double类型的值放入栈中，double类型一个64位，所以总共128位的数据被放到栈中，当imax（）从栈中读取两个整型的值，共读取64位，这些数据中比较大的是后面这个。</p><h2 id="ANSI的解决方案"><a href="#ANSI的解决方案" class="headerlink" title="ANSI的解决方案"></a>ANSI的解决方案</h2><p>针对参数不匹配的问题，ANSI C 标准要求在函数声明时还需要声明变量的类型，即使用函数原型来声明函数的返回类型、参数的数量和类型。当我们定义好了函数原型之后，编译器就可以检查函数调用是否和函数原型匹配，参数数量是否正确，类型是否匹配，以imax（）为例，若是两个数字类型不匹配，编译器会把实参转换成形参的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">imax</span><span class="params">(<span class="type">int</span> , <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The max number from %d or %d is %d\n&quot;</span>, <span class="number">3</span>, <span class="number">5</span>, imax(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The max number from %d and %d is %d\n&quot;</span>, <span class="number">3</span>, <span class="number">5</span>, imax(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">imax</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (m &gt; n ? m : n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上编译之后，就会出现函数参数太少的错误消息。</p><p>若是类型不匹配，用imax（3，5）代替imax（3），再次编译该程序，输出就正常了。第二次调用中的3.0和5.0被转换成3和5，方便函数能正确地处理输入。虽然没有错误消息，但是编译器还是给出了警告：double转换成int可能会导致丢失数据。imax（3.9，5.4）相当于imax（3，5）。</p><p>错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些编译器在进行类似的类型转换时不会通知客户，因为C标准中对此未作要求，不过，许多的编译器都允许用户选择警告的级别来控制描述警告的详细程度。</p><h2 id="无参数和未指定参数"><a href="#无参数和未指定参数" class="headerlink" title="无参数和未指定参数"></a>无参数和未指定参数</h2><p>假定下面的函数原型：</p><p>void print_name（）；</p><p> 一个支持ANSI C 的编译器会假定用户没有用函数原型来声明函数，为了表明函数确实没有参数，应该在圆括号里使用void 关键字：</p><p>void print_name（void）；</p><p>支持ANSI C 的编译器解释为print_name（）不接受任何参数。然后在调用函数时，编译器会检查确保没有使用参数。但是有一些函数会接受许多参数，例如printf（），第一个参数是字符串，剩下的参数类型和数量都不固定。对于这个情况，ANSI C 允许使用部分原型：</p><p>int printf（const char *，…）;</p><p>这种原型表明，第一个参数是一个字符串（之后会介绍），可能还有其他未指定的参数。C库通过stdarg.h 头文件提供了一个定义这类（形参数量不固定）函数的标准方法。</p><h2 id="函数原型的优点"><a href="#函数原型的优点" class="headerlink" title="函数原型的优点"></a>函数原型的优点</h2><p>函数原型是C 语言的一个强有力的工具，它可以让编译器在获取使用函数时可能会出现的错误和纰漏，若是编译器没发现问题，就很难觉察出来。有一种方法可以省略函数原型却能保留函数原型的优点，首先要明白，之所以使用函数原型，是为了让编译器在第一次执行到该函数之前就知道如何使用它。因此把整个函数定义放在第一次调用函数之前也有相同的效果，较小的函数这种用法十分普遍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">imax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, z;</span><br><span class="line">    z = imax(x, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是最简单的使用方式，但是这只适合比较小的函数，若是功能复杂的函数模块还是将函数原型和函数定义分开比较好。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>C允许函数调用它自己，这种调用过程叫做递归。递归有时候难以捉摸，有时候却很方便实用。递归使用的难点在于结束递归，一般来说递归代码没有终止递归的条件测试部分，一个调用自己的函数会无限递归。</p><p>一般来说可以使用循环的地方都可以使用递归，有时候使用循环较好，有时候使用递归更好，递归方案更加简洁，效率却没有循环高。</p><h2 id="递归演示"><a href="#递归演示" class="headerlink" title="递归演示"></a>递归演示</h2><p>通过一个实例来学习一下什么是递归。在主函数里调用up_and_down（）函数，该函数里面再调用自己，第一次是第一级递归，第二次是第二级递归，以此类推。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_and_down</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    up_and_down(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">up_and_down</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Level %d: n location %p\n&quot;</span>, n, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>)</span><br><span class="line">        up_and_down(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LEVEL %d：n location %p\n&quot;</span>, n, &amp;n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是系统的输出：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308281334944.png"></p><p>来分析一下程序里的递归是怎么工作的，首先，main（）函数调用了带参数1的up_and_down（）函数，执行的结果是up_and_down（）中的形式参数n的值是1，所以打印语句#1是打印Level 1 。然后，由于n小于4，up_and_down（）调用实际参数为n + 1 的up_and_down（）。第二级里n是2，和这个类似，调用打印的分别是Level 3和Level 4 。</p><p>当执行到第四级的时候，n 的值是4，所以 if 测试条件为假。up_and_down（）函数不再调用自己，第四级调用接着执行打印语句#2，即是打印LEVEL 4，因为 n 的值是4，此时，第四级调用结束，控制传回它的主调函数（第三级调用），执行下一个语句，以此类推。</p><p><strong>Tips：注意，每级递归的变量 n 都属于本级递归私有。这从程序输出的地址值可以看的出来。</strong></p><p>递归是一条函数调用链，fun1（）调用 fun2（）、fun2（）调用fun3（），当最后的调用结束时，控制权就会返回上一级的函数，当fun3（）结束时，返回给fun2（），递归的情况与此类似，只不过fun1（）-  fun4（）都是相同的函数。</p><h2 id="递归的基本原理"><a href="#递归的基本原理" class="headerlink" title="递归的基本原理"></a>递归的基本原理</h2><p>初次接触递归会觉得比较难以理解，但是递归的过程主要在于几个要点：</p><p>第一：每一级的函数调用都有自己的变量，也就是说，第一级的 n 和第二级的 n 不同，所以说程序创建了4个单独的变量，每个变量名都是 n ，但是它们的值各不相同。当程序最终返回up_and_down（）的第一级调用时，最初的n 仍然是它的初值是1。</p><p>第二：每次函数调用都会返回一次，当函数执行完毕，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某一级up_and_down（）返回上一级的up_and_down（），不能跳级返回到主函数的第一级调用。</p><p>第三：递归函数中位于递归调用之前的语句，均按照被调函数的顺序执行。</p><p>第四：递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。递归调用的这种特性在解决涉及相反顺序的编程问题很有用。</p><p>第五：虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。（实际上，递归有时候可以用循环来代替，循环有时也能用递归来代替）</p><p>最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都会使用 if 或者其他的等价测试条件在函数形参等于某个特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。最终，实际参数等于4的时候，if 的测试条件（n &lt; 4）为假。</p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>最简单的递归形式就是把递归调用置于函数的末尾，即正好在return 语句之前。这种形式的递归被称为尾递归，递归在函数的末尾。尾递归其实就相当于是循环。下面要介绍的实例，分别使用循环和尾递归计算阶乘，一个正整数的阶乘是从1到该整数的所有整数的乘积。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program calculates factorials.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a value in the range 0-12 (q to quit):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No negative numbers, please.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; <span class="number">12</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Keep input under 13.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;loop: %d factorial = %ld\n&quot;</span>, num, fact(num));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recursion: %d factorial = %ld\n&quot;</span>, num, rfact(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a value in the range 0-12 (q to quit):\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">fact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (ans = <span class="number">1</span>; n &gt; <span class="number">1</span>; n--)</span><br><span class="line">        ans *= n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">rfact</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> ans;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        ans = n*rfact(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试驱动程序把输入限制在0-12。因为12！快接近5亿，而13！比62亿还大，已超过我们系统中long 类型能表示的范围。要计算超过12的阶乘，必须使用能表示更大范围的类型，就像double或long long。</p><p>使用循环的函数把ans初始化为1，然后把ans与从n~2的所有递减整数相乘，根据阶乘的公式还要乘1，但其实并不会改变结果。现在应该考虑使用递归的函数，函数的关键在于n！&#x3D; n * （n - 1）！，这样做是因为（n - 1）！是 n - 1 到1的正整数的乘积。所以这一特性很适合使用递归。就像是上面的 rfact（）函数一样，可以通过递归调用来计算 n 的阶乘，当然还必须要在满足条件时结束递归，在 n 等于0 时设置返回值为1。</p><p>但是在程序中使用递归的输出和使用循环的输出是相同的，值得注意的是，虽然rfact（）的递归调用不是函数的最后一行，但是在 n &gt; 0 时，它是函数执行的最后一条语句，所以也属于尾递归。若是递归和循环都没有问题的话，应该使用哪一个呢，一般来说选择循环比较好，因为每一次的递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度很慢。</p><h2 id="递归和倒序运算"><a href="#递归和倒序运算" class="headerlink" title="递归和倒序运算"></a>递归和倒序运算</h2><p>递归在处理倒序的时候非常的方便（在解决这类问题中，递归比循环简单）。一个简单的例子，编写一个函数，打印一个整数的二进制数。那么就需要一个以二进制形式表示整数的算法，在二进制中，奇数的末尾一定是1，偶数的末尾一定是0，所以末位的数字我们就可以用取余的算法来确定，对于数字n 来说，其二进制的最后一位是n % 2，所以计算的第一位数字实际上是二进制数的最后一位。也就是说我们可以在递归函数的递归调用之前计算n % 2，在递归调用之后打印计算结果，这样的话计算的第一个值就是二进制的最后一位。</p><p>要想获得下一位数字，必须把原数除以2，这种计算方法相当于在十进制下把小数点左移一位，若是计算结果是偶数，那么二进制下一位就是0，反之则是1。计算的过程循环往复，当我们需要停止计算的时候就是与2相除的结果小于2时停止计算，因为只要大于等于2，就说明还有二进制位。每次除以2就相当于去掉一位二进制，直到算出最后一位为止。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">to_binary</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter an integer (q to quit):\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lu&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Binary equivalent: &quot;</span>);</span><br><span class="line">        to_binary(num);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter an integer (q to quit):\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">to_binary</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    r = n % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">2</span>)</span><br><span class="line">        to_binary(n / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(r == <span class="number">0</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，如果 r 的值是0，函数就显示0，若是 r 的值是1，函数就会显示1。</p><p>运行示例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308291646185.png"></p><p>若是不使用递归的话，是否有二进制表示整数的算法，当然可以实现，但是由于这个算法要首先计算最后一位二进制数，在显示结果之前必须把所有的位数都存储在别处（数组）。</p><h2 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h2><p>优点：递归给一些编程问题提供了最简单的解决方案。</p><p>缺点：递归算法会快速消耗计算机的内存资源，其次递归不方便阅读和维护。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">Fibonacci</span><span class="params">(<span class="type">unsigned</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的递归函数仅仅是重述了数学上定义的递归，该函数使用了双递归，即函数每一级递归都要调用本身两次。在 n 比较小的时候，这个递归调用还在内存能承受的范围之内，但若是 n 较大的时候，每一级递归所创建的变量都会呈指数级的增长，这就会非常消耗计算机的内存。</p><p><strong>Tip：这也从侧面说明了使用递归前需要注意是否为效率优先的程序。</strong></p><p>程序中的每个C函数与其他函数都是平等的，每个函数都可以调用其他函数，也可以被其他函数调用。最特殊的当为main（）函数，main（）函数和其他函数在一起时，最开始执行的就是main（）函数的第一条语句，但是main（）也可以被自己和其他函数递归调用。（一般不这么做）</p><h1 id="编译多源代码文件的程序"><a href="#编译多源代码文件的程序" class="headerlink" title="编译多源代码文件的程序"></a>编译多源代码文件的程序</h1><p>多函数的使用方法就是将它们放在同一个文件中，然后像编译一个文件那样编译即可。</p><h2 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h2><p>若是在UNIX系统中安装了UNIX C编译器cc，假设file1.c 和file2.c 是两个内含C函数的文件，下面的命令将编译两个文件并生成一个名为 a.out 的可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc file1.c file2.c</span><br></pre></td></tr></table></figure><p>另外还会生成两个名为 file1.o 和 file2.o 的目标文件，若是后来对其中一个函数文件进行改动，那么可以使用以下的命令进行编译和合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc file1.c file.o</span><br></pre></td></tr></table></figure><p>UNIX系统的make命令可以自动管理多文件程序，但这超出了讨论范围。</p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p>若是Linux系统安装了GNU C编译器GCC，假设file1.c 和file2.c 是两个内含C函数的文件，下面的命令将编译两个文件并生成名为 a.out 的可执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc file1.c file2.c</span><br></pre></td></tr></table></figure><p>另外还生成两个名为file1.o 和file2.o 的目标文件。如果后来改动了file1.c，可以使用命令编译第一个文件，并与第二个文件的目标代码合并：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc file1.c file2.o</span><br></pre></td></tr></table></figure><h2 id="DOS命令行编译器"><a href="#DOS命令行编译器" class="headerlink" title="DOS命令行编译器"></a>DOS命令行编译器</h2><p>绝大多数的DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过使用不同名称而已，还有一个区别，对象文件的扩展名是 .obj，而不是.o。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。</p><h2 id="Windows和苹果的IDE编译器"><a href="#Windows和苹果的IDE编译器" class="headerlink" title="Windows和苹果的IDE编译器"></a>Windows和苹果的IDE编译器</h2><p>Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的，项目是描述特定程序使用的资源，资源包括源代码文件，这种IDE中的编译器要创建项目来运行单文件程序。对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表里列出。许多的IDE都不用在项目列表中列出头文件，因为项目只管理使用的源代码文件，源代码使用#include 指令管理该文件中使用的头文件。</p><h2 id="头文件使用"><a href="#头文件使用" class="headerlink" title="头文件使用"></a>头文件使用</h2><p>如果把main（）放在第一个文件中，把函数定义放在第二个文件中，那么第一个文件还是需要使用函数原型。把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C 标准库就是这样做的，例如，把I&#x2F;O函数原型放在stdio.h中，把数学函数原型放在math.h中。你也可以这样用自定义的函数文件。</p><p>此外，程序中经常使用C预处理器定义符号常量。这种定义只存储在那些包含#define指令的文件里，但若是程序把一个函数放进一个独立的文件中，你也可以使用#define 指令访问每个文件，最直接的方法就是在每个文件中再次输入指令，但是这方法既耗时又费力还容易出错。而且程序一般还会有维护的问题：我们若是想要修改#define 定义的值，就必须在每个文件中进行修改，更好的做法就是把#define指令放进头文件，然后使用每个源文件前使用 #include 指令即可。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hotel.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nights;</span><br><span class="line">    <span class="type">double</span> hotel_rate;</span><br><span class="line">    <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">while</span> ((code = menu()) != QUIT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(code)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: hotel_rate = HOTEL1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: hotel_rate = HOTEL2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: hotel_rate = HOTEL3;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: hotel_rate = HOTEL4;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: hotel_rate = <span class="number">0.0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nights = getnights();</span><br><span class="line">        showprice(hotel_rate, nights);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thank you and goodbye.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hotel.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> code, status;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%s%s\n&quot;</span>, STARS, STARS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the number of the desired hotel:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1) Fairfield Arms2) Hotel Olympic\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3) Chertworthy Plaza4) The Stockton\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5) Quit\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s%s\n&quot;</span>, STARS, STARS);</span><br><span class="line">    <span class="keyword">while</span> ((status = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code)) != <span class="number">1</span> || code &lt; <span class="number">1</span> || code &gt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%*s&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter an integer from 1 to 5, please.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_nights</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nights;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How many nights are you needed?\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nights) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%*s&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer like 2.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nights;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">show_price</span><span class="params">(<span class="type">double</span> rate, <span class="type">int</span> nights)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; nights; n++, factor *= DISCOUNT)</span><br><span class="line">        total += factor * rate;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your stay price is $%0.2f.\n&quot;</span>, total);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> QUIT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hotel1 180.00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hotel2 225.00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hotel3 255.00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Hotel4 355.00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISCOUNT 0.95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STARS ”**********************************“</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_nights</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">show_price</span><span class="params">(<span class="type">double</span> hotel_rate, <span class="type">int</span> nights)</span>;</span><br><span class="line"><span class="comment">//这是 hotel.h 的文件内容</span></span><br></pre></td></tr></table></figure><p>这就是整个完整的程序要使用的三个文件，两个C 源文件，一个C 头文件，下面的是多文件程序的运行示例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308311416924.png"></p><p>在这个程序中，menu（）函数和getnights（）函数通过测试scanf（）的返回值来跳过非数值数据，而且还调用 scanf（”%*s”）跳至下一个空白字符。注意，menu（）函数中是如何检查非数值输入和超出范围的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((status = <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code)) != <span class="number">1</span> || code &lt; <span class="number">1</span> || code &gt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>以上代码利用了C语言的两个规则：从左往右对逻辑表达式求值；一旦求值结果为假，立即停止求值。在这个例子里，只有在scanf（）成功读入一个整数值，才会检查code的值。在不同的函数处理不同的任务时应该检查数据的有效性，但是一般来说首次编写函数时可以暂时不添加这一功能，之后再进行逐步改善各个模块。</p><h1 id="查找地址：-amp-运算符"><a href="#查找地址：-amp-运算符" class="headerlink" title="查找地址：&amp;运算符"></a>查找地址：&amp;运算符</h1><p>指针是 C 语言里最重要的概念之一，用于储存变量的地址，scanf（）函数中就使用地址作为参数，简单来说，要是主调函数不使用return返回的值，就必须通过地址才能修改主函数的值，接下来介绍一元&amp;运算符。</p><p>一元&amp;运算符给出的是变量的存储地址，若是 pooh 是变量名，那么&amp;pooh 就是变量的地址，可以把地址看作是变量在内存中的位置。</p><p>若是 pooh &#x3D; 24；且其地址为 0B76，那么 printf （”%d %p\n”，pooh，&amp;pooh）；的执行结果就是：24 0B76。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mikado</span><span class="params">(<span class="type">int</span> bah)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pooh = <span class="number">2</span>, bah = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In the main, pooh = %d and &amp;pooh = %p.\n&quot;</span>, pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In the main, bah = %d and &amp;bah = %p.\n&quot;</span>, bah, &amp;bah);</span><br><span class="line">    mikado(pooh);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mikado</span><span class="params">(<span class="type">int</span> bah)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pooh = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In the mikado, pooh = %d and &amp;pooh = %p.\n&quot;</span>, pooh, &amp;pooh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;In the mikado, bah = %d and &amp;bah = %p.\n&quot;</span>, bah, &amp;bah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序使用了%p的格式来打印地址，我们的系统输出如下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202309010945733.png"></p><p>实现不同，%p 表示的方式不同，然而许多实现都应该和这个例子一样，以十六进制显示地址，每个十六进制对应四位，这个例子显示16个十六进制数，对应64位地址。这个例子输出可以看出，两两同名的变量的地址均不相同。因此和前面介绍的一样，是看成4个独立的变量，另外mikado（）函数将主函数里的pooh传递给形参bah。</p><p><strong>Tip：这类传递只传递值，涉及的两个变量并没有改变。</strong></p><p>这一点很重要，因为这不是在所有语言中的都能成立的，在FORTRAN中，子例程会影响主调例程的原始变量，子例程的变量名可能与原始变量不同，但是它们的地址相同。但是C语言里不是这样的，每个C函数都有自己的变量。</p><h1 id="如何更改主调函数里的变量"><a href="#如何更改主调函数里的变量" class="headerlink" title="如何更改主调函数里的变量"></a>如何更改主调函数里的变量</h1><p>有时候需要在一个函数里改变其他函数的变量，例如普通的排序任务里交换两个变量的值。简单的思路就是：</p><p>x &#x3D; y；</p><p>y &#x3D; x；</p><p>上面这两句话完全不起作用，因为执行到第二行时，x 的原始值已经被 y 的原始值替换了。所以需要多写一行代码将 x 的原始值存储起来：</p><p>temp &#x3D; x；</p><p>x &#x3D; y；</p><p>y &#x3D; temp；</p><p>上面这三行代码可以实现交换值的功能，那么可以根据这个来编写一个函数并构造一个驱动来测试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    interchange(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一版交换值程序</span></span><br></pre></td></tr></table></figure><p>这是第一版的交换值程序，先来执行一下看看情况：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202309011122588.png"></p><p>可以看出两个变量的值并没有发生交换，在interchange（）函数中添加一些语句来检查错误出现在那。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    interchange(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally u = %d and v = %d.\n&quot;</span>, u, v);</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now u = %d and v = %d.\n&quot;</span>, u, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二版交换值程序</span></span><br></pre></td></tr></table></figure><p>第二版的执行情况：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202309011342256.png"></p><p>从这个情况来看，interchange（）函数没有问题，它交换了两个变量的值，问题出在了将结果传回给主函数的过程中，interchange（）使用的变量并不是main（）的变量，所以交换 u 和 v 的值对x 和 y 的值没有影响。对于传回最先想到的方法是return把数值传回main（）。当然可以，但是return一般只能返回一个值，但是现在需要传回两个值，可以实现需要用到指针。</p><h1 id="指针简介"><a href="#指针简介" class="headerlink" title="指针简介"></a>指针简介</h1><p>从根本上来说，指针是一个值为内存地址的变量（数据对象），指针变量的值是地址，在C语言中，指针有很多用法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;pooh;</span><br><span class="line">ptr = &amp;bah;</span><br><span class="line"><span class="comment">//第一句是把pooh的地址赋给ptr</span></span><br><span class="line"><span class="comment">//第二句是把bah的地址赋给ptr</span></span><br></pre></td></tr></table></figure><p>要创建指针变量，先要声明指针变量的类型，假定想把ptr声明为储存int类型变量地址的指针，就需要使用下面介绍的新运算符。</p><h2 id="间接运算符："><a href="#间接运算符：" class="headerlink" title="间接运算符：*"></a>间接运算符：*</h2><p>假设已知ptr指向bah，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;bah；</span><br><span class="line">val = *ptr; <span class="comment">//找出ptr指向的值</span></span><br><span class="line"><span class="comment">//这两句话放在一起相当于下面的语句</span></span><br><span class="line">val = bah；</span><br></pre></td></tr></table></figure><p>接下来使用间接运算符 * 找出储存在bah里的值，这个运算符有时候也叫解引用运算符，这个符号既是二元乘法运算符 * ，虽然符号相同，但是语法不同。上面是使用地址和间接运算符可以间接完成最后一句的功能，这也是间接运算符的由来。</p><p>小结：</p><p>与指针相关的运算符：</p><p>地址运算符：&amp;</p><p>一般注解：后跟一个变量名时，&amp;给出该变量的地址。</p><p>地址运算符：*</p><p>一般注解：后跟一个指针名或地址时，* 给出储存在指针指向地址上的值。</p><h2 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h2><p>对于指针变量我们应该怎么声明，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小，还需要知道储存在指定地址上的数据类型。下面是一些指针的声明示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * pi;<span class="comment">//pi是指向int类型变量的指针</span></span><br><span class="line"><span class="type">char</span> * pc;<span class="comment">//pc是指向char类型变量的指针</span></span><br><span class="line"><span class="type">float</span> * pf, * pg;<span class="comment">//pf, pg都是指向float类型变量的指针</span></span><br></pre></td></tr></table></figure><p>类型说明符表明了指针所指向对象的类型，星号（<em>）表明声明的变量是一个指针。int * pi；声明的意思是pi是一个指针，</em>pi 是int类型。星号和指针名之间的空格可有可无，一般来说在声明的时候使用空格，在解引用变量时省略空格。</p><p>pc 指向的值是char类型，pc 本身的值是一个地址，在大部分系统里是由一个无符号整数来表示，但是仅仅是表示，一些处理整数的操作不能用来处理指针，反之亦然。所以，指针不是整数类型，ANSI C 还专门提供了%p 的转换说明。</p><h2 id="利用指针实现函数间的通信"><a href="#利用指针实现函数间的通信" class="headerlink" title="利用指针实现函数间的通信"></a>利用指针实现函数间的通信</h2><p>指针是有很多的用法，就比如使用指针解决函数间的通信问题，可以对上面的程序进行更改，将interchange（）函数中的整型变量变成指针参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    interchange(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interchange</span><span class="params">(<span class="type">int</span> * u, <span class="type">int</span> * v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三版交换值程序</span></span><br></pre></td></tr></table></figure><p>第三版执行情况：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202309011708934.png"></p><p>运行正常，那么具体的函数调用是：interchange（&amp;x，&amp;y）；</p><p>函数传递的是x 和 y 的地址，而不是x 和 y 的值，这意味着出现在函数原型和定义的形参u 和 v 把地址作为它们的值，因此应该把它们声明为指针，由于x 和 y 是整数，所以u 和 v 是指向整数的指针，声明如下：</p><p>void interchange（int * u，int * v）</p><p>然后就是在函数体里声明了一个交换值时所需的临时变量，使用解引用运算符从 u 里提取出 x 的值进行交换。这个程序简单来说就是使用指针和 * 运算符，使得函数可以访问储存在这些位置的值并改变它们。</p><p>一般来说，可以把变量相关的两类信息传递给函数，如果是下面这样形式的函数调用，传递的是 x 的值：</p><p>function1（x）；</p><p>如果是下面形式的函数调用，那么传递的是 x 的地址：</p><p>function2（&amp;x）；</p><p>第一种形式要求函数定义中的形参必须是一个与 x 的类型相同的变量：</p><p>int function1（int num）；</p><p>第二种形式要求函数定义中的形参必须是一个指向正确类型的指针：</p><p>int function2（int * ptr）；</p><p>如果要计算和处理值，那么使用第一种形式的函数调用；若是要在被调函数中改变主调函数的变量就使用第二种形式的函数调用。scanf（）函数就是这样的，当程序要把一个值读入变量时，调用的是scanf（”%d”, &amp;num），读取一个值然后存储到对应的地址上。</p><p>在这个例子里，指针让interchange（）函数通过自己的局部变量改变main（）中的变量的值。在C++中也有指针变量，那么C语言中有没有引用变量，其实是没有的，引用变量其实就是给变量取一个别名（详见后续学习）。</p><p>变量：名称、地址和值</p><p>在编写程序的时候，一般认为变量包括两个属性：名称和值，计算机编译和加载程序后，变量也有两个属性：地址和值，地址就是变量在计算机内部的名称。在大部分的语言里，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&amp;运算符访问地址，通过*运算符获得地址上的值。简单来说，普通 变量把值作为基本量，把地址作为通过&amp;运算符获得的派生量；指针变量把地址作为基本量，把值作为通过星号运算符获得的派生量。</p><p>利用&amp;、*和指针可以操纵地址和地址上的内容，就像第三版程序一样。</p><p>小结：函数</p><p>形式：</p><p>典型的ANSI C 函数的定义形式为：</p><p>返回类型 名称 （形参声明列表）</p><p>函数体</p><p>形参声明列表是用逗号分隔的一系列变量声明。出形参变量外，函数的其他变量均在函数体内声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">diff</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    z = x - y;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递值：实参用于把值从主调函数传递给被调函数，若是变量 a 和 b 的值分别是5和2，那么调用：c &#x3D; diff（a，b）；这条语句把5和2分别传递给变量 x 和 y 。5和2叫做实参，传递给 x 和 y 这两个形参，使用关键字return 把被调函数中的一个值传回主函数，被调函数一般不会改变主调函数的变量，若是想要改变，要使用指针作为参数，希望把更多的值传回主调函数更要这么做。</p><p>函数的返回类型：指的是函数返回值的类型，若是返回值的类型与声明的返回类型不匹配，返回值会被转换成函数声明的返回类型。</p><p>函数签名：函数的返回类型和形参列表构成了函数签名。因此，函数签名指明了传入函数的值类型和函数返回值类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">duff</span><span class="params">(<span class="type">double</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> q, x;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    q = duff(x, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">duff</span><span class="params">(<span class="type">double</span> u, <span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> tor;</span><br><span class="line">    <span class="keyword">return</span> tor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h1><p>若是要用C编出高效灵活的程序，必须要理解函数，把大型程序组织成若干个函数更加有用，让一个函数处理一个任务，程序会更好理解，也更方便调试。更要理解函数是怎么把信息从一个函数传递到另一个函数，也就是要理解函数参数和返回值的工作原理，还要明白函数形参和其他局部变量都属于函数私有，因此声明在不同函数的同名变量是完全不同的变量，而且，函数无法直接访问其他函数的变量。若是要访问，必须把指针作为函数的参数。</p><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p>函数可以作为组成大型程序的构件块，每个函数都应该有一个单独且定义好的功能。具体的前面说过就不再赘述。ANSI C 提供了一个强大的工具——函数原型，允许编译器验证函数调用中使用的参数个数和类型是否正确。C 函数可以调用本身，这种调用方式被称为递归，有一些编程问题要用递归来解决，但是递归的缺点不仅消耗内存，效率不高且费时。</p><p>下一篇我们将对指针进行进一步的学习。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-字符输入/输出和输入验证</title>
      <link href="/2023/07/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81/"/>
      <url>/2023/07/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>我们在上一篇的博客中结束了对于控制语句的分支和跳转的学习，这一篇我们将开始学习字符输入&#x2F;输出和输入验证，更加详尽的介绍输入、输出以及缓冲输入和无缓冲输入的区别。</p><p>在涉及计算机的话题中，我们经常会讨论输入和输出，我们这一篇主要介绍的是输入和输出的函数（简称I&#x2F;O函数）。</p><p>I&#x2F;O函数：如printf（）、scanf（）、getchar（）以及putchar（）。这些函数负责把信息传送到程序中，前面已经介绍过这些函数的用法了，这一篇将详细介绍它们的基本概念。</p><h1 id="单字符I-x2F-O：getchar（）和putchar（）"><a href="#单字符I-x2F-O：getchar（）和putchar（）" class="headerlink" title="单字符I&#x2F;O：getchar（）和putchar（）"></a>单字符I&#x2F;O：getchar（）和putchar（）</h1><p>在上面那一篇我们说过，getchar（）和putchar（）每次都只能处理一个字符。虽然我们人认为这样的方式有点死板，但是毕竟电脑和人还是存在一定的差距的。这样的方式很适合计算机的，而且这也是绝大多数文本处理程序的核心方法。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自从C标准发布之后，C就把stdio.h头文件和使用getchar（）、putchar（）相关联起来了，这就是为什么程序都要包含这个头文件的原因。其实getchar（）和putchar（）都不是真正的函数，它们被定义为供预处理器使用的宏。</p><p>输出效果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308010907775.png"></p><p>那么字符是怎么显示在屏幕上的呢，用一个特殊的字符来结束输入，就无法在文本里使用这个字符了，是否有更好的方法来结束输入呢，我们需要了解缓冲和标准输入文件的概念。</p><h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><p>对于上面的程序，若是在老式系统上运行，我们输入文本的时候，可能显示如下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308010920185.png"></p><p>上图的这种行为是个例外，像这样回显示用户输入的字符立即重复打印该字符属于无缓冲（直接）输入，简单点说就是正在等待的程序可以立即使用输入的字符。对于这个例子来说，大部分的系统在用户按下回车键之前不会重复打印刚输入的字，这种形式就是缓冲输入。用户输入的字符会被收集并存储在一个名为缓冲区的临时存储区中，按下回车键后，程序才可以使用输入的字符。</p><p>具体差异可看下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308010943273.png"></p><p>缓冲区的作用：把若干个字符作为一个块进行传输比逐个发送这些字符节约不少的时间，其次，若是用户打错字符可以直接通过键盘修正错误，当最后按下回车键，传入的是正确的输入即可。</p><p>虽然缓冲输入好处多，但是任何事物都是具有两面性的，某些交互式程序也需要无缓冲输入。例如，在游戏中，就会希望按下一个键就执行相应的指令。所以缓冲输入和无缓冲输入都是有自己的用处。</p><p>缓冲主要也分为两类：完全缓冲I&#x2F;O 和 行缓冲I&#x2F;O，完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容会被发送到目的地）这样的方式一般用在文件输入中。缓冲区的大小主要取决于系统，常见的大小主要是512字节和4096字节。行缓冲指的就是在出现换行符的时候刷新缓冲区，键盘输入一般就是行缓冲输入，在按下回车键后才刷新缓冲区。</p><p>那么该如何选择是缓冲输入还是无缓冲输入，ANSI C 和后续的C标准都是规定输入是缓冲的，在一开始其实是把这个决定权交给编写者。</p><p>ANSI C 标准决定把缓冲输入作为标准的原因：一些计算机不允许无缓冲输入，若是计算机允许无缓冲输入，那么所使用的C 编译器就会提供无缓冲输入的选项，支持无缓冲输入的函数的原型大部分都在conio.h头文件中。在UNIX系统中使用另外一种方式来控制缓冲。在这里就不过多的赘述了。</p><h1 id="结束键盘输入"><a href="#结束键盘输入" class="headerlink" title="结束键盘输入"></a>结束键盘输入</h1><p>在上面的程序中，只要输入的字符中不包含#，那么程序只有在读到#才会结束。但是#也是一个普通字符，有时候总是会用到，C语言中的确有这样的字符。</p><h2 id="文件、流和键盘输入"><a href="#文件、流和键盘输入" class="headerlink" title="文件、流和键盘输入"></a>文件、流和键盘输入</h2><p>文件是存储器中储存信息的区域，通常文件都会保存在某种永久存储器里，毫无疑问，文件对于计算机系统非常重要。就像我们编写的程序就是保存在文件中，用来编译C程序的程序也保存在文件中。当编译器处理完之后，会关闭这个文件，其他的程序还要把数据写入文件。</p><p>C 语言有许多用于打开、读取、写入和关闭文件的库函数。在较低层面上，C 语言可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层I&#x2F;O。但是由于计算机系统各不相同，所以不太可能为普通的底层I&#x2F;O创建标准库，在较高的层面来说，C 语言是可以用标准的I&#x2F;O包来处理文件。</p><p>采用标准I&#x2F;O包，就不需要考虑这些差异了，因此可以使用 if  语句来检查换行符，即使系统实际用的是回车符来标记末尾，I&#x2F;O函数会在两种表示法之间相互转换。从概念上来看，C语言的程序处理的是流而不是文件。流是一个实际输入和输出映射出来的理想化数据流，意味着不同属性和不同种类的输入使用属性更加统一的流表示，也由流来进行读写等操作。</p><p>上面的内容可以知道使用处理文件的方法来处理键盘输入，一般来说是使用文件结尾检测器来结束键盘输入。</p><h2 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h2><p>一般PC系统都是要以某种方式来判断文件的开始和结束，最常用的是在文件末尾放一个特殊字符标记文件结尾。早期系统的文本文件都曾经使用过这种方法，现在都可以使用内嵌的Ctrl + Z 字符来标记文件结尾，这是曾经操作系统使用的唯一标记。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308011447531.png"></p><p>操作系统使用的另一种方法就是存储文件大小的信息，若是文件有3000字节，程序在读到3000字节时便达到文件的末尾，DOS系统使用这种方法来处理二进制文件，这种方法可以在文件中储存所有的字符，包括Ctrl + Z 。无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar（）读取文件检测到文件结尾时将返回一个特殊的值，即EOF。scanf（）函数检测到文件结尾也如此。</p><p><strong>EOF 的定义在stdio.h 头文件中：#define EOF （-1）。</strong></p><p>一般来说，getchar（）函数的返回值介于0~127之间，这些值对应标准的字符集，哪怕是使用扩展字符集，-1都不对应任何字符，可以拿来标记文件结尾。但是某些系统也会把EOF定义为 -1 之外的值，定义的值会与输入字符所产生的返回值不同，这些其实无伤大雅，只需要知道EOF是个值并且是检测文件结尾即可。</p><p> 如何使用EOF：可以将getchar（）的返回值和EOF进行比较，不同则是未达到文件结尾。若是正在读取的是键盘输入而不是文件会怎么样，大部分都有办法模拟文件结尾。对于上面的程序可以进行优化：</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然没有什么特别大的更改，但是程序运行起来之后，我们可以不用担心EOF的实际值而不敢使用某些特殊符号。还有一个变化就是变量ch的类型从char 变为了int，因为char类型的变量只能表示0~255的无符号整数，但是EOF的值为 -1 ，还好getchar（）的返回值的类型是int，所以它读取EOF字符，但也因为返回值是int类型，所以若是将返回值赋值给char类型的ch，一些编译器可能会出现问题，最好还是将ch定义为int类型最为稳妥。且ch是int类型不会影响putchar（）的输出。</p><p>采用键盘输入，要设法输入EOF字符，不能只输入字符，也不能只输入 -1 ，一般来说采取的方法是按照当前系统的要求，按下快捷键来作为识别文件结尾的信号。在windows系统里一般是Ctrl + C。</p><p>这个程序可以把输入的内容拷贝到屏幕上，那么我们可以想想这个程序有没有别的什么用途，若是传输进来一个文件，将文件内容打印在屏幕上，到达文件结尾时返现EOF信号停止；其次若是用某种方法将程序的输出定向到一个文件，用键盘输入数据，将两种方法结合到一起，就可以得到将输入定向到程序中，且输出发送到另一个文件中，就相当于可以使用这个小程序来拷贝文件。</p><h1 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h1><p>输入和输出涉及函数、数据和设备。像是上面的程序使用函数getchar（），输出设备是屏幕，输入的数据流由字符组成，若是输入函数和数据类型不变，改变程序查找数据的位置，那么程序在哪里找输入。</p><p>一般来说，C程序会使用标准的I&#x2F;O包查找标准输入作为源头就是前面介绍过的stdin流，是把数据读入计算机的常用方式。它可以是一些过时的设备进行输入，也可以从一个文件查找输入，不仅仅局限在键盘。</p><p>一个程序一般可以通过两种方式使用文件，第一种方法最简单，就像printf（）一样，使用特定的函数对文件进行打开，关闭，读取，写入等操作。第二种方法就是自己设计一个键盘和屏幕互动的程序，通过不同的渠道重定向输入到文件和输出到文件，简单说就是把stdin流赋给文件，或者用getchar（）从输入流获取数据。</p><p>重定向的主要问题是和操作系统有关，和C无关。来看看Unix、Linux和Windows的重定向。</p><h2 id="Unix、Linux和DOS重定向"><a href="#Unix、Linux和DOS重定向" class="headerlink" title="Unix、Linux和DOS重定向"></a>Unix、Linux和DOS重定向</h2><p>Unix（运行命令行模式）、Linux（ditto）和windows的命令行提示都能重定向输入、输出，可以使得程序使用的是文件而不是键盘，输出也是同理，可以输出到文件而不是屏幕。</p><p>重定向输入：</p><p>若是我们已经编译了程序，并将可执行版本放入一个exe文件中，要运行只需要输入可执行文件名。该程序运行情况和前面一样，获取用户从键盘的输入，但是若是需要使用程序处理文本文件。就不是直接对程序进行执行，要使用文本文件，就需要使用命令行将文件传入程序：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Content</span> hello.txt | .\Helloworld | <span class="built_in">Out-File</span> output.txt</span><br></pre></td></tr></table></figure><p>Windows里的powershell和其他的命令行不同，上面的命令就是将文本文件通过程序再输出给output的文件。在Unix系统中，&lt; 是重定向运算符，这个运算符使得文本文件和stdin流相关联，程序本身其实不用关心输入的内容来自那，仅需要知道导入的是字符流即可。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308041117808.png"></p><p>这是重定向运算符的使用示例。</p><p>重定向输出：</p><p>若是要使用程序把键盘输入的内容发送到输出的文件中，可以输入命令进行输出：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308041358467.png"></p><p>在上面这个命令中，&gt; 符号是第二个重定向运算符，它会创建一个名为mywords的新文件，然后将程序的输出重定向至该文件。重定向把stdout从显示设备赋给mywords文件。若是已经有一个mywords文件，则会先擦除再替换文件的内容。然后在下一行的开始处我们按系统的快捷键即可结束程序，在每一行的末尾单击回车键，才能把缓冲区的内容发送给程序。也可以使用系统的查看命令对文件内容进行检查，或者再次使用程序，把文件重定向到程序。</p><p>组合重定向：</p><p>若是我们现在要做一个mywords文件的副本，并且重新命名为savewords，下面的命令可以实现：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308041601593.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308050906578.png"></p><p>这句命令错误的原因是在输入之前就会导致mywords的长度被截断为0。总而言之，在Unix、Linux和Windows中使用了两个重定向运算符（&lt;和&gt;），需要遵循以下的规则：</p><p>1.重定向运算符可以连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接两个数据文件，也不能用于连接两个程序。</p><p>2.重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件。</p><p>3.一般来说，文件名和运算符之间的空格不是必须的，除非是在系统中有特殊含义的字符，类似于转义字符那种（\n）。</p><p>在Unix、Linux和Window还有 &gt;&gt; 运算符，该运算符可以把数据添加到现有的文件的末尾，而 |  运算符可以把一个文件的输出连接到另一个文件的输入。</p><p>注释：</p><p>重定位可以使我们使用键盘输入程序文件，若是要完成这一任务，程序需要测试文件的末尾，例如那个统计单词的程序，直到遇到 | 符号，可以把ch的类型改为int类型，将循环测试中的 | 符号更换成EOF，就能够统计单词量了。</p><p>重定向是一个命令行的概念，因为我们要在命令行输入特殊的符号发出指令。每个系统和每个集成开发环境都可以使用重定向，具体情况具体分析。在使用情况来说，Terminal比gcc这些好用许多。若是使用不了重定向，可以直接使用程序打开文件。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> fname[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the name of the file: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;fname);</span><br><span class="line">    fp = fopen(fname, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open file. Bye!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((ch = getc(fp)) != EOF)</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><p>绝大部分的C系统都是可以使用重定向的，可以通过系统重定向所有的程序，或者只是在C编译器允许的情况下重定向C程序。</p><h1 id="创建友好的用户界面"><a href="#创建友好的用户界面" class="headerlink" title="创建友好的用户界面"></a>创建友好的用户界面</h1><p>大部分人偶尔会写一些不实用的程序，但是C会提供大量的工具让输入更加的流畅，处理更加顺利，这一小节主要是让交互数据更方便，减少输入错误。</p><h2 id="采用缓冲输入"><a href="#采用缓冲输入" class="headerlink" title="采用缓冲输入"></a>采用缓冲输入</h2><p>缓冲输入用起来非常的方便，在将输入发送到程序之前，用户可以编辑输入。但是与此同时也会带来麻烦，缓冲输入要求用户必须按下回车键发送输入，这也传递了换行符需要程序进行处理。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> guess = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pick an integer from 1 to 100. I will try to guess &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;it.\nRespond with a y if my guess is right and with&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nan n if it is wrong.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Uh...is your number %d?\n&quot;</span>, guess);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Well, then, is it %d?\n&quot;</span>, ++guess);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I knew i could do it!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的糟糕的算法先不谈，先选择一个数字，但是这个程序每次输入n时，都会打印两条消息主要是由于n作为用户否定了数字1，然后还读取换行符否定数字 2。那么一种解决方案是，使用while 循环丢弃输入行最后的剩余内容，包括换行符。这种方法的优点就是可以把 no 和 no way 这样的相应视为简单的 n 。</p><p>可以优化为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Well, then, is it %d?\n&quot;</span>, ++guess);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一小段的优化确实可以解决换行符的问题，但是这个程序会把除了y 之外的字母也识别为 n 。我们还是需要添加一个 if 语句进行判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> response;</span><br><span class="line"><span class="keyword">while</span> ((response = getchar()) != <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (response != <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;Well, then, it is %d\n&quot;</span>, ++guess);</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">&quot;We only recive y and n.\n&quot;</span>);</span><br><span class="line">           <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>从这上面的两次改进可以看出编写交互式程序的时候，应该事先预料到用户可能出现的错误，针对输入的错误进行处理并提醒再次输入。</p><h2 id="混合数值和字符输入"><a href="#混合数值和字符输入" class="headerlink" title="混合数值和字符输入"></a>混合数值和字符输入</h2><p>若是一个程序要求使用getchar（）处理字符输入，用scanf（）处理数值输入，这两个函数都可以很好的完成任务，但是不能将两个进行混用，因为getchar（）会读取每一个字符，包括空格、制表符和换行符，但是scanf（）在读取数字的时候会跳过这些符号。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">char</span> cr, <span class="type">int</span> lines, <span class="type">int</span> width)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a character and two integer:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;rows, &amp;cols);</span><br><span class="line">        display(ch, rows, cols);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter another character and two integer;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a new line to quit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">char</span> cr, <span class="type">int</span> lines, <span class="type">int</span> width)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt;= lines; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (col  = <span class="number">1</span>; col &lt;= width; col++)</span><br><span class="line">            <span class="built_in">putchar</span>(cr);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，main（）函数负责获取数据，display（）函数负责打印数据。但是在实际运行过程中会发现些许的小问题，就是输入完之后没有后续了。原因就是在输入行中紧跟3后面的换行符。scanf（）函数把这个换行符留在输入队列里，在进入下一轮迭代时，就会把换行符进行读取赋给ch。而ch是换行符就是正式终止循环的条件。</p><p>想要解决这个问题，程序需要跳过一轮输入结束和下一轮输入开始之间的所有换行符或空格。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">char</span> cr, <span class="type">int</span> lines, <span class="type">int</span> width)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a character and two integer:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;rows, &amp;cols) != <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        display(ch, rows, cols);</span><br><span class="line">        <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter another character and two integer;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a new line to quit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">char</span> cr, <span class="type">int</span> lines, <span class="type">int</span> width)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> row, col;</span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">1</span>; row &lt;= lines; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (col  = <span class="number">1</span>; col &lt;= width; col++)</span><br><span class="line">            <span class="built_in">putchar</span>(cr);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while循环实现了丢弃scanf（）输入后面所有字符（包括换行符）的功能，为下一轮循环做准备。在if 语句中使用一个break语句，可以在scanf（）返回值不等于2时终止了程序，在后面也将丢弃后面输入字符的功能加上。</p><h1 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h1><p>在实际的运用过程中，用户的输入由于各种原因不一定会按照指令来做，输入和程序的期望不匹配经常发生，这会导致程序运行失败，我们需要学会提前预测错误并做出应对。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">while</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//处理n</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一小段就是处理非负数整数的循环，属于是输入的内容的范围错误。还有另外一种就是输入的类型错误的值，像是需要输入数字却输入字符。但是这个我们可以通过scanf（）的返回值来进行判断，因为scanf（）函数会规定读取值的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;n) == <span class="number">1</span></span><br><span class="line"><span class="comment">//这个语句只有在输入为整数时才为真。</span></span><br></pre></td></tr></table></figure><p>将这个改进和上面的一小段进行结合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//处理n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将程序进行简化，while的循环条件可以解释为读取一个非负整数。若是用户输入错误类型的值时，程序结束，但是可以让程序友好一点，提示用户输入正确的类型。在这种情况下，要处理有问题的输入，这里要明确输入实际上字符流，可以使用getchar（）逐字的读取输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">get_long</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> input;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;input) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; is not an integer.\nPlease enter an &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;integer value, such as 25, -178, or 3: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是要把一个int类型的值读入变量input中，若是读取失败，函数进入外层while循环体，然后内层循环逐字符的读取错误输入，这个函数丢弃该输入行的所有内容；或者可以丢弃下一个字符，提示用户再次输入，外层循环重复运行，直到用户成功输入，此时的返回值为1。</p><p>在我们输入整数之后，程序还需要检查输入的值是否有效，比如要求用户输入一个上限和下限来定义值的范围，对于这个功能来说，我们还需要程序去检查第一个值是否大于第二个值（一般假设第一个值是比较小的那个值），另外还需要检查这些值是否在允许的范围内，比如查询曾经的档案不会在1958年之前以及2014年之后一样，是会有一个范围。</p><p>假定程序中包含了stdbool.h头文件，如果当前的系统不允许使用 _Bool，把bool替换成int，把 true 换成1，把false 换成0即可。注意，若是输入无效该函数会返回true，所以将函数名为bad limits（）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">bad_limits</span><span class="params">(<span class="type">long</span> begin, <span class="type">long</span> end, <span class="type">long</span> low, <span class="type">long</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> not_good = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld isn&#x27;t smaller than %ld.\n&quot;</span>, begin, end);</span><br><span class="line">        not_good = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (begin &lt; low || end &lt; low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Values must be %ld or greater.\n&quot;</span>, low);</span><br><span class="line">        not_good = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (begin &gt; high || end &gt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Values must be %ld or less.\n&quot;</span>, high);</span><br><span class="line">        not_good = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> not_good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这些片段都是为了下面这个程序作铺垫，程序主要是计算特定范围内所有的整数的平方和，上下限是±10000000。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">get_long</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//验证输入是否是整数</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bad_limits</span><span class="params">(<span class="type">long</span> begin, <span class="type">long</span> end, <span class="type">long</span> low, <span class="type">long</span> high)</span>; <span class="comment">//验证上下限范围是否有效</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">sum_squares</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>; <span class="comment">//对a到b之间的数进行求平方和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> MIN = <span class="number">-10000000</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> MAX = +<span class="number">10000000</span>;</span><br><span class="line">    <span class="type">long</span> start;</span><br><span class="line">    <span class="type">long</span> stop;</span><br><span class="line">    <span class="type">double</span> answer;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program computes the sum of the squares of &quot;</span> <span class="string">&quot;integers in a range.\nThe lower bound should not &quot;</span> <span class="string">&quot;be less than -10000000 and\nThe upper bound &quot;</span> <span class="string">&quot;should not be more than +10000000.\nEnter the &quot;</span> <span class="string">&quot;limits (enter 0 for both limits to quit):\n&quot;</span> <span class="string">&quot;lower limit: &quot;</span>);</span><br><span class="line">    start = get_long();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;upper limit: &quot;</span>);</span><br><span class="line">    stop = get_long();</span><br><span class="line">    <span class="keyword">while</span> (start != <span class="number">0</span> || stop != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bad_limits(start, stop, MIN, MAX))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please try it again!&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            answer = sum_squares(start, stop);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The sum of the squares of the integers from %ld to %ld is %g.\n&quot;</span>, start, stop, answer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the limits(enter 0 for both limits to quit):\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;lower limits: &quot;</span>);</span><br><span class="line">        start = get_long();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;upper limits: &quot;</span>);</span><br><span class="line">        stop = get_long();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">get_long</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> input;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;input) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; is not an integer.\nPlease enter an integer value, such as 25, -178, or 3: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">bad_limits</span><span class="params">(<span class="type">long</span> begin, <span class="type">long</span> end, <span class="type">long</span> low, <span class="type">long</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> not_good = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld isn&#x27;t smaller than %ld.\n&quot;</span>, begin, end);</span><br><span class="line">        not_good = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (begin &lt; low || end &lt; low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Values must be %ld or greater.\n&quot;</span>, low);</span><br><span class="line">        not_good = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (begin &gt; high || end &gt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Values must be %ld or less.\n&quot;</span>, high);</span><br><span class="line">        not_good = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> not_good;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">sum_squares</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> total;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = a; i &lt;= b; i++)</span><br><span class="line">        total += (<span class="type">double</span>)i*(<span class="type">double</span>)i;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序的分析"><a href="#程序的分析" class="headerlink" title="程序的分析"></a>程序的分析</h2><p>虽然这个程序的核心部分是在 sum_square（）函数，但是输入验证部分比以往的都要复杂，先主要看程序的主要结构。这个程序遵循模块化的编程思想，使用独立函数来验证输入和管理显示。程序越大越需要模块化。</p><p>main（）函数管理程序流，为其他的函数委派任务。使用get_long（）获取值，while循环来处理值，bad_limits（）来检查获取的值是否在规定的范围之内，最后使用sum_squares（）函数来处理实际的运算。</p><h2 id="输入流和数字"><a href="#输入流和数字" class="headerlink" title="输入流和数字"></a>输入流和数字</h2><p>在编写处理错误输入的代码时，我们应该要清楚C语言是如何处理输入的。如下输入：</p><p>is 28 12.4</p><p>正常来看，这是一个由字符、整数和浮点数构成的字符串，但是对于C语言来说，其实这就是一个字节流。第一个字节是 i 的字母编码，第二个字节是 s 的字母编码，以此类推。若是我们使用get_long（）函数来处理这一行输入，由于第一个是非数字会导致整行输入都被抛弃。</p><p>虽然输入流由字符组成，但是也可以设置scanf（）把它们转换成数值。对于下面的输入：</p><p>42</p><p>在scanf（）中使用%c 转换说明，会存储在char类型的变量中；使用%s 转换说明，只会读取两个字符并存储在字符数组中；若是使用%d 转换说明，则是会存储在int类型的变量中；如果是 %f 的转换说明，并将其存储在float类型的变量里。简而言之，scanf（）可以使用转换说明限制可接受输入的字符类型，而getchar（）和%c 的scanf（）接受所有的字符。</p><h1 id="菜单浏览"><a href="#菜单浏览" class="headerlink" title="菜单浏览"></a>菜单浏览</h1><p>不少的程序都会把菜单作为用户界面的一部分，虽然会给使用带来方便的同时，也会给编程带来一定的难度。</p><p>假设有下面这样的一个例子：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202308091110883.png"></p><p>最理想的状态自然是根据用户选择的选项去完成任务，自然希望这个过程是顺利运行的，有两个目标：1.当用户遵循指令时顺利运行。2.当用户没有遵循指令时，程序也能顺利运行。当然，第二种情况实现的难度较大。</p><p>一般来说，应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标等，而不是我们的命令行模式。这两者的处理过程基本上是一样的：1.提供选项给用户。2.检查并执行用户的响应。3.保护程序不受误操作的影响。相较来说图形界面更容易限制控制输入。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>一个菜单程序具体来说需要执行那些任务呢，一般来说需要获取用户的响应，然后根据响应来选择需要执行的操作。此外，程序还需要提供返回菜单的选项。这个需求我们最好的是采用switch语句，用户的每个选择都是对应一个特定的case标签，还可以使用while语句实现重复访问菜单的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以写出以下的伪代码</span></span><br><span class="line">获取选项</span><br><span class="line">当选项不是‘q’时</span><br><span class="line">根据选项执行相应的程序</span><br><span class="line">获取下一个选项</span><br></pre></td></tr></table></figure><p>所以对应想要实现的功能来说，我们都可以先使用伪代码的形式来将框架给搭出来。</p><h2 id="顺利的程序执行"><a href="#顺利的程序执行" class="headerlink" title="顺利的程序执行"></a>顺利的程序执行</h2><p>当我们决定去实现这个程序的时候，就需要去考虑怎么让程序顺利运行（指的是无论程序是在正确输入还是错误输入时都可以顺利运行），那么我们需要做的就是在1.获取选项 时的代码筛选掉不合适的响应，只将正确的响应传给switch。这就说明需要为输入过程提供一个返回正确响应的函数。结合while循环和switch语句，可以简要的构建程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> <span class="title function_">get_choice</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="keyword">while</span> ((choice = get_choice()) != <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Buy low, sell high.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;\a&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                count();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Program error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">get_choice</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the letter of your choice:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a. advice                  b. bell\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c. count                   q. quit\n&quot;</span>);</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;a&#x27;</span> || ch &gt; <span class="string">&#x27;c&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please respond with a, b, c, or q.\n&quot;</span>);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，缓冲输入依旧会带来一些麻烦，程序会把用户每一次按下回车键产生的换行符视为错误响应。为了使得程序的界面更加流畅，这个函数应该跳过这些换行符。</p><p>解决这个问题有很多的方法，第一种就是自己编一个程序来替代getchar（）函数，读取第一个字符并丢弃剩余字符。优点在于可以将 类似 act 这样的输入视为简单的 a 。</p><p>简单的优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">get_choice</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the letter of your choice:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a. advice                  b. bell&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c. count                   q. quit&quot;</span>);</span><br><span class="line">    ch = get_first();</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;a&#x27;</span> || ch &gt; <span class="string">&#x27;c&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please respond with a, b, c, or q.\n&quot;</span>);</span><br><span class="line">        ch = get_first();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">get_first</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原函数中加入一个自我改编的函数可以使得整体程序的模块化更加明显， 当然在使用之前还是要在开头加上声明。</p><h2 id="混合字符和数字的输入"><a href="#混合字符和数字的输入" class="headerlink" title="混合字符和数字的输入"></a>混合字符和数字的输入</h2><p>在前面分析过混合字符和数值输入会产生一些问题，创建菜单也会有这样的问题。可以假设C 选项的count（）函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count how far? Enter an integer:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, i &lt;= n, i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是若是输入3作为响应，scanf（）函数会将3和换行符都留在输入队列里，在下一次调用get_choice（）将会导致get_first（）返回这个换行符，会导致错误的情况出现。有两种办法可以解决，一是重写get_first（），使得其返回下一个非空白字符而不仅仅是下一个字符，就能修复这个问题；还有另外一种方法，在count（）函数中清理换行符，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count how far? Enter an integer:\n&quot;</span>);</span><br><span class="line">    n = get_int();</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>, i &lt;= n, i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的改动主要是集中在get_int（）这个函数，主要是借鉴了8.7程序里的get_long（）的形式，将其中的long类型数据改换成int类型的数据。在完成这些修复之后，可以得到一个最终版的菜单程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> <span class="title function_">get_choice</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">get_first</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_int</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> choice;</span><br><span class="line">    <span class="keyword">while</span> ((choice = get_choice()) != <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Buy low, sell high.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                <span class="built_in">putchar</span>(<span class="string">&#x27;\a&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">                count();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Program error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">get_choice</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the letter of your choice:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a. advice                  b. bell\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c. count                   q. quit\n&quot;</span>);</span><br><span class="line">    ch = get_first();</span><br><span class="line">    <span class="keyword">while</span> ((ch &lt; <span class="string">&#x27;a&#x27;</span> || ch &gt; <span class="string">&#x27;c&#x27;</span>) &amp;&amp; ch != <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please respond with a, b, c, or q.\n&quot;</span>);</span><br><span class="line">        ch = get_first();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">get_first</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to count: &quot;</span>);</span><br><span class="line">    n = get_int();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_int</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input) != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; is not an integer.\nPlease enter an integre value such as 25, 178 or 3: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序对于最后一个问题的解决是在count（）函数中的末尾添加上清理换行符的一段代码。那么我们若是不在count中进行消除，而是在get_first（）函数中应当怎么改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">get_first</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to count: &quot;</span>);</span><br><span class="line">    n = get_int();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目的是为了在count（）中使用scanf（）时消除换行符的影响的另外一种方法。</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">get_first</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;&#x27; &amp;&amp; ch != &#x27;</span>\t<span class="number">&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">count</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to count: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实这两种方法都是可以的，在编程没有固定的公式，就像再完美的程序也是会有漏洞一样，当它出现的时候，我去将其补上即可。</span></span><br></pre></td></tr></table></figure><p>到此我们就完成了一个简单的菜单页面的开发，若是某一天需要用到，也可以在这个基础上进行完善和修补。这个实例的学习最重要的一点就是需要学到程序的模块化是有多么实用。</p><h1 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h1><p>C程序把输入作为传入的字节流。getchar（）函数把每个字符解释成字符编码，scanf（）函数以同样的方式看待输入，但是根据转换说明，它可以将字符输入转换成数值。许多操作系统都提供重定向，允许使用文件代替键盘输入，用文件代替显示器输出。</p><p>程序通常接受特殊形式的输入，在设计程序时需要考虑在输入时可能会犯的错误，在输入验证处理这些错误。对于一个小型程序，输入验证会是代码里最复杂的部分，处理这类问题有很多种方案。如果用户输入错误类型的信息，可以终止程序，也可以给用户提供机会重新输入。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>许多的程序使用getchar（）逐字符的去读取输入。通常使用缓冲输入，也就是当用户按下回车键后输入才被传送给程序，但是与此同时也传送了一个换行符，需要对这个换行符进行处理。</p><p>通过标准的I&#x2F;O包的函数，使用统一的方式来处理不同系统的不同文件形式，这是C语言的特性之一。getchar（）和scanf（）也属于这一行列。当检测到文件结尾时，这两个函数都会返回 EOF 。</p><p>在混合使用getchar（）和scanf（）的时候，在调用getchar（）之前，scanf（）会在输入的缓冲里留下一个换行符从而导致一些问题。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业实践-OPC初识</title>
      <link href="/2023/07/26/%E4%BC%81%E4%B8%9A%E5%AE%9E%E8%B7%B5-OPC%E5%88%9D%E8%AF%86/"/>
      <url>/2023/07/26/%E4%BC%81%E4%B8%9A%E5%AE%9E%E8%B7%B5-OPC%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>博主这个暑假因为校企联培项目跟随企业导师开始实习，主要的目标是需要我们做一个可以对故障进行报警和预测的web或者应用。</p><p>给我们发了一些资料，需要我们先了解OPC DA 协议、Rockwell控制器和西门子s7-1500和TIA博途软件等资料进行学习。会在这篇进行学习记录。</p><p>经过B站的短暂学习之后：</p><p><a href="https://www.bilibili.com/video/BV1564y1t7mZ?p=1&vd_source=8123557494c3afc5379c8969b7df4d5a">上位机通信之OPC底层原理-1_哔哩哔哩_bilibili</a></p><p>对于OPC和PLC有了一定的基本的了解，OPC创立的初衷是因为PLC设备的多样化导致驱动、通信协议的多样化，这样的情况下导致不同的设备协同出现了很大的问题，所以在几个自动化的巨头牵头下，成立了OPC基金会来对协议进行一个整合和管理，对于软件工程师来说，通过OPC软件就可以不用去了解具体的PLC硬件的通信协议，只需要对OPC变量进行操作即可，大大减少了开发软件的难度和时间。</p><p>OPC变量在软件层面反映出来的是那些，具体来说是 设备 -&gt; 组 -&gt; 变量；属于是节点式的结构，这些变量通过OPC软件（KEPserver，西门子，NI），对Modbus、AB、ABB、三菱、西门子和Codesys等PLC硬件进行控制。</p><p>主要是使用C#语言，我现在OPC服务器软件主要采用KEPserver，由于没有现场的PLC设备，所以我们现在主要采用虚拟PLC进行仿真去模拟出一个实际应用场景，主要用到是Modbus slave这款软件，其他像是TIA 博图软件等也是可以拿来使用的，剩下的我们需要通过自己写程序进行数据提取，那么就是用C#语言在VScode进行脚本的编写。</p><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p>所用软件：</p><p>PLC仿真软件：Modbus poll（主机；暂未使用）；Modbus slave（从机）</p><p>OPC服务器软件：KEPserver（KEPware出品）</p><p>编程软件：VS2022</p><p>Modbus相关的软件在官网就可以下载：</p><p><a href="https://www.modbustools.com/download.html">Download (modbustools.com)</a></p><p>在下载之后可以自己在百度寻找注册码进行注册用来延长30天的期限。</p><p>KEPserver：</p><p><a href="https://pan.baidu.com/s/1ts9_aAEeikCBWveix7320w">https://pan.baidu.com/s/1ts9_aAEeikCBWveix7320w</a></p><p>提取码：2431</p><p>至于VS的下载相信可以在各种平台找到许多，在此不再赘述了。</p><p>前期的工作和软件的安装已经基本完成了，下面就是要先尝试使用OPC服务器软件对PLC仿真进行数据读取。</p>]]></content>
      
      
      <categories>
          
          <category> 企业项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工业控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-文件权限</title>
      <link href="/2023/07/21/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
      <url>/2023/07/21/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>缺乏安全性的系统就不是完整的系统，系统里必须有一套能够保护文件遭非授权用户浏览和修改的机制。Linux沿用了Unix文件权限的办法，就是允许用户和组根据每个文件和目录的安全性设置来访问文件。</p><h1 id="Linux的安全性"><a href="#Linux的安全性" class="headerlink" title="Linux的安全性"></a>Linux的安全性</h1><p>Linux安全系统的核心是用户账户，每一个能进入Linux系统的用户都会被分配唯一的用户账户，这也是决定我们对各种对象访问权限的关键因素。用户权限是通过创建用户时分配的用户ID来跟踪的，Linux系统使用特定的文件和工具来跟踪和管理用户账户。在学习文件权限之前，需要先知道Linux怎么处理用户账户。</p><h2 id="x2F-etc-x2F-passwd-文件"><a href="#x2F-etc-x2F-passwd-文件" class="headerlink" title="&#x2F;etc&#x2F;passwd 文件"></a>&#x2F;etc&#x2F;passwd 文件</h2><p>Linux系统使用一个专门的文件将用户的登录名匹配到对应的UID上，这个文件就是&#x2F;etc&#x2F;passwd，主要包含了用户有关的信息，下面是对这个文件的查看：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307311430625.png"></p><p>root用户账户是Linux系统的管理员，固定分配的UID是0，Linux系统会给各种各样的功能创建不同的用户账户，但是这些账户不是真的用户，这些账户叫做系统账户，是在系统上运行的各种服务进程访问资源的特殊账户，所有运行在后台的服务都要用一个系统用户账户登录到Linux系统上。</p><p>一般来说，Linux系统会为账户预留了500的UID值，有些服务甚至需要特定的UID才能正常工作，为普通用户创建账户时，大多数Linux会从500开始，将第一个可用的UID分配给这个账户。</p><p>在&#x2F;etc&#x2F;passwd文件里还有许多的用户登录名和UID之外的信息：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307311431046.png"></p><p>&#x2F;etc&#x2F;passwd文件里的密码字段都被设置成了x，这并不是说所有的用户账户都使用一样的密码，在早期的Linux里，文件中包含加密的用户的密码，但是随着技术的发展，有些人想着破解密码，所以开发者需要考虑这个问题了。</p><p>在现在的系统中，大部分的</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-控制语句 分支和跳转</title>
      <link href="/2023/07/18/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%20%E5%88%86%E6%94%AF%E5%92%8C%E8%B7%B3%E8%BD%AC/"/>
      <url>/2023/07/18/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%20%E5%88%86%E6%94%AF%E5%92%8C%E8%B7%B3%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p>在经过了循环的学习之后，对C语言的熟悉更进一步了，为了更好的使用C程序来解决复杂的问题，就需要一些方法来控制和组织程序了。除了循环之外，我们还有分支结构（if 和 switch）让程序根据测试条件去执行相应的行为。</p><h1 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h1><p>先从一个简单的例子来进行学习if 语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> FREEZING = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> temperature;</span><br><span class="line">    <span class="type">int</span> cold_days = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> all_days = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the list of daily low temperature.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Use Celsius, and enter q to quit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;temperature) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        all_days++;</span><br><span class="line">        <span class="keyword">if</span> (temperature &lt; FREEZING)</span><br><span class="line">            cold_days++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (all_days != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d days total: % .1f%% were below freezing.\n&quot;</span>, all_days, <span class="number">100.0</span> * (<span class="type">float</span>)cold_days / all_days);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (all_days = <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data entered!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序可以实现的是读取一列数据，统计总天数和最低温度在0摄氏度以下的天数占总天数的百分比。</p><p>实现效果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307190933451.png"></p><p>其中while循环的测试条件是之前学习过的利用scanf（）的返回值来结束循环，因为temperature 的类型是float ，所以可以接受小数。</p><p>if 语句被称为分支语句或选择语句，因为它像一个交叉点，要在两条分支里选择一条执行，通用格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">statement;</span><br></pre></td></tr></table></figure><p>如果对expression 为真，则执行 statement 的内容，if 语句的结构和while 语句的结构很相似，主要的区别是若是条件满足，if 语句只能执行一次，而while 语句可以执行很多次。statement 部分可以是一条简单语句或是用花括号的复合语句。</p><h1 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if else 语句"></a>if else 语句</h1><p>简单形式的if 语句可以让程序选择执行一条语句，或者跳过这条语句，除了这个形式C 还提供了if else 形式，可以在两条语句中做出选择。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (all_days != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d days total: % .1f%% were below freezing.\n&quot;</span>, all_days, <span class="number">100.0</span> * (<span class="type">float</span>)cold_days / all_days);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (all_days = <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data entered!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以修改为以下形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (all_days != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d days total: % .1f%% were below freezing.\n&quot;</span>, all_days, <span class="number">100.0</span> * (<span class="type">float</span>)cold_days / all_days);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data entered!\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>这就将两个if 语句合并成了一个 if else 语句了。</p><p>通用格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expression)</span><br><span class="line">    statement1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">statement2;</span><br></pre></td></tr></table></figure><p><strong>Tip：如果要在if 和 else 之间执行多条语句，必须使用花括号把这些语句合成一个块变成复合语句，否则容易出现语法错误。</strong></p><h2 id="getchar（）和putchar（）"><a href="#getchar（）和putchar（）" class="headerlink" title="getchar（）和putchar（）"></a>getchar（）和putchar（）</h2><p>到目前为止，大部分的程序都需要输入数值，那么输入字符除了使用scanf（）和printf（）根据%c 转换说明读写字符，还有没有别的方法。</p><p>在C语言中有字符输入&#x2F;输出函数：getchar（）和putchar（）。</p><p>getchar（）函数不带任何参数，它从输入队列中返回下一个字符。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = getchar();</span><br><span class="line"><span class="comment">//效果与下面语句一样</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure><p>而putchar（）函数是打印它的参数</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="comment">//效果与下面语句一样</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure><p>由于这些函数只处理字符，所以他们比printf（）和scanf（）函数更快更简洁，而且这两个函数是不需要转换说明的，因为它们只需要处理字符，通常定义在stdio.h的头文件里。</p><p>下面我们在具体的程序中去使用这两个函数</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&#x27; &#x27;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == SPACE)</span><br><span class="line">            <span class="built_in">putchar</span>(ch);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(ch + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序就是将每个非空格都替换成ASCII 表中的下一个字符，空格保持不变的效果。</p><p>这个程序总体来说还是有可以改进的地方，例如可以将while循环的测试条件中加入获取字符这一项可以节省一些步骤，也能使得每个行为更加的清晰。但是在细节方面也需要注意，像是 (ch &#x3D; getchar()) 的两个圆括号就不能遗忘，还有逻辑符号的先后顺序等。</p><h2 id="ctype-h-系列的字符函数"><a href="#ctype-h-系列的字符函数" class="headerlink" title="ctype.h 系列的字符函数"></a>ctype.h 系列的字符函数</h2><p>在上面这个程序也还是有漏洞，因为它只是针对字母和非字母字符，但是非字母字符中也有许多的种类，像是标点符号等就显得没有这么方便转换，而且转换之后也不是我们想要的效果。其实C 语言有一系列专门处理字符的函数，ctype.h 的头文件里包含了这些函数的原型，利用这些函数可以对上面的程序进行优化。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isalpha</span>(ch))</span><br><span class="line">            <span class="built_in">putchar</span>(ch + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，isalpha（）函数是拿来判断是否是字符的，非字符为0，小写为2，大写为1。这一段改进之后的程序相较于之前就好了很多，很多行为也更加的清晰。</p><p>在ctype.h 这个头文件中还有许多针对字符的测试函数：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307191411410.png"></p><h2 id="多重选择-else-if"><a href="#多重选择-else-if" class="headerlink" title="多重选择 else if"></a>多重选择 else if</h2><p>在现实生活中一般会出现不止一种选择，在程序中我们可以使用else if 来应对这种情况，来扩展if else 结构中不足的部分，最简单的一个就是阶梯电费的收费，这就是一个多重选择模型，因为它会在不同的用电区间里实行差额电价。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307191434154.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATE1 0.13230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATE2 0.15040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATE3 0.30025</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RATE4 0.34025</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BREAK1 360.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BREAK2 468.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BREAK3 720.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE1 (RATE1 * BREAK1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE2 (BASE1 + ((BREAK2 - BREAK1) * RATE2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE3 (BASE1 + BASE2 + ((BREAK3 - BREAK2) * RATE3))</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> kwh;</span><br><span class="line">    <span class="type">double</span> bill;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the kwh used.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;kwh);</span><br><span class="line">    <span class="keyword">if</span> (kwh &lt;= BREAK1)</span><br><span class="line">        bill = kwh * RATE1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kwh &lt;= BREAK2)</span><br><span class="line">        bill = BASE1 + ((kwh - BREAK1) * RATE2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kwh &lt;= BREAK3)</span><br><span class="line">        bill = BASE2 + ((kwh - BREAK2) * RATE3);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bill = BASE3 + ((kwh - BREAK3) * RATE4);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The charge for %.lf kwh is $%1.2f.\n&quot;</span>, kwh, bill);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序就完整的把阶梯电费的功能给实现出来了，若是需要修改，我们仅仅需要在符号常量更改费率和费率临界点即可。</p><p>实际上，else if 是上面 if else 语句的变式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (kwh &lt;= BREAK1)</span><br><span class="line">        bill = kwh * RATE1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kwh &lt;= BREAK2)</span><br><span class="line">        bill = BASE1 + ((kwh - BREAK1) * RATE2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kwh &lt;= BREAK3)</span><br><span class="line">        bill = BASE2 + ((kwh - BREAK2) * RATE3);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bill = BASE3 + ((kwh - BREAK3) * RATE4);</span><br><span class="line"><span class="comment">//实际效果等同于下面</span></span><br><span class="line"><span class="keyword">if</span> (kwh &lt;= BREAK1)</span><br><span class="line">    bill = kwh * RATE1;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">if</span> (kwh &lt;= BREAK2)</span><br><span class="line">        bill = BASE1 + ((kwh - BREAK1) * RATE2);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">if</span> (kwh &lt;= BREAK3)</span><br><span class="line">        bill = BASE2 + ((kwh - BREAK2) * RATE3);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bill = BASE3 + ((kwh - BREAK3) * RATE4);</span><br></pre></td></tr></table></figure><p>上面这两种形式是完全等价的，效果也是完全一样的，实际就是一种嵌套语句。切记这种形式的最后一定是单独的一个else ，但是也不是能一直嵌套的，在C99标准中，最少支持127层嵌套。</p><h2 id="else-与-if-配对"><a href="#else-与-if-配对" class="headerlink" title="else 与 if 配对"></a>else 与 if 配对</h2><p>若是在一个程序中有许多的if 和 else ，编译器怎么知道if 对应那个else 呢。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">12</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You&#x27;re close!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorry, you lose a turn!\n&quot;</span>);</span><br><span class="line"><span class="comment">//这只是其中一种情况</span></span><br><span class="line"><span class="keyword">if</span> (number &gt; <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt; <span class="number">12</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You&#x27;re close!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorry,you lose a turn!\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>具体匹配规则：如果没有花括号，else 会与离它最近的if 匹配，除非最近的if 被花括号括起来了，像是实例中的第二部分一样。</p><h2 id="多层嵌套的if-语句"><a href="#多层嵌套的if-语句" class="headerlink" title="多层嵌套的if 语句"></a>多层嵌套的if 语句</h2><p>上面我们介绍的 if else 序列是嵌套 if 的一种形式，从一系列的选项中选择一个执行，在选择一个特定选项之后又引出其他选择，又可以使用另外一个选择。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> div;</span><br><span class="line">    <span class="type">bool</span> isPrime;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer for analysis; &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter q to quit!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lu&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (div = <span class="number">2</span>, isPrime = <span class="literal">true</span>; (div * div) &lt;= num; div++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num % div) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((div * div) != num)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%lu is divisible by %lu and %lu.\n&quot;</span>, num, div, num / div);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu is divisible by %lu.\n&quot;</span>, num, div);</span><br><span class="line">                isPrime = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isPrime)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lu is prime.\n&quot;</span>, num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter another integer for analysis; &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter q to quit.\n&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这是一个输入一个数字，判断是否是一个素数，若不是则找出其约数对并显示的程序。</p><p>小结：</p><p>上面主要学习了使用if 语句进行选择，关键字：if else 。</p><p>一般来说，if else 所组成的语句总共有三种形式：</p><p>形式1：</p><p>if （expression）</p><p>​statement</p><p>形式2：</p><p>if（expression）</p><p>​statement1</p><p>else</p><p>​statement2</p><p>形式3：</p><p>if （expression1）</p><p>​statement1</p><p>else if （expression2）</p><p>​statement2</p><p>else</p><p>​statement3</p><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>经过上面的学习，对于if 语句和 while 语句通常使用关系表达式作为测试条件比较熟练了。 接下来学习逻辑运算符的使用。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERIOD <span class="string">&#x27;.&#x27;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> charcount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != PERIOD)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;&quot;&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">charcount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;There are %d non-quote characters.\n&quot;</span>,</span><br><span class="line">charcount);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是计算输入的一行句子中除了单双引号以外其他字符的数量，且使用句号（.）作为句子结尾。</p><p>这段程序中最重要的就是if 语句的测试条件中使用了逻辑与运算符&amp;&amp;，这句话翻译成文字就是测试的字符不是双引号且不是单引号，那么字符数增加1。逻辑运算符两侧均为真，整个表达式才为真，但是逻辑运算符的优先级比关系运算符低，所以可以不用加圆括号。（最好加上！）</p><p>三种逻辑运算符：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307201618399.png"></p><p>剩下的这些就是逻辑的基本运算，难度较低不再赘述。</p><h2 id="iso646-h头文件（备选逻辑运算符）"><a href="#iso646-h头文件（备选逻辑运算符）" class="headerlink" title="iso646.h头文件（备选逻辑运算符）"></a>iso646.h头文件（备选逻辑运算符）</h2><p>一般来说，C 语言是用美式键盘开发的语言，但是世界各地的键盘不尽相同，因此在C99标准中新增了可以替代逻辑运算符的拼写，这些存在于 iso646.h头文件里，在这里面，and 替代 &amp;&amp;、or 替代||、not 替代!</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;&quot;&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">charcount++;</span><br><span class="line"><span class="comment">//可以改写成以下的形式</span></span><br><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;&quot;&#x27;</span> and ch != <span class="string">&#x27;\&#x27;&#x27;</span>)</span><br><span class="line">charcount++;</span><br></pre></td></tr></table></figure><p>但是为什么不直接使用对应的拼写呢，这是由于C 语言一直要坚持保持较少的关键字。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307210857211.png"></p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>在这几个逻辑运算符中，! 运算符的优先级很高，比乘法运算符的还要高，和递增运算符的优先级相同，只比圆括号的优先级低。&amp;&amp;运算符的优先级比 || 运算符要高，但是两者都比关系运算符要低，比赋值运算符要高。</p><p><strong>Tip：在实际应用中，还是可以更多的使用圆括号，这样即使忘记了运算符的优先级，表达式的含义也会非常的清楚。</strong></p><h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>除了两个运算符共同使用一个运算对象的情况外，C 语言一般不保证对复杂表达式的那一部分进行求值，但是逻辑运算符是其中的例外，C 语言保证逻辑表达式的求值顺序是从左往右，&amp;&amp; 和 || 都是序列点，从一个运算对象到下一个运算对象，所有的副作用都会产生效果，而且C 一旦发现某一个元素使得表达式无效，会立即停止求值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((c = getchar()) != <span class="string">&#x27; &#x27;</span> &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">//所以这句话可以完美执行，不会导致c在还没赋值之前就和\n进行比较。</span></span><br></pre></td></tr></table></figure><p>小结：逻辑运算符的运算对象一般是关系表达式，！运算符只需要一个运算对象，其他两个都是需要两个运算对象，左右各一个。求值顺序记住是从左往右即可！</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><p>&amp;&amp;运算符可用于测试范围。假设要测试score是否在90-100之间，可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(range &gt;= <span class="number">90</span> &amp;&amp; range &lt;= <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good show!\n&quot;</span>);</span><br><span class="line"><span class="comment">//记住不要模仿数学上的写法变成</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">90</span> &lt;= range &lt;= <span class="number">100</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good show!\n&quot;</span>); <span class="comment">//不好的形式</span></span><br></pre></td></tr></table></figure><p>若是按照第二种形式来写代码，会出现语义错误，因为 &lt;&#x3D; 运算符的求值顺序是从左往右，所以编译器会将其解释成((90 &lt;&#x3D; range) &lt;&#x3D; 100)，这样就不是我们的本意了，因此在范围测试中都使用 &amp;&amp; 。</p><p>一般的使用中都是集中在判断一个字符是否是一个小写字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s a lowercase character.\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是这种方法对ASCII码的字符比较有效果，若是编码系统是EBCDIC就没用了，对应的可移植方法就是使用ctype.h 中的 islower（）函数。因为无论是那种编码系统，islower （）函数都能正常运行。</p><h1 id="统计单词的程序"><a href="#统计单词的程序" class="headerlink" title="统计单词的程序"></a>统计单词的程序</h1><p>经过上面的学习之后，我们可以开始使用所学来编写一个统计单词数量的程序。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STOP <span class="string">&#x27;|&#x27;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> prev;</span><br><span class="line">    <span class="type">long</span> n_chars = <span class="number">0L</span>;</span><br><span class="line">    <span class="type">int</span> n_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n_words = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> inword = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please Enter text to be analyzed(| to terminate):\n&quot;</span>);</span><br><span class="line">    prev = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != STOP)</span><br><span class="line">    &#123;</span><br><span class="line">        n_chars++;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            n_lines++;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isspace</span>(c) &amp;&amp; !inword)</span><br><span class="line">        &#123;</span><br><span class="line">            inword = <span class="literal">true</span>;</span><br><span class="line">            n_words++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isspace</span>(c) &amp;&amp; inword)</span><br><span class="line">            inword = <span class="literal">false</span>;</span><br><span class="line">        prev = c;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (prev != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">p_lines = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;characters = %ld, words = %d, lines = %d, &quot;</span>,</span><br><span class="line">n_chars, n_words, n_lines);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;partial lines = %d\n&quot;</span>, p_lines);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这其中，!inword 和 inword &#x3D;&#x3D; false 等价。上面的整个测试条件比单独判断每个空白字符的可读性要高许多。若是c 不是空白字符，且如果c 不在单词里，那么一定是一个单词的开头，所以单词数要加1。等读到下一个空白字符时，inword 又会被置成false，但是若是单词中间有多个空格时，程序可能会出现错误，在后面的学习中会说明如何解决。</p><h1 id="条件运算符：？："><a href="#条件运算符：？：" class="headerlink" title="条件运算符：？："></a>条件运算符：？：</h1><p>C 语言提供条件表达式作为表达if else 语句的一种便捷方式，那么怎么使用这个条件表达式呢，这个运算符分为两个部分，需要三个运算对象，这是C 语言中唯一一个三元运算符。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = (y &lt; <span class="number">0</span>) ? -y: y;</span><br><span class="line"><span class="comment">//这行代码的意思就是当y &lt; 0时，x = -y，反之x = y。</span></span><br><span class="line"><span class="comment">//转换成if else的形式如下：</span></span><br><span class="line"><span class="keyword">if</span> (y &lt; <span class="number">0</span>)</span><br><span class="line">    x = -y;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x = y;</span><br><span class="line"><span class="comment">//相较于if else的形式简单了不少。</span></span><br></pre></td></tr></table></figure><p>条件表达式的通用形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression1 ？expression2 ：expression3</span><br><span class="line"><span class="comment">//最简单的例子</span></span><br><span class="line">max = (a &gt; b) ? a : b;</span><br><span class="line"><span class="comment">//把两个值中的最大值赋给变量。</span></span><br></pre></td></tr></table></figure><p>其实条件运算符能完成的事情都可以通过if else语句完成。但是使用条件运算符能使得代码更加的简洁。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COVERAGE 350;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sq_feet;</span><br><span class="line">    <span class="type">int</span> cans;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter number of square feet to be painted:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sq_feet) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cans = sq_feet/COVERAGE;</span><br><span class="line">        cans += ((sq_feet % COVERAGE == <span class="number">0</span>)) ? <span class="number">0</span> :<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;You need %d%s of paint.\n&quot;</span>, cans, cans ==<span class="number">1</span> ? <span class="string">&quot;can&quot;</span> : <span class="string">&quot;cans&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter next value(q to quit):\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序用于计算刷给定面积的墙面需要多少桶油漆，其中主要用到的是取整和取余的方法。还有一个是根据单复数来打印是can还是cans。</p><h1 id="循环辅助：continue-和-break"><a href="#循环辅助：continue-和-break" class="headerlink" title="循环辅助：continue 和 break"></a>循环辅助：continue 和 break</h1><p>一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中<br>的所有语句。continue 和break语句可以根据循环体中的测试结果来忽略一部<br>分循环内容，甚至结束循环。</p><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>三种循环都可以使用continue语句。执行到该语句，会跳过本次迭代的剩余部分，并开始下一轮迭代。若是continue语句在嵌套循环内，则只会影响包含该语句的内层循环。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> MIN = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> MAX = <span class="number">100.0f</span>;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">float</span> total = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> min = MAX;</span><br><span class="line">    <span class="type">float</span> max = MIN;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter the first score(q to quit):&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;score) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (score &lt; MIN || score &gt; MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%0.1f is an invalid value.Try again:&quot;</span>, score);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Accepting %0.1f:\n&quot;</span>, score);</span><br><span class="line">        min = (score &lt; min) ? score : min;</span><br><span class="line">        max = (score &gt; max) ? score : max;</span><br><span class="line">        total += score;</span><br><span class="line">        n++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the next score(q to quit):&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Average of %d scores is %0.1f.\n&quot;</span>, n, total/n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Low = %0.1f, high = %0.1f\n&quot;</span>, min, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No vaild scores were entered.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，while 语句持续读取输入，直至用户输入非数值数据，循环中的if 语句会筛选出无效的数据。continue 语句让程序跳过了处理有效数字的部分使得程序进入了下一个循环。</p><p>其实我们有两种方法可以不去使用continue，一是省略continue，把剩余部分放在一个else块中；而另外一种就是换一个格式来代替：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &lt; MIN || score &gt; MAX)</span><br><span class="line"><span class="comment">//可以换成以下的形式</span></span><br><span class="line"><span class="keyword">if</span> (score &gt;= MIN &amp;&amp; score &lt;= MAX)</span><br></pre></td></tr></table></figure><p>但是在这种情况下，使用continue 的好处就是可以减少语句组的一级缩进。当语句很长或者嵌套较多时，简洁的格式提高了代码的可读性。</p><p>continue 有时候还可以作为占位符来使用，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">//可以转换成另外一种形式</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//在加入continue之后使得可读性更高了</span></span><br></pre></td></tr></table></figure><p>若是使用了continue 使得代码更加复杂了就不要使用continue 了，一般来说，把if 的测试条件反过来就可以避免使用continue了。上面是介绍了continue 语句让程序跳过循环的余下部分，那么从何处继续开始循环呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个循环是读取10个字符(除换行符外)，并显示它们。</span></span><br><span class="line"><span class="comment">//对于for循环来说，执行continue后的下一个行为是对更新表达式求值。</span></span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">10</span>; count++)</span><br><span class="line">&#123;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于在continue之后，count进行了递增，所以和上一个例子不同，for循环中会显示换行符，仅仅只是读取10字符。</span></span><br></pre></td></tr></table></figure><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>程序执行到循环的break语句时，会终止包含它的循环，并继续执行下一阶段。若是break语句位于嵌套循环内，它只会影响当前的循环。</p><p>下图生动的说明了continue和break语句的区别：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307251049651.png"></p><p>break 语句还可以用于因其他原因退出循环的情况。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> length, width;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the length of the rectangle:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;length) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;length = %0.2f:\n&quot;</span>, length);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the width.\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;width) != <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Width = %0.2f:\n&quot;</span>, width);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Area = %0.2f&quot;</span>, length * width);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter the length of the rectangle:\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是根据输入的长和宽来计算面积的一个程序，若是输入一个非数字则终止循环。</p><p>但其实可以将循环中的测试表达式进行简洁，但是为了更好的显示用户即时输入的值，还是使用上面的更加方便。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;length) == <span class="number">1</span>)</span><br><span class="line"><span class="comment">//可以更改成下面的形式</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%f %f&quot;</span>, &amp;length, &amp;width) == <span class="number">2</span>)</span><br><span class="line"><span class="comment">//这样可以直接进入我们操作的部分，但是不会进行输入值的显示</span></span><br></pre></td></tr></table></figure><p>和continue 一样，如果使用了break 之后代码反而复杂了，就不要使用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以换成更好的一段，使用break就没有这么好了。</span></span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">    <span class="built_in">putchar</span>(ch);</span><br></pre></td></tr></table></figure><p>break 语句对于接下来的switch 语句非常重要，在for循环中的break 和 continue 完全不一样，执行break 语句会直接执行循环后面的第一条语句，连更新部分都会跳过。嵌套循环的break 只会跳出当前循环，若是要跳出外层循环还要一个break。</p><h1 id="多重选择：switch-和-break"><a href="#多重选择：switch-和-break" class="headerlink" title="多重选择：switch 和 break"></a>多重选择：switch 和 break</h1><p>我们在使用条件运算符和if else 语句时很容易编写二选一，但是有时候程序需要在多个选项中进行选择。虽然也可以使用 if else if …… else来完成，但是大多数的情况下使用switch 语句更加方便。下面的实例可以展示怎么使用switch 语句，输入一个字母，然后打印和该字母相同的动物名称。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Give me a letter of the alphabet, and I will give&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;an animal name\n begining with that letter.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type in a letter; type # to end my act.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == ch)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">islower</span>(ch))</span><br><span class="line">            <span class="keyword">switch</span>(ch)</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">case</span><span class="number">&#x27;</span>a<span class="number">&#x27;</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;argali, a wild sheep of Asia.\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span><span class="number">&#x27;b</span><span class="number">&#x27;</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;babirusa, a wild pig of Malay.\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span><span class="number">&#x27;</span>c<span class="number">&#x27;</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;coati, racoonlike mammal.\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span><span class="number">&#x27;</span>d<span class="number">&#x27;</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;desman, aquatic, molelike, critter.\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;echidna, the spiny anteater\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fisher, brownish marten\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s a stumper!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I only need lowercase letter.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please type in a letter; type # to end my act.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序就是展示了switch的用法，但是长度有限，我们的字母只能展示到 f 后面的字符依次类推。</p><p>使用效果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307280953210.png"></p><p>下面来分析一下switch的具体原理。</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>主要是对跟在关键字 switch 后圆括号中的表达式求值，然后对标签列表进行扫描，直到发现一个匹配值为止，然后程序会跳到所在行，若是没有匹配的标签，有default 标签行，就跳转至该行否则就执行switch 之后的语句。</p><p>break 语句在其中主要起到什么作用呢，它会让程序离开switch语句，跳转至switch语句后面的下一条语句。若是没有break，就会从匹配标签开始执行一直到末尾。</p><p><strong>Tip：break 语句可以用于循环和switch 语句中，但是continue 只能用于循环，若是switch 语句在一个循环中，continue 便可以作为switch 语句的一部分，像在其他循环中一样，continue 让程序跳出剩余部分。</strong></p><p>switch 语句的圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case 标签必须是<strong>整数类型（包括char 类型）的常量，或者是常量表达式</strong>。切记不能使用变量作为case 标签，switch结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">            语句</span><br><span class="line">        <span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">            语句</span><br><span class="line">        <span class="keyword">default</span>：</span><br><span class="line">            语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仅读每行首字符"><a href="#仅读每行首字符" class="headerlink" title="仅读每行首字符"></a>仅读每行首字符</h2><p>在上面的程序运行过程中，还有一个独到的地方，当我们输入多个字母时，只会处理第一个字符，这类丢弃一行中其他字符的行为，会经常出现在响应单字符的交互程序中，实现的代码也比较的简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>循环从输入中读取字符包括按下Enter键所产生的换行符。**但是函数的返回值并没有赋值给ch，由于最后丢弃的是换行符，所以下一个读取的是下一行的首字母，在最外层的循环中，getchar（）的值被赋值给了ch。</p><p>若是用户一开始就按下Enter键的话，那么程序第一个读到的就是换行符，但是这就不符合接下来输入字母的要求了。可以使用一段代码来解决：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == ch)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这样就成功避免了用户在一开始就输入换行符的情况。</p><h2 id="多重标签"><a href="#多重标签" class="headerlink" title="多重标签"></a>多重标签</h2><p>在上面的程序中，都是一个标签对应一个语句或是一种情况，那若是我们需要多个标签都是对应同一个语句又该如何去做呢。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> a_ct, e_ct, i_ct, o_ct, u_ct;</span><br><span class="line">    a_ct = e_ct = i_ct = o_ct = u_ct = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter some text; enter # to quit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>a<span class="number">&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:</span><br><span class="line">                a_ct++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;e&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;E&#x27;</span>:</span><br><span class="line">                e_ct++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>i<span class="number">&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>I<span class="number">&#x27;</span>:</span><br><span class="line">                i_ct++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>o<span class="number">&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>O<span class="number">&#x27;</span>:</span><br><span class="line">                o_ct++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;u</span><span class="number">&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;U</span><span class="number">&#x27;</span>:</span><br><span class="line">                u_ct++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number of vowels:    A E I O U\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                     %4d %4d %4d %4d %4d\n&quot;</span>, a_ct, e_ct, i_ct, o_ct, u_ct);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序就是多个标签对应同一个输出，不过这只是看上去如此，前面说过若是没有break，那么会继续往下执行，所以看起来像是两个标签对应一个输出，底层的逻辑从来没变过。但是如果使用 ctype.h 头文件中的 toupper（）函数就可以避免这个多重选择，在测试之前就可以把小写字母转换成大写字母。</p><p>小结：</p><p>关键字：switch</p><p>程序根据测试表达式的值跳转至相应的case标签处。然后执行其中的语句，除非执行到了break 语句才会进行重定向。**尤为重要的是测试表达式和case 标签都必须是整数值，标签必须是常量或者是常量组成的表达式，若是没有标签进行匹配，则转到default 的语句（如果有），否则就是直接执行switch 语句后面的语句。</p><h2 id="switch-和if-else"><a href="#switch-和if-else" class="headerlink" title="switch 和if else"></a>switch 和if else</h2><p>对于什么时候使用 switch 和 if else ，经常会有疑惑，但是数据是浮点型的话就无法使用switch了，根据变量在某一个范围内决定程序流，使用switch也是不方便的，这样的情况还是采用 if 来的更好。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (integer &lt; <span class="number">1000</span> &amp;&amp; integer &gt; <span class="number">2</span>)</span><br><span class="line"><span class="comment">//这个若是用switch，需要将每个整数都设置case标签</span></span><br></pre></td></tr></table></figure><p>但是使用switch 也有好处，程序通常会运行的快一点，生成的代码少一点。</p><h1 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h1><p>早期版本的BASIC语言依赖的goto语句，在C 语言中依然可以使用，但是和前期的语言有所不同，没有goto 语句的C程序也能良好运行，而且goto 语句容易被滥用。一般来说，goto 语句通常不需要它。</p><p>goto语句有两部分：goto 和标签名；标签命名遵循变量命名规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> part；</span><br><span class="line">part: <span class="built_in">printf</span>(<span class="string">&quot;Refined analysis:\n&quot;</span>);</span><br><span class="line"><span class="comment">//要让这条语句正常工作，还要在后面加入part的内容，标签名后面跟上冒号</span></span><br></pre></td></tr></table></figure><h2 id="避免使用goto语句"><a href="#避免使用goto语句" class="headerlink" title="避免使用goto语句"></a>避免使用goto语句</h2><p>在原则上，根本不需要在C程序中使用goto语句，先来看一下goto语句的常见情况，然后再来介绍C 语言的解决方案：</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">goto</span> a;</span><br><span class="line"><span class="keyword">goto</span> b;</span><br><span class="line">    a: cost = cost * <span class="number">1.5</span>;</span><br><span class="line">    flag = <span class="number">2</span>;</span><br><span class="line">    b: bill = cost * flag;</span><br><span class="line"><span class="comment">//若是要转化成C语言的形式如下</span></span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">12</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cost = cost * <span class="number">1.5</span>;</span><br><span class="line">    flag = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">bill = cost * flag;</span><br></pre></td></tr></table></figure><p>上面主要演示了使用goto语句和C 语言之间的转换。</p><p>二选一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ibex &gt; <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">goto</span> a;</span><br><span class="line">sheds = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">goto</span> b;</span><br><span class="line">a: sheds = <span class="number">3</span>;</span><br><span class="line">b: help = <span class="number">2</span> * sheds;</span><br><span class="line"><span class="comment">//下面是转换到C语言</span></span><br><span class="line"><span class="keyword">if</span> (ibex &gt; <span class="number">14</span>)</span><br><span class="line">    sheds = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    sheds = <span class="number">2</span>;</span><br><span class="line">    help = <span class="number">2</span> * sheds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，新版的BASIC语言已经把else纳入新的语法中了。</p><p>创建不确定的循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">readin: <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line"><span class="keyword">if</span> (score &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> stage2;</span><br><span class="line">lots of statements</span><br><span class="line"><span class="keyword">goto</span> readin;</span><br><span class="line">stage2: more stuff;</span><br><span class="line"><span class="comment">//上面的程序可以使用while语句来替代</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score);</span><br><span class="line"><span class="keyword">while</span> (score &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    lots of statement;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score)</span><br><span class="line">&#125;</span><br><span class="line">more stuff;</span><br></pre></td></tr></table></figure><p>上面就演示了不确定循环在goto 语句和C 语言的while循环之间的转换。</p><p>跳出循环，C语言使用break语句，实际上，break和continue是goto的特殊形式，使用它们的好处是其名称已经表明了它们的用法，这些语句不用标签，不会有标签放错位置的烦恼。</p><p>在C 语言中可以接受一种goto的用法，那就是出现问题时，从一组嵌套循环中跳出（一个break只能跳出当前循环）。</p><p>小结：程序跳转</p><p>关键字：continue、break、goto</p><p>注解：这3种语句都能使程序流从程序的一处跳转到另外一处。</p><p>break语句：</p><p>所有的循环和switch语句都可以使用break语句。</p><p>continue语句：</p><p>所有的循环都可以使用continue语句，但是switch语句不行。对于while和for循环，程序执行到continue语句就会开始进入下一轮迭代，对于do while循环，对出口条件求值后，看情况进入循环。</p><p>goto语句：</p><p>goto语句使得程序控制跳转到相对应的标签语句。冒号用于分隔标签和标签语句。标签语句可以出现在goto前面或者后面（或许就是由于这样的自由度，所以在C 语言里不受待见。）</p><h1 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h1><p>智能的一个方面就是根据情况做出反应，所以选择语句是开发具有智能行为程序的基础，C 语言可以if 、if else和switch语句，以及条件运算符（？：）可以实现智能选择。</p><p>if 和 if  else 语句使用测试条件来判断执行那些语句，所有的非零值都会被视为 true，零被视为 false，测试一般涉及关系表达式、逻辑表达式。</p><p>我们需要记住一个通用的原则，如果需要测试两个条件，应该使用逻辑运算符把两个测试表达式组合起来，而不是直接合并。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; x &lt; z)<span class="comment">//这是错误的写法</span></span><br><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;q&#x27;</span> &amp;&amp; != <span class="string">&#x27;Q&#x27;</span>)<span class="comment">//这也是错误的写法</span></span><br><span class="line"><span class="comment">//正确的写法如下</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; a &amp;&amp; x &lt; z)</span><br><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;q&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;Q&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么关于分支和跳转的部分就叙述到这里，之后我们将学习字符的输入&#x2F;输出以及输入验证。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-环境变量</title>
      <link href="/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2023/07/02/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在上一篇关于shell，子shell，进程相关介绍结束之后，接下来将要学习Linux中的环境变量。</p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>bash shell 会用一个叫作环境变量的特性来存储shell会话和工作环境的信息，这项特性允许我在内存中存储数据，这也是存储持久数据的方法。</p><p>一般来说，环境变量分为两类：全局变量和局部变量</p><p>虽然bash中会有使用一致的专用环境变量，但是不同的版本Linux经常会添加自有的环境变量。</p><h2 id="全局环境变量"><a href="#全局环境变量" class="headerlink" title="全局环境变量"></a>全局环境变量</h2><p>全局环境变量顾名思义就是对于shell和子shell都是可见的，而局部变量则只是对创建它们的shell可见。系统环境变量基本上都是大写的。</p><p>查看全局变量命令：env 或者 printenv</p><p>如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051618054.png"></p><p>这里只是其中一部分的全局环境变量，其中有很多都是在登录过程中设置的，另外，我们的登录方式也会影响到所设置的环境变量。</p><p>若是需要显示个别环境变量的值，使用printenv命令，但是不要使用env命令。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051622854.png"></p><p>当然我们也可以使用echo来显示变量的值，不过在这种情况下使用某个环境变量时，必须要在变量前加上 $ 。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051628360.png"></p><p><strong>Tip：在echo命令中，在变量名前加上$ 可不仅仅是要显示变量当前的值，它能够让变量作为命令行参数。</strong></p><p>那么是否可以用所有的子shell，当然是可以的。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051649985.png"></p><p>上面我们可以看出，在子shell中显示的HOME环境变量的值和父shell中是一摸一样的。</p><h2 id="局部环境变量"><a href="#局部环境变量" class="headerlink" title="局部环境变量"></a>局部环境变量</h2><p>局部环境变量是只能在定义它们的进程中可见，虽然它是局部的但是和全局环境变量同等重要。事实上，Linux系统也默认定义了标准的局部环境变量，不过我们自己也可以定义自己的局部变量，这些被称为用户定义局部变量。</p><p>但是在Linux中并没有一个只显示局部环境变量的命令。set命令会显示特定进程设置的所有的环境变量，包括局部、全局和用户定义变量。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307051712915.png"></p><p>这只是set命令显示出来的部分环境变量，包含了全局环境变量。</p><p><strong>Tip：命令env、printenv和set之间的差异很细微，set不仅仅会显示全部的环境变量还会按照字母的顺序进行排序，而env和printenv并没有这个功能，但是env相较于printenv来说还多出一个功能。</strong></p><h1 id="设置用户定义变量"><a href="#设置用户定义变量" class="headerlink" title="设置用户定义变量"></a>设置用户定义变量</h1><p>上面介绍了两种不同类型的环境变量，那么对于用户自定义变量应该如何去创建并引用就是接下来需要学习的东西。</p><h2 id="设置局部用户定义变量"><a href="#设置局部用户定义变量" class="headerlink" title="设置局部用户定义变量"></a>设置局部用户定义变量</h2><p>在启动了bash shell之后，就可以创建在这个shell内可见的局部变量了，可以通过等号给环境变量赋值，值可以是数值或者是字符串。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307101421447.png"></p><p>非常的简单，当我们需要引用环境变量的值时，只要通过$my_variable引用即可。若是我们需要给变量赋一个含有空格的字符串值，必须使用单引号（双引号）来界定字符串的首尾。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307101425054.png"></p><p><strong>Tip：所有的环境变量名都是使用大写字母，若是我们自己创建的局部变量一般使用小写字母以作区分，另变量名、等号和值之间没有空格，若是加上空格，bash可能会把值作为一个命令。</strong></p><p>当我们设置了局部变量后，就可以在shell的任何地方使用它，但是若是我们在另外一个shell中使用它，结果就是不可用。同理，若是我们在子shell中设置了一个局部变量，一旦退出了子进程，这个局部变量就不可用了。为了解决这个问题，可以将局部的用户定义变量变成全局变量来改变这种情况。</p><h2 id="设置全局环境变量"><a href="#设置全局环境变量" class="headerlink" title="设置全局环境变量"></a>设置全局环境变量</h2><p>设置全局环境变量的进程及其子进程中，这个变量都是可见的，创建全局环境变量的方法是先创建一个局部环境变量，然后再把它导入到全局环境中。</p><p>需要命令：export</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307101452411.png"></p><p>这个过程通过export命令来完成，变量名前不需要加$ 。bash命令启动一个子shell后，在这个子shell中仍能正确显示变量的值，该变量能保留住它的值是因为export命令使其成为了全局环境变量。</p><p><strong>Tip：修改子shell中的全局环境变量不会影响父shell中该变量的值，子shell甚至无法使用export命令改变父shell中全局环境变量的值。</strong></p><h1 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h1><p>上面我们学习了如何创建用户自定义变量，既然可以创建，那么也就可以删除。</p><p>命令：unset</p><p><strong>Tip：不要使用$。</strong></p><p>我们在涉及到环境变量名时，对于什么时候使用$，只需要记住一点：如果需要用到变量，就需要$，如果是操作变量，不使用$，规则有个例外就是printenv 来显示变量的值。</p><p>在处理全局环境变量时，和上述一个规则，若是在子shell中删除了一个全局环境变量，只对子shell有效，该变量在父shell中仍然可以使用。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307101537802.png"></p><h1 id="默认的shell环境变量"><a href="#默认的shell环境变量" class="headerlink" title="默认的shell环境变量"></a>默认的shell环境变量</h1><p>在默认情况下，bash shell 都会使用一些特定的环境变量来定义系统环境，这些变量在Linux系统上就已经设置好了。</p><p>下表是一些bash shell 支持的变量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307101544965.png"></p><p>除了上述默认的环境变量，bash shell 还提供了一些自有的变量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307101555355.png"></p><p>这里就展示一部分，不是所有的默认环境变量都会在运行set命令时列出，尽管这些都是默认环境变量，但并不是每一个都必须有一个值。</p><h1 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h1><p>当我们在shell命令行输入一个外部命令时，shell必须搜索系统来找到对应的程序，PATH环境变量定义了用于进行命令和程序查找的目录。</p><p>在当前系统环境下的目录如下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307111535951.png"></p><p>PATH中的目录使用冒号进行分隔，输出显示了可供用来查找命令和程序。</p><p>如果命令和程序的位置不在PATH环境中，且不使用绝对路径的话，shell是没有办法找到的，这样就会产生一个问题，应用程序可执行文件一般不放在PATH的目录中，就需要我们将应用程序所在的目录放到PATH环境变量的目录中。其实这个步骤还是比较简单的，只需要把新的搜索目录添加到现在的PATH环境变量中，无需从头定义。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307111546807.png"></p><p>如上就已经成功将新的目录添加到了PATH环境变量中了，当我们加入PATH环境变量之后，我们就可以在虚拟目录的任何位置执行程序了。</p><p><strong>Tip：如果我们希望shell能够找到我们程序的位置，要记得把修改的PATH环境变量导出（export命令）。</strong></p><p>一般来说，程序员会将单点符也加入PATH环境变量，单点符表示当前目录。不过对于PATH环境 变量的修改只能持续到退出或者重启系统，并不能一直持续，下面会来学习如何永久保持环境变量的修改效果。</p><h1 id="定位系统环境变量"><a href="#定位系统环境变量" class="headerlink" title="定位系统环境变量"></a>定位系统环境变量</h1><p>环境变量在linux系统中的用途有很多，上面我们学习了如何修改系统的环境变量，也知道如何创建自己的环境变量，那么我们就要学习如何使得它的作用更加持久化。</p><p>在我们登入Linux系统并且启动一个bash shell时，默认情况下bash会在几个文件中查找命令，这些文件叫做启动文件，bash检查的启动文件主要取决于启动bash shell的方式：</p><p>1.登录时作为默认的登录shell</p><p>2.作为非登录shell的交互式shell</p><p>3.作为运行脚本的非交互shell</p><h2 id="登录shell"><a href="#登录shell" class="headerlink" title="登录shell"></a>登录shell</h2><p>当我们登录Linux系统时，bash shell 作为登录shell 启动，会从五个不同的启动文件中读取命令：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307180854797.png"></p><p>第一个文件 &#x2F;etc&#x2F;profile 是系统上默认的bash shell 的主启动文件，每个用户登录都会执行。</p><p><strong>Tip：需要注意的是有些Linux开发版使用的是PAM（可拆卸式认证模块），这种情况下，PAM文件会在bash shell 之前启动处理，这些文件会包含环境变量。</strong></p><p>另外的四个启动文件是针对用户的个人需求定制的，来仔细看看各个文件。</p><p>&#x2F;etc&#x2F;profile 文件：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307180909241.png"></p><p>这个文件上面介绍过了，上图是它在ubuntu系统中的样子。这里面的大部分细节和语法会在之后的章节具体学习。</p><p>在诸多Linux开发版的系统中，启动主文件都用到了一个共同的特性：for语句，主要是用来迭代 &#x2F;etc&#x2F;profile.d 目录下的所有文件。（这是一个为Linux系统提供了一个放置特定程序启动文件的地方），在ubuntu系统下该文件主要包含了以下这些：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307180920925.png"></p><p><strong>Tip：两个文件的主要区别在于，&#x2F;etc&#x2F;profile 是储存命令的，而 &#x2F;etc&#x2F;profile.d 主要是存放命令中所需的可执行文件的。</strong></p><p>在上述可执行文件中大部分都是使用 .sh扩展名（供bash shell使用），还有另外一种使用 .csh扩展名（供C shell使用）。</p><p>$HOME 目录下的启动文件：</p><p>剩下这些启动文件都是起到一个作用：提供一个用户专属的启动文件定义所用到的环境变量。一般来说，大多数都只会使用到一到两个。</p><p>需要知道的是，剩下这四个文件都是以点号开头，这就说明这些是隐藏文件（不会在通常的 ls 指令的输出列表中出现），它们位于用户的HOME目录下，所以每个用户都可以编辑这些文件并且添加自己的环境变量，这些环境变量会在每次启动shell会话时生效。</p><p><strong>Tip：$HOME表示某个用户的主目录，它和波浪号（~）的作用是一样的。</strong></p><h2 id="交互式shell进程"><a href="#交互式shell进程" class="headerlink" title="交互式shell进程"></a>交互式shell进程</h2><p>若是我们的bash shell 不是登录系统时启动的，那么启动的就是交互式shell，不会像登录shell 一样运行，依然会提供命令行提示符来输入命令，若是bash作为交互式shell启动，那么它就不会访问 &#x2F;etc&#x2F;profile 文件了，只会检查用户HOME目录中的. bashrc 文件。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307181339082.png"></p><p>这是在ubuntu系统中，. bashrc 文件的部分命令。</p><p>. bashrc 文件有两个作用：一个是查看&#x2F;etc目录下通用的bashrc文件，二是为用户提供一个定制自己的命令别名和私有脚本函数的地方。</p><h2 id="非交互式shell"><a href="#非交互式shell" class="headerlink" title="非交互式shell"></a>非交互式shell</h2><p>最后一种就是非交互式的shell，系统执行shell脚本时用的就是这种shell，不同的地方在于它没有命令行提示符。脚本能以很多不同的方式运行，但是只有某一些方式能够启动子shell 。</p><p>为了能够处理这样的情况，bash shell 提供了BASH_ENV 环境变量。当shell 启动一个非交互式的进程时，它会检查这个环境变量来查看要执行的启动文件，若是有指定的文件，shell会执行该文件中的命令，也包括一些变量的设置。</p><p>BASH_ENV 环境变量在默认情况下并没有被设置，在这情况下 printenv 命令只会返回CLI提示符：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307181448457.png"></p><p>输入echo 命令会显示一个空行，然后返回CLI命令提示符：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307181452331.png"></p><p>如果BASH_ENV变量没有设置，shell脚本一般会从父shell 中继承导出过的变量，若是脚本不启动子shell的话，变量已经存在于当前的shell中了，就算没有设置，也可以使用当前shell 的局部和全局变量。</p><h2 id="环境变量的持久化"><a href="#环境变量的持久化" class="headerlink" title="环境变量的持久化"></a>环境变量的持久化</h2><p>上面学习了全局环境变量和局部环境变量，以及shell的四种类型：登录、非登录、交互和非交互，接下来就正式进入主题：找出永久性的环境变量和自己创建永久性的全局变量或者是局部变量。</p><p>对于全局变量来说，我们一般将修改过的或者是新的变量放在 &#x2F;etc&#x2F;profile.d 目录下的一个以 .sh 结尾的文件里较为合适。相较之下，&#x2F;etc&#x2F;profile 这个文件会随着系统升级而产生变化，当然还有一个更好的选择，就是$HOME&#x2F;.bashrc文件，<strong>该点适用于所有类型的shell进程</strong>，若是设置了BASH_ENV变量，那么若是该变量不指向 $HOME&#x2F;.bashrc 文件，应当将非交互式shell的用户变量放在别的地方。（原因：非交互式shell不会读取 .bashrc文件。）</p><p>当我们知道了这个，在命令行这片博客中说过 alias 命令设置就是不能够持久存在下去，现在可以将alias 放置在 .bashrc 文件中，使得其效果永久化。</p><h2 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h2><p>环境变量还有一点非常好，那就是可以作为数组来使用，和C语言中的数组本质相同，但是在具体使用细节略微有不同。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202307181719022.png"></p><p>首先自己创建一个数组，和之前学习一样，可以使用通配符进行简略的书写，也可以使用标号进行单独位置的显示，也可以对单独位置的信息进行更改。最后一个命令就是删除整个数组，也可以进行单独的删除。但是数组变量会使得程序变得很麻烦，所以总体上一般不会太频繁的使用到这个变量。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此关于环境变量的介绍就结束了，全局环境变量可以在父进程和子进程中使用，局部环境变量只能在定义它们的进程中使用，还学习了Linux使用全局环境变量和局部环境变量存储环境信息，可以通过shell命令行界面和shell脚本来访问，还学习了登录和非登录，交互和非交互shell之间的区别。</p><p>接下来将要学习的是Linux的文件权限，这相对来说还是比较难的。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-C控制语句：循环</title>
      <link href="/2023/06/03/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-C%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BE%AA%E7%8E%AF/"/>
      <url>/2023/06/03/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-C%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%EF%BC%9A%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>此篇我们将对循环进行更加深入的学习，while、for以及do while三种。</p><h1 id="深入while循环"><a href="#深入while循环" class="headerlink" title="深入while循环"></a>深入while循环</h1><p>在上篇中我们已经初步接触过了这个循环，主要是对条件语句进行判断，接下来通过一个程序来进一步了解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> num;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to be sunmmed &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(q to quit): &quot;</span>);</span><br><span class="line">    status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (status == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum + num;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter next integer (q to quit): &quot;</span>);</span><br><span class="line">        status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Those integers sum to %ld.\n&quot;</span>, sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是根据键入的整数求和，那么while的循环判断语句是什么呢，从上诉程序中我们可以看出就是scanf的返回值，在之前的学习，我们知道scanf的返回值是读取的数字项数，在这个程序中可知返回值只有0和1两种可能性。</p><h2 id="程序注释"><a href="#程序注释" class="headerlink" title="程序注释"></a>程序注释</h2><p>我们先来看看while循环中的测试条件，是一个完全等于的表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status == <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>在这个判断表达式中，&#x3D;&#x3D; 运算符是一个相等运算符，用来判断是否等于1，而不是赋值表达式，把1赋值给status，要让程序正常运行，每次都要获取一个num，并且重置status的值。</p><p>其实我们在这里可以思考一个问题，循环的停止是否只能利用scanf 的返回值呢，若是scanf 没有返回值，我们是否可以利用别的方法来暂停循环，例如将测试条件改为num &gt;0，或者是num !&#x3D; 0。（经过测试，这种方法是可行的！）也可以在循环中添加代码，询问用户是否接着循环，但是这样会增加代码的复杂性，且减慢了输入的速度。</p><p>while循环作为入口条件循环，程序必须在进入循环体之前必须获取输入的数据并检查status的值。</p><h2 id="C风格读取循环"><a href="#C风格读取循环" class="headerlink" title="C风格读取循环"></a>C风格读取循环</h2><p>根据伪代码的设计思路，我们可以对上述程序进行改进：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, num);</span><br><span class="line"><span class="keyword">while</span> (status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 循环体具体行为 */</span></span><br><span class="line">    status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一小节可以改成如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, num) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 循环体具体行为 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，每次迭代之前都会判断循环的条件，只有当获取值和判断值都成功的时候，才会对值进行处理。</p><h1 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h1><p>通用形式：</p><p>while（expression）</p><p>statement</p><p>其中，statement可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。</p><p>在目前接触到的while循环里，对于expression部分都是使用关系表达式，进行真假值的判断，更一般的说法其实就是判断是不是等于1（非零）。只要是非零，循环就会一直执行，每次循环都被称为一次迭代。</p><h2 id="终止while循环"><a href="#终止while循环" class="headerlink" title="终止while循环"></a>终止while循环</h2><p>while循环有一点很重要：必须让测试表达式的值有所变化，表达式最终需要为假。（其实在后面可以使用break和if语句来终止循环）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">while</span> (index &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Good morning!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序会一直输出早上好，因为index的值始终为1，不曾变过，条件一直满足所以一直循环。</p><p><strong>Tip：在循环中我们一定要记住就是不能陷入死循环，对于条件判断表达式的值一定谨慎的选择和变化。</strong></p><h2 id="何时终止循环"><a href="#何时终止循环" class="headerlink" title="何时终止循环"></a>何时终止循环</h2><p>对于这个问题，只有在对测试条件求值时，才决定是终止还是继续循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n = %d&quot;</span>, n);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Now n = %d&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The loop has finished.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这个程序，在第二次循环时首次获得了值7，但此时程序还没有退出，只有在对测试条件的再次判断之后才退出了循环。（所以总共是2次循环，3次判断）</p><h2 id="while：入口条件循环"><a href="#while：入口条件循环" class="headerlink" title="while：入口条件循环"></a>while：入口条件循环</h2><p>while循环是使用入口条件的有条件循环。有条件：语句的部分执行取决于测试表达式的条件，必须满足条件才能进入循环体，因为条件一开始就是假的话，根本进入不了循环。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">10</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (index++ &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Have a fair day or better.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一小段程序，把第一行改成 index &#x3D; 3 就可以开始运行循环了。</p><h2 id="语法要点"><a href="#语法要点" class="headerlink" title="语法要点"></a>语法要点</h2><p>我们在使用while的时候，还有另外一点我们需要记住：只有在测试条件后面的单独语句才是循环部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n is %d\n&quot;</span>, n);</span><br><span class="line">    n++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all program does\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述程序中，虽然n++ 这行缩进了，但是并未把它和上一条语句括在花括号内，因此只有直接跟在测试条件之后的一条语句是循环的一部分，导致这个循环会变成一个死循环的程序。（若是没有外部干涉就不会退出）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n++ &lt; <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n is %d\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all program does\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是将上述程序改为第二版，并且在while循环后面加上分号，那么这个程序的输出结果就会变得不一样，因为这个时候while循环的语句就变成了单独语句而不是一个判断入口语句。（后面这个分号的作用表示空语句）</p><p>但是这个形式最好改为下面的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">    ; <span class="comment">/* 跳过整数输入 */</span></span><br></pre></td></tr></table></figure><p>处理这种情况更好的方法是使用下一章介绍的continue语句。</p><h1 id="用关系运算符和表达式比较大小"><a href="#用关系运算符和表达式比较大小" class="headerlink" title="用关系运算符和表达式比较大小"></a>用关系运算符和表达式比较大小</h1><p>while循环经常使用依赖测试表达式作比较，这样的表达式被称为关系表达式，出现在关系表达式中的运算符叫做关系运算符。</p><p>下图是一些关系运算符：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306091305022.png"></p><p>关系运算符常用于构造while语句和其他C语句中用到的关系表达式，会检查这些关系式的真假。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (number &lt; <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Your number is too small.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ch != <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;num) == <span class="number">1</span>)</span><br><span class="line">sum = sum + num;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这三个例子，我们需要注意的是第二个，关系表达式是可以用于比较字符的，比较的时候使用的是ASCII码，但是不能使用关系运算符来比较字符串，后面会对比较字符串进行介绍。</p><p>在对浮点数进行比较的时候，尽量使用大于号或者小于号，因为有些小数位数的误差会导致原本应该相等的两个数最终不相等，或者也可以使用 fabs（）函数来返回一个浮点数的绝对值。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">double</span> response;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What is the value of pi?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;response);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Try it again!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Close enough!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306091334450.png"></p><h2 id="何为真"><a href="#何为真" class="headerlink" title="何为真"></a>何为真</h2><p>在C语言中什么是真这并不难讨论，关系表达式更是如此，只有一个真一个假，类似于布尔值。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> true_val, flase_val;</span><br><span class="line">    </span><br><span class="line">    true_val = (<span class="number">10</span> &gt; <span class="number">2</span>);</span><br><span class="line">    flase_val = (<span class="number">10</span> &lt; <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;true is %d and flase is %d\n&quot;</span>, true_val, flase_val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这个例子我们就可以看出关系式的返回值就可以是逻辑判断真假。所以有时候可以使用 while（1）使得循环一直进行。</p><h2 id="其他真值"><a href="#其他真值" class="headerlink" title="其他真值"></a>其他真值</h2><p>从上面我们可以知道 1 和 0 可以作为测试表达式，那么是否可以使用其他数字呢？</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is true\n&quot;</span>, n--);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is false\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    n = <span class="number">-3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is true\n&quot;</span>, n++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2d is false\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306091442981.png"></p><p>这个程序对 while 的使用提升了一个层次，不添加 {} ，那么在条件为真时就是接着下一个语句输出，若是为假，则会跳出循环，来到下一个句子。（设计思路听巧妙）。</p><p>一般来说，在C语言中只有0会被认为是假，其余的数字都是真，也可以说，使得测试条件的值为非零即为真，所以有时候会把 while （goats）改成 while （goats !&#x3D; 0），第一种形式对初学者来说比较清楚，但是一般来说，第二种形式为多数程序员使用。</p><h2 id="真值的问题"><a href="#真值的问题" class="headerlink" title="真值的问题"></a>真值的问题</h2><p>虽然C语言对真值的概念约束太少有一定的好处，但是事物都是有两面性的，约束少同时也会带来一些麻烦。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> num;</span><br><span class="line"><span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to be summed &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(q to quit): &quot;</span>);</span><br><span class="line">status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (status = <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter next integer (q to quit): &quot;</span>);</span><br><span class="line">    status = <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Those integers sum to %ld.\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序其实是6.1程序改变而来，而我们改变的就是将 status &#x3D;&#x3D; 1 改为 status &#x3D; 1 ，将原来的等于改为了赋值语句，这会导致我们即使输入了q 改变了status的值，在执行循环测试条件的时候又重新赋值为1，所以while （status &#x3D; 1）其实就是 while（1），外加scanf （）函数读取指定形式的输入失败，它会把 q 留下，在下一次循环的时候继续读取，这样就会形成一个无限失败的循环。</p><p><strong>Tip：这就提醒了我们不要在本应该使用 &#x3D;&#x3D; 的地方使用 &#x3D; ，等于和赋值是两个完全不同的概念。</strong></p><p>为了避免这样的错误，有经验的程序员在构建比较是否相等的表达式时，都会习惯把常量放在左侧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>； <span class="comment">//赋值</span></span><br><span class="line">a == <span class="number">5</span>; <span class="comment">//a是否等于5</span></span><br><span class="line"><span class="number">5</span> = a； <span class="comment">//语法错误</span></span><br><span class="line"><span class="number">5</span> == a； <span class="comment">//效果等于第二行</span></span><br></pre></td></tr></table></figure><p>总之，关系运算符用于构成关系表达式，真时值为1，假时值为0。通常用关系表达式作为测试语句条件，非零为真，零为假。</p><h2 id="新的-Bool类型"><a href="#新的-Bool类型" class="headerlink" title="新的_Bool类型"></a>新的_Bool类型</h2><p>在C语言中，一般来说是使用int类型的变量表示真假值，之前也介绍过新的标准中新增了_Bool类型，但是布尔类型只能存储0和1，如果把其他数值赋值给布尔类型，变量都会被设置为1。</p><p>若是我们使用布尔类型对上面的程序进行更改优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> num;</span><br><span class="line"><span class="type">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="type">_Bool</span> input_is_good;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter an integer to be summed &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(q to quit): &quot;</span>);</span><br><span class="line">input_is_good = (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (input_is_good)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + num;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter next integer (q to quit): &quot;</span>);</span><br><span class="line">input_is_good = (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;num) == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Those integers sum to %ld.\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的优化在于把容易出错的测试表达式转换到了对于布尔值的赋值，所以这个 scanf(“%ld”, &amp;num) &#x3D;&#x3D; 1 式子只能输出0 和 1 的值，这是为了防止输入多个数字出现错误，但根据C语言的约束条件其实 &#x3D;&#x3D; 1 也可以去掉（根据我自己的实验），加上是为了更加严谨的逻辑。</p><p><strong>Tip：最新的标准中提供了stdbool.h 的头文件，该头文件让bool成为了_Bool的别名，还把true和false定义为1和0的符号常量，最关键的是写出来的代码可以和C++兼容，因为C++把bool、true、false定义为了关键字</strong></p><h2 id="优先级和关系运算符"><a href="#优先级和关系运算符" class="headerlink" title="优先级和关系运算符"></a>优先级和关系运算符</h2><p>关系运算符的优先级比算数运算符（+ -）低，比赋值运算符要高。说明 x &gt; y +2 等同于 x  &gt; （y + 2），x &#x3D; y &gt; 2 等同于 x &#x3D; （y &gt; 2）。</p><p>在关系运算符之中也有两种不同的优先级：</p><p>高优先级组：&lt; 、&lt;&#x3D; 、&gt;、 &gt;&#x3D;</p><p>低优先级组：&#x3D;&#x3D;、!&#x3D;</p><p>和大部分的运算符一样，关系运算符的结合律也是从左往右。</p><p>所以 ex !&#x3D; wye &#x3D;&#x3D;zee这个式子就是先判断ex和wye是否相等然后使用得出来的0或1和zee进行比较，但是这种写法不是首选推荐。</p><p>我们下面列出现在已经学习过的运算符的优先级的表格：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306131357679.png"></p><p>while语句小结：while语句创建了一个循环，一直会重复执行到测试表达式为假或0为止，循环体可以是简单语句，也可以是复合语句。</p><h1 id="不确定循环和计数循环"><a href="#不确定循环和计数循环" class="headerlink" title="不确定循环和计数循环"></a>不确定循环和计数循环</h1><p>在实际的运用之中，一些while循环是不确定循环，所谓的不确定循环是指在测试表达式为假之前，不知道需要执行多少次循环，就像前面一个和用户交互计算整数之和的程序；还有另外一类就是计数循环，提前设定好需要循环的次数。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">22</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (count &lt; NUMBER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Be my Valentine!\n&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完成之后，得到如下结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306131414274.png"></p><p>从上面这个程序中，我们可以知道创建一个重复执行固定次数的循环涉及三个要点：</p><p>1.必须初始化计数器</p><p>2.计数器和有限值做比较</p><p>3.每次循环时递增计数器</p><p>while循环的测试条件执行比较，递增运算符执行递增，上述程序把递增放在最后会避免忘记，比将测试条件和更新组合放到一起要更好，但是计数器的初始化放在循环外，就很有可能会忘记初始化，实践告诉我们可能会发生的事终究还是会发生。下面来学习另外一种循环：for循环。</p><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>上面说到了三个行为（初始化、测试和更新），for循环把这三个行为组合在了一处，先来使用for循环对上面这个程序进行优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">22</span>;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; NUMBER; count++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Be my Valentine!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序实现的效果和之前的一摸一样，for关键字后面的圆括号中有三个表达式，分别使用两个分号隔开，第一个表达式是初始化，只会在循环开始时执行一次，第二个是测试条件，第三个是执行更新，for循环语句后面还有简单语句和复合语句，for圆括号中的表达式也叫做控制表达式，都是完整表达式，每个表达式的副作用都发生在对下一个表达式求值之前。</p><p>接下来使用for循环来创建一个立方表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nn cubed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (num = <span class="number">1</span>; num &lt;= <span class="number">6</span>; num++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d %5d\n&quot;</span>, num, num*num*num)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个数字1-6的立方表。</p><p>for循环的第一行包含了循环的所需的信息：初值，终值，每次循环所需的增量。</p><h2 id="利用for循环的灵活性"><a href="#利用for循环的灵活性" class="headerlink" title="利用for循环的灵活性"></a>利用for循环的灵活性</h2><p>for循环相较于while循环拥有更多的灵活性主要取决于for循环的三个表达式，除了像上面一样进行递增的计数器，for循环还有其他的九种用法：</p><p>1.将递增运算符换成递减运算符变成递减计数器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> secs;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (secs = <span class="number">5</span>; secs &gt; <span class="number">0</span>; secs--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d seconds!\n&quot;</span>, secs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;we have ignition!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.可以让计数器递增2、10等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">2</span>; n &lt; <span class="number">60</span>; n += <span class="number">13</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.可以使用字符代替数字计数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ch = <span class="string">&#x27;a&#x27;</span>; ch &lt; <span class="string">&#x27;z&#x27;</span>; ch++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The ASCII value for %c is %d.\n&quot;</span>, ch, ch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序本质上还是使用整数来计数的。</p><p>对于控制的条件我们可以根据自己的需求进行特殊的更改：</p><p>4.让递增的量几何增长</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> debt;</span><br><span class="line">    <span class="keyword">for</span> (debt = <span class="number">100.0</span>; debt &lt; <span class="number">150.0</span>; debt = debt * <span class="number">1.1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Your debt is now $%.2f.\n&quot;</span>, debt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多其他的例子在这里就不逐个展示了，其中在for循环中也可以省略一个或者多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。</p><p><strong>Tip：顺带一提，省略第2个表达式被视为真，所以下面的循环会一直运行：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; ; )</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I want some action\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>在第一个表达式不一定是给变量赋初值，也可以使用 printf（）。在执行循环的其他部分之前，只对第一个表达式求值一次或执行一次。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">printf</span>(<span class="string">&quot;Keep entering numbers!\n&quot;</span>); num != <span class="number">6</span>;)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s the one I want!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306151508104.png"></p><p>上面是程序的执行结果。</p><p>但是若是我们创建了以下的循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(n = <span class="number">1</span>; n &lt; <span class="number">10000</span>; n = n + delta)</span><br></pre></td></tr></table></figure><p>这句话经过几次迭代后会发现delta太小或者太大了，循环中的if语句才可以改变delta的大小，但是这样做也会有危险的一面，就是把delta设置为0了。</p><p>小结：</p><p>for语句使用3个表达式控制循环过程，分别使用分号隔开，initialize表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真（或非零），执行循环一次；接着对update表达式求值，并再次检查test表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。</p><p>形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( initialize; test; update )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>在test为0或者假之前，重复执行statement的内容。</p><h1 id="其他赋值运算符：-x3D-，-x3D-，-x3D-，-x2F-x3D-，-x3D"><a href="#其他赋值运算符：-x3D-，-x3D-，-x3D-，-x2F-x3D-，-x3D" class="headerlink" title="其他赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;"></a>其他赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</h1><p>C语言有许多赋值运算符，最基本、最常用的是&#x3D;，它属于赋值运算符，其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306211645228.png"></p><h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><p>逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> FIRST_OZ = <span class="number">46</span>; <span class="comment">// 2013邮资</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NEXT_OZ = <span class="number">20</span>; <span class="comment">// 2013邮资</span></span><br><span class="line"><span class="type">int</span> ounces, cost;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ounces cost\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ounces = <span class="number">1</span>, cost = FIRST_OZ; ounces &lt;= <span class="number">16</span>;</span><br><span class="line">ounces++, cost += NEXT_OZ)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d $%4.2f\n&quot;</span>, ounces, cost / <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序在初始化表达式和更新表达式中使用了逗号运算符，初始化表达式中的逗号使得ounces和cost都进行了初始化，绝大多数计算都在for循环头中进行。逗号运算符并不局限于在for循环，但是这是它常用的地方。</p><p>例子：house &#x3D; 249，500; 其实等同于house &#x3D; 249;</p><p>​    house &#x3D; （249，500）; 也是赋值表达式，得到最终的结果是500。</p><p>逗号也可以作为分隔符号，在下面的语句中就是分隔符，不是逗号运算符。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch，date；</span><br><span class="line"><span class="built_in">printf</span>（<span class="string">&quot;%d%d\n&quot;</span>, chimps,chumps）;</span><br></pre></td></tr></table></figure><p>小结：</p><p>赋值运算符：</p><p>+&#x3D; 把右侧的值加到左侧的变量上<br>-&#x3D; 从左侧的变量中减去右侧的值<br>*&#x3D; 把左侧的变量乘以右侧的值<br>&#x2F;&#x3D; 把左侧的变量除以右侧的值<br>%&#x3D; 左侧变量除以右侧值得到的余数</p><p><strong>Tips：这些组合赋值运算符与普通赋值运算符的优先级相同，都比算术运算符的优先级低。</strong></p><h2 id="当zeno遇到for循环"><a href="#当zeno遇到for循环" class="headerlink" title="当zeno遇到for循环"></a>当zeno遇到for循环</h2><p>我们运用for循环和逗号表达式来解决Zeno悖论：</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t_ct; </span><br><span class="line"><span class="type">double</span> time, power_of_2;</span><br><span class="line"><span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of terms you want: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;limit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (time = <span class="number">0</span>, power_of_2 = <span class="number">1</span>, t_ct = <span class="number">1</span>; t_ct &lt;= limit;</span><br><span class="line">t_ct++, power_of_2 *= <span class="number">2.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">time += <span class="number">1.0</span> / power_of_2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;time = %f when terms = %d.\n&quot;</span>, time, t_ct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要输入限制的次数，即可得到次数限制内时间之和，通过for循环和逗号表达式更加减少了变量赋值的过程，构建完循环程序之后就相当于完成了程序的编写，大大简化了程序。</p><h1 id="出口条件循环：do-while"><a href="#出口条件循环：do-while" class="headerlink" title="出口条件循环：do while"></a>出口条件循环：do while</h1><p>while循环和for循环都是入口条件循环，就是在每次迭代之前检查测试条件，所以会出现不执行循环体的内容，C语言还有出口条件循环，就是在迭代之后再来检查测试条件，这就保证了循环体至少执行一次，被称为do while循环。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> secret_code = <span class="number">13</span>;</span><br><span class="line">    <span class="type">int</span> code_entered;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To enter the triskaidekaphobia therapy club,\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter the secret code number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code_entered);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (code_entered != secret_code);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Congratulations! You are cured!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306270011783.png"></p><p>当然我们使用while循环也可以得到相同的效果，但是代码相较于使用do while的程序就会复杂不少，首先多出来的一段代码就是do while循环提前输出的这段。</p><p>while循环下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> secret_code = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> code_entered;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;To enter the triskaidekaphobia therapy club,\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter the secret code number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code_entered);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (code_entered != secret_code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To enter the triskaidekaphobia therapy club,\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter the secret code number: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;code_entered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulations! You are cured!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序相较于上一个程序来说就复杂的多了。</p><p>那么do while循环的通用形式：</p><p>do</p><p>statement</p><p>while（expression）；</p><p>statement是一条简单语句或者是复合语句。do while循环最适合那些至少要迭代一次的循环（比较适合密码锁这类场合），若是询问类的则没有这么适合，因为这类都是需要先决条件，使用do while循环的话会迟滞结果的得出。</p><p>总的来说，需要注意的点就是do while循环无论条件判定如何，都会执行一次，这也是它和while循环和for循环的不同之处。</p><h1 id="如何选择循环"><a href="#如何选择循环" class="headerlink" title="如何选择循环"></a>如何选择循环</h1><p>上面我们介绍了while循环，for循环，do while循环三种不同的循环，三个循环各有特点和优势，那么应该如何最大化的提高效率去使用就是这一小结需要学习的了。</p><p>首先我们需要确定的是需要入口条件循环还是出口条件循环，一般来说，入口条件循环用的多一些，因为在执行循环前还是先测试条件比较好，其次，测试条件放在开头会使得程序的可读性更高。</p><p>若是选择入口条件循环，for循环和while循环其实都可以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ,test, ) <span class="comment">//其实就是while循环</span></span><br><span class="line"><span class="keyword">while</span> (test) <span class="comment">//这两个式子本质相同</span></span><br><span class="line"></span><br><span class="line">初始化</span><br><span class="line"><span class="keyword">while</span> (测试)</span><br><span class="line">&#123;</span><br><span class="line">    其他语句；</span><br><span class="line">    更新语句；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (初始化;测试;更新语句)</span><br><span class="line">&#123;</span><br><span class="line">    其他语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就是两者之间的互相转换，主要是看使用者的习惯。当然一般而言，当我们的循环涉及到初始化和更新变量时，使用for循环比较合适，而其他情况下还是while循环更合适。</p><h1 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h1><p>嵌套循环是指在一个循环内包含另外一个循环，嵌套循环主要常用于按行和按列显示数据。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROWS 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARS 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; ROWS; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ch = <span class="string">&#x27;A&#x27;</span>; ch &lt; (<span class="string">&#x27;A&#x27;</span> + CHARS); ch++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序中，第10行的循环属于是外层循环，第12行开始是属于内层循环，内层循环10次打印了A到 J ，外层循环接着换行，进行下一次的外层循环，一共会打印出6行10列的字母。</p><p>嵌套循环的变式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ROWS <span class="number">6</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> CHARS <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; ROWS; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ch = (<span class="string">&#x27;A&#x27;</span> + row); ch &lt; (<span class="string">&#x27;A&#x27;</span> + CHARS); ch++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实本质并未改变，只是添加了打印需要参考行数的变化。</p><h1 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h1><p>在C语言中，数组很重要，可以作为一种储存多个相关项的便利方式，之后会详细学习数组，但是在循环中会使用数组，先在这里简单进行介绍。</p><p>数组是按顺序储存的一系列类型相同的值，比如10个char类型的字符或者15 int类型的值。整个数组有一个数组名，通过整数下标来访问数组中单独的项。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> debts[<span class="number">20</span>]; <span class="comment">//这就是创建了一个浮点型的数组</span></span><br><span class="line">debts[<span class="number">5</span>] = <span class="number">3.14159</span>; <span class="comment">//数组的第六个元素的值是3.14159</span></span><br><span class="line">debts[<span class="number">9</span>] = <span class="number">0.915814</span>; <span class="comment">//数组的第十个元素是0.915814</span></span><br></pre></td></tr></table></figure><p>实际上，使用数组元素和使用同类型的变量一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;debts[<span class="number">6</span>]); <span class="comment">//将读入的数据放到第七个位置上</span></span><br></pre></td></tr></table></figure><p>**Tips：这里需要注意一个潜在的陷阱，C编译器一般不会检查数组的下标是否正确:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debts[<span class="number">20</span>] = <span class="number">88.32</span>; <span class="comment">//这其实是不正确的</span></span><br></pre></td></tr></table></figure><p>但是面对上述错误，编译器不会查找出来，当程序运行时会导致数据被放置在已经被其他数据占用的地方，会破坏程序的正常运行。</p><p>数组的数据类型可以是任意的数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nannies[<span class="number">22</span>]; <span class="comment">//可储存22个int类型整数的数组</span></span><br><span class="line"><span class="type">char</span> actors[<span class="number">26</span>]; <span class="comment">//可储存26个字符的数组</span></span><br><span class="line"><span class="type">long</span> big[<span class="number">500</span>]; <span class="comment">//可储存500个long类型整数的数组</span></span><br></pre></td></tr></table></figure><p>说到数组就不得不提到在字符串那篇中，可以把字符串储存在char类型的数组中，若是在末尾加上空字符 \0，那么就是字符串了。</p><p>用于识别数组元素的数字被称为是下标，下标必须是整数，而且要从0开始计数，数组的元素被依次存在内存相邻的位置。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306271421616.png"></p><h2 id="数组在for循环中的应用"><a href="#数组在for循环中的应用" class="headerlink" title="数组在for循环中的应用"></a>数组在for循环中的应用</h2><p>程序许多地方都要使用到数组，下面是一个比较简单的例子。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAR 72</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index, score[SIZE];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> average;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter %d golf scores:\n&quot;</span>, SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;score[index]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The scores read in are as follows:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, score[index]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; SIZE; index++)</span><br><span class="line">        sum += score[index];</span><br><span class="line">    average = (<span class="type">float</span>)sum/SIZE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of scores = %d, average = %.2f\n&quot;</span>, sum, average);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s a handicap of %.0f.\n&quot;</span>, average - PAR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序大大简化了取数值的麻烦，不用再一个一个的取读，而且在程序开头就采用了明示常量方便以后对数组进行扩展的操作，当然在在读取时数组下角标的方式就是int类型的变量，也需要我们注意，当然这个程序还可以进行优化，可以发现这个程序的三个独立循环都是使用一个条件，可以进行合并和简化使得结构更加紧凑。</p><h1 id="利用返回值的循环"><a href="#利用返回值的循环" class="headerlink" title="利用返回值的循环"></a>利用返回值的循环</h1><p>最后一个程序是要利用一个函数计算数的整数次幂（math.h库中提供了一个强大的幂函数pow()）。</p><p>既然是需要计算数的整数次幂，那么循环就是必不可少的，设计一个循环将 n 相乘p 次就可以得到整数次幂：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p; i++)</span><br><span class="line"><span class="built_in">pow</span> *= n; <span class="comment">//pow的初值设为1</span></span><br></pre></td></tr></table></figure><p>要编写一个有返回值的函数，我们需要完成以下的内容：</p><p>1.定义函数时，确定函数的返回类型。</p><p>2.使用关键字return表明待返回的值。</p><p>接下来我们尝试写一下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> n, <span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p; i++)</span><br><span class="line">        <span class="built_in">pow</span> *= n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序展示的是名为power的函数，返回值可以一个变量的值，也可以是表达式的值。</p><p>接下来我们来使用这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> n, <span class="type">int</span> p)</span>; <span class="comment">// ANSI函数原型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> x, xpow;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a number and the positive integer power&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; to which\nthe number will be raised. Enter q&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; to quit.\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lf%d&quot;</span>, &amp;x, &amp;<span class="built_in">exp</span>) == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">xpow = power(x, <span class="built_in">exp</span>); <span class="comment">// 函数调用</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3g to the power %d is %.5g\n&quot;</span>, x, <span class="built_in">exp</span>, xpow);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter next pair of numbers or q to quit.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hope you enjoyed this power trip -- bye!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> n, <span class="type">int</span> p)</span> <span class="comment">// 函数定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line"><span class="built_in">pow</span> *= n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">// 返回pow的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个程序中的main（）函数是一个测试函数，就是被设计用来测试函数的小程序，程序的while循环的判断条件是之前讨论过的形式，利用scanf（）函数的返回值进行判断，读取两个数就能够进入循环，剩下的就是power（）函数的内容了，一共出现了三次，第一次是声明，第二次是使用，第三次是函数定义，power（）函数有两个形参，一个是double类型，一个是int类型。</p><p><strong>Tip：函数定义的末尾没有分号，而函数原型的末尾有分号。在函数头后面花括号中的内容，就是power()完成任务的代码。</strong></p><p>在我们使用带返回值的函数时，声明函数、调用函数、定义函数、使用关键字return都是其中的基本要素。</p><p>对于定义中说明了power（）函数的返回类型是double，为什么还要提前声明，其实如果把函数定义放在main（）函数之前，就可以不用前置声明了，但是这不是很符合C语言的习惯，所以前置声明是必不可少的。那为什么scanf（）函数就可以直接使用，是因为在头文件中包含了函数的原型表明。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>循环是一个强大的编程工具，在创建循环的时候我们需要注意三个方面：</p><p>1.注意测试条件要能使得循环结束。</p><p>2.要保证测试中的值首次使用之前已经初始化。</p><p>3.保证循环每次迭代都会更新测试的值。</p><p>数组是由相邻的内存位置组成，只能存储相同类型的数据。</p><p>涉及到函数使用的3个步骤：</p><p>1.通过函数原型声明函数。（声明函数的时候需要使用分号（；））</p><p>2.在程序中通过函数调用使用函数。</p><p>3.定义函数。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-shell进程</title>
      <link href="/2023/05/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-shell%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/05/22/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-shell%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中，已经介绍了些许系统管理员和程序员用到的一些高级bash指令，那么这篇我们将介绍shell进程的技巧。</p><h1 id="shell类型"><a href="#shell类型" class="headerlink" title="shell类型"></a>shell类型</h1><p>一般来说，系统启动什么样的shell进程取决于个人的ID设置，在&#x2F;etc&#x2F;passwd文件中我们可以看到ID的记录，只要登录，默认的虚拟shell程序就会运行。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301250891.png"></p><p>在现在使用的ubuntu版本上，默认的系统shell和默认的交互shell并不一致，默认的交互shell是&#x2F;bin&#x2F;bash，但是作为系统的默认shell却是&#x2F;bin&#x2F;sh被设置成dash shell。</p><p><strong>Tip：对bash shell脚本来说，这两种不同的shell（默认的交互shell和默认的系统shell）会造成问题。</strong></p><p>我们可以直接采用&#x2F;bin&#x2F;dash的指令进入dash shell程序，$提示符是dash的标志，若是需要退出，我们只需要键入exit指令即可。</p><p>在下一节将探究shell程序和新启动的shell程序之间的关系。</p><h1 id="shell的父子关系"><a href="#shell的父子关系" class="headerlink" title="shell的父子关系"></a>shell的父子关系</h1><p>了解关系之前，需要知道什么是父shell，一般来说用于登录控制器终端或者在终端仿真器所启动的默认shell就是一个父shell，然后等待命令的输入。</p><p>在命令行输入&#x2F;bin&#x2F;dash的命令之后会创建一个全新的shell程序，那么这个程序就被称为子shell，也同样会等待命令的输入。</p><p>当我们生成子shell的时候，需要使用ps -f命令来帮助我们理清这一切，这个命令显示出显示出现有的进程：<br><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301308271.png"></p><p>在我们输入命令之后，一个子shell就出现了，第二个ps -f 是在子shell中执行的，其实在PID和PPID这两个号码之间，我们也能够看出端倪，现有的ID都是由父shell所创建而成。</p><p>在生成子shell进程时，只有部分的父进程的环境会被复制到子shell环境中，这会对包括变量在内的一些东西造成影响，子shell可以从父shell中创建，也可以从另一个子shell中创建（相当于一个树形结构中的分支）。</p><p>bash shell程序可以使用命令行参数修改shell的启动方式：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301320028.png"></p><p>还有更多的参数可以使用man命令详细查看。</p><h2 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h2><p>为了避免命令过多需要一个又一个的输入，我们可以在一行中一次运行一系列的命令，这就是命令列表，只需要在命令之间加入分号（；）即可。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301326479.png"></p><p>该实例中命令依次执行，不存在任何的问题，但这也仅仅是命令列表，不是进程列表，若是要变成进程列表，这些命令必须包含在括号中。</p><p>多了括号之后，在最终的结果来看并没有什么不同，但是多了括号之后，使得命令列表变成进程列表，生成一个子shell来执行对应的指令。</p><p><strong>Tip：进程列表是一种命令分组（command grouping）。另一种命令分组是将命令放入花括号中，并在命令列表尾部加上分号（;）。语法为{ command; }。使用花括号进行命令分组并不会像进程列表那样创建出子shell。</strong></p><p>在这个实例中最值得关注的就是是否生成子shell，我们需要借助一个环境变量来查看：（echo $BASH_SUBSHELL）。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301338554.png"></p><p>如上图所示，显示的数字是0，说明这些命令不是在子shell中运行的。</p><p>若是使用进程列表的话，最后输出的数字会是1。甚至我们还可以命令列表中嵌套括号来创建子shell。</p><p><strong>Tip：在shell脚本中，经常会使用子shell进行多线程处理，但是利用子shell的成本不菲，会明显的拖慢处理的速度，在一般交互式的shell会话中，子shell同样会存在问题。</strong></p><h2 id="子shell的用法"><a href="#子shell的用法" class="headerlink" title="子shell的用法"></a>子shell的用法</h2><p>在交互式shell中，一个高效的子shell用法就是使用后台模式。</p><p>后台模式：运行命令可以在处理命令的同时让出CLI，以作他用。其中经典命令就是sleep。</p><p>sleep：接受一个参数，参数是希望进程等待的秒数，返回CLI提示符。</p><p>若是我们想要将命令置入后台模式，可以在命令末尾加上字符&amp;。当命令被置入后台，在CLI提示符返回之前会出现两个信息，第一个信息是显示在方括号中的后台作业号，第二个是后台作业的进程ID。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301400631.png"></p><p>后台作业号是2，进程ID是9370。</p><p>在这里我们除了使用ps命令来查看进程信息，也可以使用jobs命令来显示后台作业信息。</p><p>jobs命令：可以显示当前在进行作业的进程的信息。</p><p>方括号中是作业号，第二个是作业状态，以及对应的命令。</p><p>利用jobs命令中的-l选项，还可以看到更多相关的信息，还能显示PID。后台作业结束后就会显示已完成的状态。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301412495.png"></p><p><strong>Tip：需要提醒的是，后台作业的结束状态不是一直等待到合适的时候才会现身，会突然出现在屏幕上。</strong></p><p>上面是将命令置入后台，若是我们将进程列表置入后台会有什么不一样的效果嘛</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301420387.png"></p><p>在CLI中运用子shell较好的方法之一就是将进程列表置入后台模式，既可以在子shell之中进行处理工作，也不会让子shell的I&#x2F;O受制于终端。</p><p>除了将进程列表置入后台模式之外，还有另外一种方法也可以—协程。</p><p>协程：同时做两件事，在后台生成一个子shell，并在这个子shell之中执行命令。</p><p>命令：coproc  command</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301432894.png"></p><p>同样的jobs命令可以显示协程的处理状态。</p><p>从上面的例子我们可以看到，子shell执行的后台指令是coproc COPROC sleep 10。COPROC是coprco命令给进程取的名字，我们自己可以使用扩展语法设置这个名字：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301437168.png"></p><p>当然，使用扩展语法写起来还是有些许的麻烦，必须确保第一个花括号和命令之间有一个空格，结尾亦是如此。</p><p><strong>Tip：协程使用起来非常的方便，只有当我们拥有多个协程的时候才需要对其命名，需要和它们进行通信。</strong></p><p>协程和进程列表结合起来可以产生嵌套的子shell，只需要输入进程列表，然后在列表前加上命令coproc就可以了。</p><p>简单的介绍了子shell的几个用途，接下来我们来研究内建命令和外部命令的差异。</p><h1 id="shell的内建命令"><a href="#shell的内建命令" class="headerlink" title="shell的内建命令"></a>shell的内建命令</h1><p>在shell的学习过程中，我们可能听说过内建命令和非内建命令（外部命令），这两种命令的操作方式也是大不相同。</p><h2 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h2><p>外部命令有时候也被称为文件系统命令，是存在于bash之外的程序，外部命令一般可能存在于&#x2F;bin，&#x2F;usr&#x2F;bin之中。</p><p>ps命令其实就是一个外部命令，可以使用which和type命令来找到它，当外部命令执行的时候，会创建出一个子进程，这种操作被称为衍生，ps命令可以很方便的显示出它的父进程及对应的衍生程序。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031413558.png"></p><p><strong>Tip：就算衍生出子进程或是创建了子shell，仍然可以通过发送信号与其沟通，这一点在命令行和脚本编写都是很有用的。</strong></p><h2 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h2><p>要说内建命令和外部命令的区别主要在于内建命令不需要使用子进程来执行，它们已经和shell编译成一体了，作为shell工具的组成部分，不用借助外部程序文件来运行。</p><p>cd和exit命令都内建于bash shell，也可以使用type命令来进行查看。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031420496.png"></p><p><strong>Tip：既不需要衍生出子进程来执行，也不需要打开程序文件，执行速度更快，效率也更高。</strong></p><p>当然命令也不是这两种的分类，有些命令更是两者兼而有之，例如echo和pwd。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031423099.png"></p><p>有一点需要注意，which命令只能显示外部命令文件，对于有多种实现的命令，我们若是想要外部命令来实现，可以直接输入&#x2F;bin&#x2F;pwd。</p><h3 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h3><p>一个比较有用的内建命令是history命令，shell会跟踪使用过的命令，可以召回这些命令并且再次使用。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031431350.png"></p><p>一般来说记录的命令会非常的多，需要谨慎使用。</p><p><strong>Tip：我们可以设置保存在bash历史记录的命令数，要想实现这一点，需要修改名为HISTSIZE的环境变量。</strong></p><p>若是我们只是需要唤回并使用最近的命令，只需要输入！！即可。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031438986.png"></p><p>命令历史记录是被保存在隐藏的文件.bash_history中，位于主目录里，bash命令是先存放在内存中，当shell退出才写进历史文件。但是我们可以在退出会话之前将命令历史记录写入.bash_history文件，为了实现强制写入，需要使用history中的-a选项。</p><p>history和.bash_history的输出是一样的，除了最近的那条命令。</p><p><strong>Tip：若是打开了多个终端会话，仍然可以使用history -a命令在打开的会话中向文件中添加记录，对于其他的终端会话，该命令却不会向里面添加记录，若是想要更新终端会话，可以使用history -n命令。</strong></p><h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>alias命令是另一个shell的内建命令，命令别名允许为常用的命令创建另一个名称，降低输入量。</p><p>一般来说在系统初始会预设一些命令别名：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031514519.png"></p><p>自己也可以创建命令的别名：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306031517760.png"></p><p>这个时候，我们就可以使用 li 命令来代替 ls -li 了。这个时候我们随时都可以使用它，在shell脚本中也可以，但是命令别名属于内部命令，一个别名只在被定义的shell进程中才有效。当然是有方法可以解决的，在之后的学习中会讲到。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此篇主要是讨论了shell，包括shell进程及其关系，还有子shell，以及那些能够创建子进程的命令和不能创建子进程的命令。</p><p>1.当我们登录终端时，一般会启动一个交互式shell，系统启动那个主要取决于用户的配置，一般是bash或者dash。</p><p>2.子shell可以利用bash来生成，或者是使用进程列表，coproc命令也会产生shell，子shell也可以嵌套，生成子shell的子shell。</p><p>3.最后学习两种类型的命令：内建命令和外部命令。</p><p>下一篇将会学习linux的环境变量。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-BERT-Bilstm-CRF命名实体识别</title>
      <link href="/2023/05/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-BERT-Bilstm-CRF%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"/>
      <url>/2023/05/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-BERT-Bilstm-CRF%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>这篇博客用来记录导师项目中碰到的问题以及解决方法！</p><p>这周在结束了模型的训练和项目结构的初步理解，问题渐渐转到了获取数据集和对于新的数据集的训练和三元组的提取，下面是项目的结构:</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305301517904.png"></p><p>此次的项目主要是为了实现橡胶挤塑机的故障预警和故障溯源，我的想法是希望通过机器运行过程中产生的日志中的文本信息进行命名实体抽取，在形成三元组之后存入图数据库（neo4j）之中，在工业机器出现该故障之后，可以及时查询到整个完整的故障链路和可能出现的分支情况，也能够对新出现的故障进行及时的增删改查。</p><p>那么第一步对于非结构化的文本和半结构化的文本的处理就显得较为重要。</p><p>这周汇报时，针对matlab生成日志问题，导师解答了疑惑，其实需要我自己写txt文件的判断语句，通过生成的数据是否产生偏差可以读取出故障，那么针对这个问题，首先分为两步，首先，提取出的三元组应当是故障——&gt;问题的结构，但是对于此次的文本来说，一个故障的出现可能是2个或者2个以上的变量同时影响而得到的，不过这对于标注来说并不是什么大问题，我采用一个标注软件就能解决：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061651673.png"></p><p>如上图所示，这是一个模糊控制的简单例子中的四条规则，我们将其提炼总结之后可以得到我们的故障文本，其中里面包含故障前因，故障，故障后果，其中的故障f1、f2和f3 如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061656085.png"></p><p>分别是三个故障。</p><p>提炼总结后的中文文本：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061657717.png"></p><p>得到故障文本之后，我们就开始对其进行处理，使用标注软件和脚本对其进行处理，并将其上传到neo4j数据库之中：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061704023.png"></p><p>这样就说明我们提取三元组成功并且上传到数据库里了。那么接下来我们需要从模型中使用具体的数据来看看是否可以从其中提取出不同条件下出现的故障以及是否正确提取。</p><p>在matlab中打开模型，设定好参数后，运行simulink，得到我们需要的数据：</p><p>level.xlsx和flowout.xlsx两个数据文件</p><p>提取数据的命令：xlwrite（’level.xlsx’,level)</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061712729.png"></p><p>如图所示</p><p>接下来我们对数据进行处理，希望可以得到在flowout和level同时满足条件时输出正确的故障。代码如下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202306061713265.png"></p><p>上述代码还有错误，有待修改。（并未导入level.xlsx的数据），不过上述代码可以得到我想要的结果，那就是在flowout小于0.0032时输出正确的文字，接下来只要加入level的数据再做尝试。</p><p>接下来我们来导入level的数据进行下一步的处理。</p><p>这篇博客的学习内容因为企业实习的原因暂时搁置，但是希望未来可以用到这段时间中学习到的内容，但是C语言的复习内容和Linux 的新学内容仍然会更新。</p>]]></content>
      
      
      <categories>
          
          <category> 导师项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-运算符、表达式和语句</title>
      <link href="/2023/05/12/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/05/12/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>上一篇博客我们结束了对格式化字符串的输入输出的介绍和学习，这一篇博客我们将学习如何来处理数据，处理方式：算数运算、比较值的大小、修改变量、各种逻辑的组合关系等。</p><p><strong>Tip：此篇中我们还学习循环这个编程中最强大的特性。</strong></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>为什么我们需要使用循环，因为若是完成单一的工作，编写程序的工作量远不如人完成的快速有效率，计算机需要帮助我们完成的就是重复计算的工作，C中有相当多的方法可以去做重复计算，这里先简单的介绍一种——while循环。</p><p>如下所示，在有或没有循环两种情况下的代码的效率：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121448492.png"></p><p>无循环，只能输出单个的结果。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121459096.png"></p><p>加入while循环，可以输出多个结果。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305121503058.png"></p><p>从这里我们可以得出结论，在进行重复运算时，计算机相较于人有显著的优势。</p><p>while循环的原理：</p><p>当程序第一次到达循环时，会检查圆括号中的条件是否为真，在上述例子中条件表达式：shoe &lt; 18.5。初始鞋码为3.0，条件为真，程序将进入循环执行，将尺码转化为英寸，进行打印结果，在最后给shoe增加1.0，返回while入口检查条件，while下两个花括号括起来的称为块。返回入口时会再次进行判断，直至循环结束。</p><h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><p>在C中使用运算符表示算数运算，除开基本运算符以外，C没有指数运算符，不过C标准库提供一个<strong>pow（）函数</strong>用于指数运算：pow（3.5， 2.2）表示3.5的2.2次幂。</p><p><strong>Tip：在使用Pow（）函数时需先导入math.h的头文件，且在编译时需要在gcc mi.c -o mi 后加上 -lm才能编译成功。（链接math头文件）。</strong></p><h2 id="赋值运算符：-x3D"><a href="#赋值运算符：-x3D" class="headerlink" title="赋值运算符：&#x3D;"></a>赋值运算符：&#x3D;</h2><p>对于这个运算符应该都不陌生，不是常规数学中的等于号意味着相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bmw = <span class="number">2000</span>；</span><br></pre></td></tr></table></figure><p>上述语句就是把2000这个数值赋给bmw这个变量，赋值行从右往左进行。</p><p>变量名和变量值的区别看似区别不大，那么下面这个语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>这在数学上来说是完全行不通的，但是在赋值语句中就是常规的对变量加1并且赋值给 原变量的过程。在编写代码的过程中，&#x3D; 号左侧必须是一个变量名，右侧是一个常量或者表达式。</p><p><strong>几个术语：数据对象、左值、右值和运算符</strong></p><p>数据对象：存储值的数据存储区域称为数据对象。一般使用变量名来标识对象，还有指定数组的元素、结构的成员、使用指针表达式等。（房间）</p><p>左值：用于标识特定数据对象的名称或者表达式。（房间号）</p><p>前篇提到过的 const 限定符也是变量名却不能被赋值，所以左值就变成了可修改的左值。</p><p>右值：指能赋值给可修改左值的量，且本身不是左值。可以是常量、变量或者可求值的表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ex;</span><br><span class="line"><span class="type">int</span> why;</span><br><span class="line"><span class="type">int</span> zee;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TWO = <span class="number">2</span>;</span><br><span class="line">why = <span class="number">42</span>;</span><br><span class="line">zee = why;</span><br><span class="line">ex = TWO * (why + zee);</span><br></pre></td></tr></table></figure><p>一般来说其他语言会回避程序的三重赋值，但是在C中完全没问题。</p><h2 id="加法运算符："><a href="#加法运算符：" class="headerlink" title="加法运算符：+"></a>加法运算符：+</h2><p>用于加法运算，使得两侧的值相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">4</span> + <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>输出的是24，而不是表达式 4 + 20。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">income = salary + bribes;</span><br></pre></td></tr></table></figure><p>这样的表达式也是可以的，程序会读取右边变量的值并将其相加，然后把和赋值给income。</p><h2 id="减法运算符："><a href="#减法运算符：" class="headerlink" title="减法运算符：-"></a>减法运算符：-</h2><p>同加法运算符理，这两个运算符被称为二元运算符，即需要两个运算符才能完成操作。</p><h2 id="符号运算符"><a href="#符号运算符" class="headerlink" title="符号运算符"></a>符号运算符</h2><p>减号还可以用于标记一个值的代数符号。例如，执行下面的语句后，值会变成12：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rocky = <span class="number">-12</span>;</span><br><span class="line">smokey = -rocky;</span><br></pre></td></tr></table></figure><p>以这种方式使用的负号被称为一元运算符。</p><p><strong>Tip：在最新的标准中，增加了+的一元运算符，仅仅是编译不会报错。</strong></p><h2 id="乘法运算符："><a href="#乘法运算符：" class="headerlink" title="乘法运算符：*"></a>乘法运算符：*</h2><p>符号*表示乘法，并将结果进行赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cm = <span class="number">2.54</span> * inch;</span><br></pre></td></tr></table></figure><p>在C中没有平方函数，我们就可以使用乘法来计算平方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d %6d\n&quot;</span>, num, num * num);</span><br><span class="line">        num = num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有另外一个在棋盘中放麦粒也是类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARES 64 <span class="comment">// 棋盘中的方格数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> CROP = <span class="number">2E16</span>; <span class="comment">// 世界小麦年产谷粒数</span></span><br><span class="line"><span class="type">double</span> current, total;</span><br><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;square grains total &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fraction of \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; added grains &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;world total\n&quot;</span>);</span><br><span class="line">total = current = <span class="number">1.0</span>; <span class="comment">/* 从1颗谷粒开始 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d %13.2e %12.2e %12.2e\n&quot;</span>, count, current,</span><br><span class="line">total, total / CROP);</span><br><span class="line"><span class="keyword">while</span> (count &lt; SQUARES)</span><br><span class="line">&#123;</span><br><span class="line">count = count + <span class="number">1</span>;</span><br><span class="line">current = <span class="number">2.0</span> * current; <span class="comment">/* 下一个方格谷粒翻倍 */</span></span><br><span class="line">total = total + current; <span class="comment">/* 更新总数 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d %13.2e %12.2e %12.2e\n&quot;</span>, count, current,</span><br><span class="line">total, total / CROP);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That&#x27;s all.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中还运用到了while循环。</p><h2 id="除法运算符：-x2F"><a href="#除法运算符：-x2F" class="headerlink" title="除法运算符：&#x2F;"></a>除法运算符：&#x2F;</h2><p>C中使用符号&#x2F;来表示除法，左侧属于被除数，右侧属于除数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">four = <span class="number">12.0</span>/<span class="number">3.0</span>；</span><br></pre></td></tr></table></figure><p><strong>Tip：在C语言中，整数除法结果会有小数部分被丢弃，这一过程被称为截断。</strong></p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 5/4 is %d \n&quot;</span>, <span class="number">5</span> / <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 6/3 is %d \n&quot;</span>, <span class="number">6</span> / <span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;integer division: 7/4 is %d \n&quot;</span>, <span class="number">7</span> / <span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;floating division: 7./4. is %1.2f \n&quot;</span>, <span class="number">7.</span> / <span class="number">4.</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mixed division: 7./4 is %1.2f \n&quot;</span>, <span class="number">7.</span> / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip：C语言中对于负数的截断一般会舍弃小数部分，称为趋零截断，如-3.8会变成-3。</strong></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>在日常数学运算中，我们都知道要先乘除后加减，那么在C语言中的运算符也有对应的优先级。基本规则差距不大，如下表所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305131429823.png"></p><p><strong>Tip：我们只需要注意+、-的两种不同用法即可</strong></p><h2 id="优先级和求值顺序"><a href="#优先级和求值顺序" class="headerlink" title="优先级和求值顺序"></a>优先级和求值顺序</h2><p>用一个简单的程序就能解释清楚这个问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> top, score;</span><br><span class="line">top = score = -(<span class="number">2</span> + <span class="number">5</span>) * <span class="number">6</span> + (<span class="number">4</span> + <span class="number">3</span> * (<span class="number">2</span> + <span class="number">3</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;top = %d, score = %d\n&quot;</span>, top, score);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序的输出结果应当为-23，这和我们在实际数学应用上并无不同。</p><h1 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h1><p>上面介绍的都是C语言中最常用的运算符，接下来我们介绍一些比较有用的运算符。</p><h2 id="sizeof-运算符和size-t类型"><a href="#sizeof-运算符和size-t类型" class="headerlink" title="sizeof 运算符和size_t类型"></a>sizeof 运算符和size_t类型</h2><p>在数据类型那篇文章里最后就介绍了这个运算符。</p><p>功能：以字节为单位返回运算对象大小。</p><p>运算对象：具体的数据对象（变量名）或者类型。</p><p><strong>Tip：若是类型必须使用圆括号括起来。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> intsize;</span><br><span class="line">        intsize = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;n = %d, n has %zd bytes; all ints have %zd bytes.\n&quot;</span>,n ,<span class="keyword">sizeof</span> n, intsize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序就展示了这个运算符的功能以及size_t类型的数据。</p><p>在C语言中，sizeof 返回的就是size_t类型，属于无符号整型，不是一个新类型。</p><p><strong>Tip：C还有一个typedef类型，可以允许使用者为现有的类型创建别名，后续再详细介绍。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> real;</span><br></pre></td></tr></table></figure><p>这样一来，real 就是double的别名了，real 类型的变量本质就是double类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">real deal；<span class="comment">//使用typedef</span></span><br></pre></td></tr></table></figure><p><strong>Tip：在最新的标准中，%zd 转换说明用于printf（）显示size_t 类型，若是系统不支持，则可以使用%u 或者%lu来代替%zd。</strong></p><h2 id="求模运算符："><a href="#求模运算符：" class="headerlink" title="求模运算符：%"></a>求模运算符：%</h2><p>功能：给出其左侧整数除以右侧整数的余数。</p><p>例：13%5，得3。</p><p>局限：只能用于整数，不能用于浮点数。</p><p>该运算符在有公约数且需要取余的程序中用处很大。(例如年月分秒)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEC_PER_MIN 60 <span class="comment">// 1分钟60秒</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sec, min, left;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Convert seconds to minutes and seconds!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the number of seconds (&lt;=0 to quit):\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sec); <span class="comment">// 读取秒数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sec &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = sec / SEC_PER_MIN; <span class="comment">// 截断分钟数</span></span><br><span class="line">left = sec % SEC_PER_MIN; <span class="comment">// 剩下的秒数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d seconds is %d minutes, %d seconds.\n&quot;</span>, sec, min, left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter next value (&lt;=0 to quit):\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序是对正数进行求模，那么怎么对负数进行求模呢？</p><p>在最新的标准中，有了趋零截断的规则之后，第一个运算对象是负数，那么求模结果也是负数，若为正数，求模也为正数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> / <span class="number">5</span>得<span class="number">2</span>，<span class="number">11</span> % <span class="number">5</span>得<span class="number">1</span>；</span><br><span class="line"><span class="number">11</span> / <span class="number">-5</span>得<span class="number">-2</span>，<span class="number">11</span> % <span class="number">-5</span> 得<span class="number">1</span>；</span><br><span class="line"><span class="number">-11</span> / <span class="number">5</span>得<span class="number">-2</span>，<span class="number">-11</span> % <span class="number">5</span>得<span class="number">-1</span>；</span><br><span class="line"><span class="number">-11</span> /<span class="number">-5</span>得<span class="number">2</span>，<span class="number">-11</span> % <span class="number">-5</span>得<span class="number">-1</span>；</span><br></pre></td></tr></table></figure><p>若是系统不支持最新的标准，但是只要两个数是整数，就可以使用a - (a&#x2F;b)*b来计算 a % b。</p><h2 id="递增运算符："><a href="#递增运算符：" class="headerlink" title="递增运算符：++"></a>递增运算符：++</h2><p>功能：将其运算对象递增1。</p><p>使用方式：</p><p>1.出现在其作用的变量前面，属于前缀模式</p><p>2.出现在其作用的变量后面，属于后缀模式</p><p>有了这个运算符，我们可以对前面出现的鞋码测脚长的程序进行优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shoe = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">while</span> (shoe &lt; <span class="number">18.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">foot = SCALE * size + ADJUST;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10.1f %20.2f inches\n&quot;</span>, shoe, foot);</span><br><span class="line">++shoe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是将shoe &#x3D; shoe + 1 转换成 ++shoe，还可以进行进一步的精简:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shoe = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">while</span> (++shoe &lt; <span class="number">18.5</span>)</span><br><span class="line">&#123;</span><br><span class="line">foot = SCALE*shoe + ADJUST;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10.1f %20.2f inches\n&quot;</span>, shoe, foot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在这里我们需要注意的是，由于是循环外的递增，所以我们需要将shoe的初始值改成2.0，这样我们的第一个输入值才会是3.0。</p><p><strong>Tip：这样虽然精简了程序，但是也降低了程序的可读性，同时也使得后续排查错误显得更加难。</strong></p><p>当然这两种的使用方式也有区别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a_post, pre_b;</span><br><span class="line"></span><br><span class="line">    a_post = a++; <span class="comment">// 后缀递增</span></span><br><span class="line">pre_b = ++b; <span class="comment">// 前缀递增</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a a_post b pre_b \n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%1d %5d %5d %5d\n&quot;</span>, a, a_post, b, pre_b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305131553448.png"></p><p>在两个运算符单独使用时，并没有区别，但是在运算表达式中时，后缀是先赋值后递增，而前缀是先递增后赋值。为了避免这样的错误，一般解决方法就是不要这样使用他们，换一种方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = i++；<span class="comment">//不好</span></span><br><span class="line">i++；</span><br><span class="line">b = i; <span class="comment">//较好（换成++i也不会影响b的值）</span></span><br></pre></td></tr></table></figure><h2 id="递减运算符：–"><a href="#递减运算符：–" class="headerlink" title="递减运算符：–"></a>递减运算符：–</h2><p>基本同递增运算符的理，每个++都可以用–来代替。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">101</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (--count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bottles of spring water on the wall, &quot;</span> <span class="string">&quot;%d bottles of spring water!\n&quot;</span>, count, count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Take one down and pass it around,\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d bottles of spring water!\n&quot;</span>, count<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip：在这个程序中，&lt; &gt;这两个符号表示的是大于号和小于号，都属于关系运算符。</strong></p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>和代数运算一样，递增递减运算符也拥有很高的结合优先级，只有圆括号的优先级比他们高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">2</span>；</span><br><span class="line">n = <span class="number">3</span>；</span><br><span class="line">nextnum = （y + n++）*<span class="number">6</span>；</span><br></pre></td></tr></table></figure><p>上述程序的值应当是30，因为n++是先使用了3而后再进行加1的操作。</p><h2 id="贴心提示"><a href="#贴心提示" class="headerlink" title="贴心提示"></a>贴心提示</h2><p>在同一个程序中，不要一次使用过多的递增运算符，否则会被程序弄晕。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">21</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%10d %10d\n&quot;</span>, num, num*num++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序有可能会出现先递增再计算的后果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>  <span class="number">25</span> <span class="comment">//原来的结果</span></span><br><span class="line"><span class="number">6</span>  <span class="number">25</span> <span class="comment">//现实的结果</span></span><br></pre></td></tr></table></figure><p>而且同一个语句也可能因为编译器不会按照预想的顺序来执行，所以最好的办法就是不要在一个语句中过多使用递增运算符。</p><p><strong>Tip：1.如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或<br>递减运算符；<br>          2.如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减<br>运算符。</strong></p><h1 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h1><p>C的基本程序步骤由语句组成，而大多数语句都由表达式构成。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式（expression）由运算符和运算对象组成（前面介绍过，运算对象是运算符操作的对象）。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">-6</span></span><br><span class="line"><span class="number">4</span>+<span class="number">21</span></span><br><span class="line">a*(b + c/d)/<span class="number">20</span></span><br><span class="line">q = <span class="number">5</span>*<span class="number">2</span></span><br><span class="line">x = ++q % <span class="number">3</span></span><br><span class="line">q &gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>每一个表达式都有一个值，若是有&#x3D;（赋值运算符）即是按照符号的优先级进行计算得出最后的数值；若是&gt;&lt;这些关系运算符，那么这些表达式的值最后都是0或者1，用以表示真假。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句（statement）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">legs = <span class="number">4</span> <span class="comment">//表达式</span></span><br><span class="line">legs = <span class="number">4</span>；<span class="comment">//语句</span></span><br></pre></td></tr></table></figure><p>最简单的语句是空语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">；<span class="comment">//空语句</span></span><br></pre></td></tr></table></figure><p><strong>Tip一条完整的指令不一定是一条语句。</strong></p><p>常见语句实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> count, sum;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (count++ &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sum = sum + count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序中包含了声明和表达式语句和迭代语句和跳转语句。</p><p><strong>Tip：特殊的就是声明，它不是表达式语句，若是去掉分号也不是一个表达式。</strong></p><p>while语句是一种迭代语句，也被称为结构化语句，相较于简单的赋值表达式语句更加复杂。</p><h3 id="副作用和序列点"><a href="#副作用和序列点" class="headerlink" title="副作用和序列点"></a>副作用和序列点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>上述的语句的副作用就是将变量的值设置为50，其实我也没理解为啥是副作用，书上这么写的，说是对数据对象或文件的修改就叫副作用。</p><p>类似的，我们调用printf（）函数时，显示信息其实是副作用，返回值是显示字符的个数。</p><p>序列点：程序执行的点。</p><p>作用：在该点上，所有的副作用都在进入下一步之前发生。</p><p>在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。</p><p>完整表达式：这个表达式不是另外一个更大表达式的子表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (guests++ &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, guests);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此段代码在运行打印函数之前，guests变量就已经递增了，后缀++只是保证了guests是在完成了与10的比较之后才进行递增。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = （<span class="number">4</span> + x++）+ （<span class="number">6</span> + x++）;</span><br></pre></td></tr></table></figure><p>这个式子就会引发歧义，因为4 + x++ 不是一个完整的表达式，所以C无法保证在子表达式求值之后立马递增x，应当避免编写类似的语句。</p><h2 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h2><p>复合语句：用花括号括起来的一条或多条语句，也称为块。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index++ &lt; <span class="number">10</span>)</span><br><span class="line">sam = <span class="number">10</span> * index + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sam = %d\n&quot;</span>, sam);</span><br><span class="line"><span class="comment">//代码2</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index++ &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">sam = <span class="number">10</span> * index + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sam = %d\n&quot;</span>, sam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然看上去就只差了一对花括号，但是效果却是天差地别。</p><p>代码1：while循环结束之后，printf（）函数只会被调用一次。</p><p>代码2：花括号的存在确保了两条语句都是循环的一部分，每次循环都会执行一次printf（）函数。</p><p>总的来说：</p><p>表达式：由运算符和运算对象组成，最简单的表达式是不带运算符的一个常量或变量。</p><p>语句：主要分为简单语句和复合语句，简单语句就是以一个分号结尾；复合语句是由花括号括起来的一条或者多条语句构成。</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>一般来说，在语句和表达式中应当使用类型相同的变量和常量，若是我们使用混合类型，C语言会采用自己的一套规则进行自动的类型转换，我们应当对此做出了解。</p><p>规则：</p><p>1.当类型转换出现在表达式中时，无论是无符号还是有符号的char或short都会被自动转成int，如有必要会被转换成无符号整型，这些都是从较小类型转换成较大类型，一般被称为升级。</p><p>2.涉及两种类型的运算，两个值一般会被转换成两种类型的更高级别。</p><p>3.类型的级别从高到低依次是是long double、double、float、unsignedlong<br>long、long long、unsigned long、long、unsigned int、int。short和char类型已经被升级为int或者unsigned int了。</p><p>4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型，可能会导致降级。</p><p>5.当作为函数参数传递时，char和short会被自动转换成int，float会被自动转换成为double。</p><p><strong>Tip：一般来说升级不会导致问题，类型降级才会引发一系列的问题。</strong></p><p>若是待转换的值与目标类型不匹配时有以下规则：</p><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256。</p><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> fl;</span><br><span class="line">    </span><br><span class="line">    fl = i = ch = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c, i = %d, fl = %2.2f\n&quot;</span>,ch ,i, fl);</span><br><span class="line">    ch = ch + <span class="number">1</span>;</span><br><span class="line">    i = fl + <span class="number">2</span> * ch;</span><br><span class="line">    fl = <span class="number">2.0</span> * ch + i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %c, i = %d, fl = %2.2f\n&quot;</span>,ch ,i ,fl);</span><br><span class="line">    ch = <span class="number">1107</span>;</span><br><span class="line">    pritnf(<span class="string">&quot;Now ch = %c\n&quot;</span>,ch);</span><br><span class="line">    ch = <span class="number">80.89</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now ch = %c\n&quot;</span>,ch);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h2><p>一般来说，我们应当避免自动类型转换，尤其是类型降级；但是小心使用，类型转换也是很方便的，前面提到的类型转换都是自动完成的。有时候，我们需要精确的类型转换，我们就需要用到强制类型转换（cast），即在某个量前置圆括号括起来的类型名。</p><p>通用形式：（type），type就是我们需要更改的类型名。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mice = <span class="number">1.6</span> + <span class="number">1.7</span>; <span class="comment">//mice是int类型</span></span><br><span class="line">mice = (<span class="type">int</span>)<span class="number">1.6</span> + (<span class="type">int</span>)<span class="number">1.7</span>; <span class="comment">//根据程序的需要来做取舍。</span></span><br></pre></td></tr></table></figure><p><strong>Tip：一般来说，不应该使用混合类型，偶尔这样做也是有用的，也需要我们自己来承担后果。</strong></p><p>总结运算符：</p><p>赋值运算符：</p><p>&#x3D; 将其右侧的值赋给左侧的变量</p><p>算术运算符：</p><p>+将其左侧的值与右侧的值相加</p><p>-将其左侧的值减去右侧的值</p><p>-作为一元运算符，改变其右侧值的符号</p><p>*将其左侧的值乘以右侧的值</p><p>&#x2F;  将其左侧的值除以右侧的值，如果两数都是整数，计算结果将被截断</p><p>% 当其左侧的值除以右侧的值时，取其余数（只能应用于整数）</p><p>++ 对其右侧的值加1（前缀模式），或对其左侧的值加1（后缀模式）</p><p>– 对其右侧的值减1（前缀模式），或对其左侧的值减1（后缀模式）</p><p>其他运算符：</p><p>sizeof 获得其右侧运算对象的大小（以字节为单位），运算对象可以是一个被圆括</p><p>号括起来的类型说明符，如sizeof(float)，或者是一个具体的变量名、数组名等如</p><p>sizeof foo。</p><p>(类型名) 强制类型转换运算符将其右侧的值转换成圆括号中指定的类型，如(float)9</p><p>把整数9转换成浮点数9.0。</p><h1 id="带参数的函数"><a href="#带参数的函数" class="headerlink" title="带参数的函数"></a>带参数的函数</h1><p>带参数的函数应当是比较熟悉了，为了之后自己编写函数，我们需要进一步学习。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pound</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> times = <span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">6.0f</span>;</span><br><span class="line">    </span><br><span class="line">    pound(times);</span><br><span class="line">    pound(ch);</span><br><span class="line">    pound(f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pound</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305211501043.png"></p><p>最终的结果</p><p>我们可以看到在函数头出现的是（int n），这就说明该函数是要接受整型参数，参数名应当遵循C语言的命名规则。</p><p>在声明参数的过程中就创建了形式参数的变量，在该例中，形式参数就是整型变量n，我们称函数调用传递的值为实际参数，简称为实参，函数在调用时就是把实参的值拷贝给了形参n。</p><p><strong>Tip：实参和形参，形参是变量，实参是函数调用提供的值，实参被赋给相应的形参，另外变量名是函数私有的，若是使用times代替pound中的n，对后续使用整型变量times也不会产生影响，最好不要这样做。</strong></p><p>从pound（）函数的原型说明了两点：</p><p>1.该函数没有返回值（<strong>函数名前面有void关键字</strong>）</p><p>对void关键字的解释详见</p><p><a href="https://blog.csdn.net/m0_69909682/article/details/128485569">C语言学习之void关键字_void是c语言关键字吗_忆梦初心的博客-CSDN博客</a></p><p>简单点说就是void前置表示函数可以没有return 0；这句话，若是void出现在参数位置，则说明函数是没有参数传入的。</p><p>2.该函数有一个int类型的参数。</p><p>现在函数声明越来越规范，但是以前的版本可以不用指明参数类型，所以C语言中还存在着void pound（）；这样的函数声明形式，但是这种形式在使用在pound（f）会出现错误，float会被升级为double，虽然能运行，但是输出结果不正确，这个时候只能使用pound（（int）f）；可以解决。</p><h1 id="实例程序"><a href="#实例程序" class="headerlink" title="实例程序"></a>实例程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S_PER_M = <span class="number">60</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S_PER_H = <span class="number">3600</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> M_PER_K = <span class="number">0.62137</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> distk, distm;</span><br><span class="line">    <span class="type">double</span> rate;</span><br><span class="line">    <span class="type">int</span> min, sec;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="type">double</span> mtime;</span><br><span class="line">    <span class="type">int</span> mmin, msec;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This program converts your time for a metric race to a time for running a mile and to your average speed in miles per hour.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter, in kilometers, the distance run.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;distk);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Next enter the time in minutes and seconds.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Begin by entering the minutes.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;min);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now enter the seconds.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sec);</span><br><span class="line">    </span><br><span class="line">    time = S_PER_M * min + sec; </span><br><span class="line">distm = M_PER_K * distk; </span><br><span class="line">rate = distm / time * S_PER_H;</span><br><span class="line">mtime = (<span class="type">double</span>) time / distm; </span><br><span class="line">mmin = (<span class="type">int</span>) mtime / S_PER_M; </span><br><span class="line">msec = (<span class="type">int</span>) mtime % S_PER_M;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You ran %1.2f km (%1.2f miles) in %d min, %d</span></span><br><span class="line"><span class="string">sec.\n&quot;</span>, distk, distm, min, sec);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;That pace corresponds to running a mile in %d</span></span><br><span class="line"><span class="string">min, %d sec.\n&quot;</span>, mmin, msec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your average speed was %1.2f mph.\n&quot;</span>, rate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202305211607417.png"></p><p>最后所呈现的效果。</p><h1 id="关键概念和小结"><a href="#关键概念和小结" class="headerlink" title="关键概念和小结"></a>关键概念和小结</h1><p>在C语言的环境中有大量的运算对象的优先级和结合律，主要是在共享一个运算对象时需要注意。</p><p>虽然C语言允许编写混合数值的表达式，尽管如此，不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样可以避免出现不必要的类型转换。</p><p>一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个<br>运算对象的运算符（如负号和 sizeof）称为一元运算符，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为二元运算符。</p><p>在C语言中，许多类型转换都是自动进行的。当char和short类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为int类型；float类型在函数参数中时，会被升级为double类型。</p><p>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。</p><p>到此就结束了对运算符、表达式和语句相关知识的介绍，下一篇将具体学习C语言的控制语句：循环。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-系统管理命令</title>
      <link href="/2023/04/24/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/04/24/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中我们总结了处理文件和目录的指令学习，接下来我们来对Linux的系统管理命令展开学习，这也是我们在开始脚本编程之前需要学习的，如何通过命令行的命令来探查系统内部信息。</p><h1 id="监测程序"><a href="#监测程序" class="headerlink" title="监测程序"></a>监测程序</h1><p>在Linux系统中最复杂的任务就是跟踪已经在运行的程序，如何探查？</p><h2 id="探查进程"><a href="#探查进程" class="headerlink" title="探查进程"></a>探查进程</h2><p>当程序在Linux系统运行时，我们称之为进程（process）。</p><p>命令：ps </p><p>功能：输出运行在系统上的所有程序的许多信息。</p><p>缺点：稳健而带来的就是复杂性，参数过多（详见man ps），只能显示特定时间点的信息。</p><p>默认情况下：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300049523.png"></p><p>例子解析：输出显示了程序的进程ID（process ID，PID），运行的终端（TTY），进程已使用的CPU时间。</p><p><strong>Tip：ps 命令叫人头疼的地方在于它曾经有两个版本。每个版本都有自己的命令行参数集，这些参数控制着输出什么信息以及如何显示。最近，Linux开发人员已经将这两种ps命令格式合并到了单个ps命令中。</strong></p><p>Linux系统主要支持3种类型的命令行参数：</p><p>1.Unix风格的参数，前面加破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300057824.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300058087.png"></p><p>一般来说，我们并不需要记住所有的参数，常用的是ps -ef ；ps -l 这两个命令。</p><p>2.BSD风格的参数，前面不加破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300105635.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304300107591.png"></p><p>如上所示，Unix和BSD类型的参数有很多重叠的地方。使用其中某种类型参数得到的信息也同样可以使用另一种获得。大多数情况下，你只要选择自己所喜欢格式的参数类型就行了。</p><p>3.GNU风格的参数，前面是双破折线</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301344251.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301345346.png"></p><p>在GNU长参数中一个着实让人喜爱的功能就是–forest参数。它会显示进程的层级信息，并用ASCII字符绘出可爱的图表。如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301346827.png"></p><p>以上就是对三种风格的参数的简单介绍，我们只需要记住常用的几个命令即可。</p><p>ps -ef 所展示的扩展的信息包含以下几个方面：</p><p>UID：启动这些进程的用户。<br>PID：进程的进程ID。<br>PPID：父进程的进程号（如果该进程是由另一个进程启动的）。<br>C：进程生命周期中的CPU利用率。<br>STIME：进程启动时的系统时间。<br>TTY：进程启动时的终端设备。<br>TIME：运行进程需要的累计CPU时间。<br>CMD：启动的程序名称。</p><p>ps -l 指令多出的那些列：</p><p>F：内核分配给进程的系统标记。<br>S：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止）。<br>PRI：进程的优先级（越大的数字代表越低的优先级）。<br>NI：谦让度值用来参与决定优先级。<br>ADDR：进程的内存地址。<br>SZ：假如进程被换出，所需交换空间的大致大小。<br>WCHAN：进程休眠的内核函数的地址。</p><h2 id="实时监测进程"><a href="#实时监测进程" class="headerlink" title="实时监测进程"></a>实时监测进程</h2><p>ps命令虽然在收集运行在系统的进程信息时非常有用，缺点如上所述，为了解决特定时间点的问题，另一个命令就刚好合适：</p><p>命令：top</p><p>功能：实时显示进程信息</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301358009.png"></p><p>总体来说和ps命令并没有太大的不同，只是从特定时间点变成了实时。在默认情况下，top命令在启动的时候会按照使用CPU时间比例进行排序，键入f允许你选择对输出进行排序的字段，键入d允许你修改轮询间隔。键入q可以退出top。</p><p>当我们找到了占用系统大部分资源的进程之后，我们就要开始结束这些进程了。</p><h2 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h2><p>接上节所讲，作为系统的管理员，我们应该具备何时以及如何结束一个进程，在Linux进程中大多数是通过信号来通信：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301412584.png"></p><p>命令：kill </p><p>功能：该命令可以通过PID给进程发出信号终止进程。</p><p>缺点：默认情况下，kill会向命令行发送一个TERM信号，只能使用PID而不是命令名。</p><p>TERM信号告诉进程尽可能停止，若是有不服管教的进程需要我们强制终止，可以使用 -s 参数。若是要检查是否有效，可以再次运行ps 和 top 命令。</p><p>命令：killall</p><p>功能：该命令可以通过进程名而不是PID来结束进程，也支持通配符，在系统因为负载过大而变慢时很有用。</p><p>命令：kill -9 进程ID</p><p>功能：强制结束该进程。</p><h1 id="监测磁盘空间"><a href="#监测磁盘空间" class="headerlink" title="监测磁盘空间"></a>监测磁盘空间</h1><p>系统管理员的另一个重要任务就是要监测系统磁盘的使用情况（也就是空间）。在Linux系统上有几个命令行命令用来帮助存储媒体：</p><h2 id="挂载存储媒体"><a href="#挂载存储媒体" class="headerlink" title="挂载存储媒体"></a>挂载存储媒体</h2><p>在文件管理中曾介绍Linux文件系统将所有的磁盘都并入一个虚拟目录下，在使用新的存储媒体之前需要把它放在虚拟目录下，这就叫做挂载。</p><p>现在大多数的系统都能自动挂载，若是用的发行版不支持自动挂载，就必须手动挂载了。</p><p>命令：mount</p><p>功能：挂载媒体，默认情况下也可以用来显示挂载的设备列表</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301427346.png"></p><p>mount命令主要提供四部分信息：</p><p>1.媒体的设备文件名</p><p>2.媒体挂载到虚拟目录的挂载点</p><p>3.文件系统类型</p><p>4.已挂载媒体的访问状态</p><p>手动挂载设备，需要以root用户登录，或者是以root用户运行sudo命令</p><p>手动命令：mount -t type device directory</p><p>type参数指定了磁盘被格式化的文件系统类型。</p><p><strong>Tip：手动挂载的磁盘要先格式化才能进行挂载。</strong></p><p>mount命令的参数：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301444408.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301444867.png"></p><p>命令：umount</p><p>功能：从Linux系统上移除一个可移动设备，就要先卸载。</p><p>实际格式：umount  [directory | device]</p><p>若是有任何程序正在使用设备上的文件，系统是不会允许我们卸载它。</p><h2 id="df命令的使用"><a href="#df命令的使用" class="headerlink" title="df命令的使用"></a>df命令的使用</h2><p>学习挂载之后，我们需要查看设备还剩余多少的磁盘空间，df命令就显得很方便。</p><p>命令：df</p><p>功能：显示每个有数据的已挂载文件系统。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301504380.png"></p><p><strong>Tip：Linux系统后台一直有进程来处理文件或使用文件。df命令的输出值显示的是Linux系统认为的当前值。有可能系统上有运行的进程已经创建或删除了某个文件，但尚未释放文件。这个值是不会算进闲置空间的。</strong></p><h2 id="du命令的使用"><a href="#du命令的使用" class="headerlink" title="du命令的使用"></a>du命令的使用</h2><p>df命令只能告诉我们宏观的磁盘的存储空间，并不能告诉我们细分的文件或者特定的目录，这个时候就要用到du命令来显示具体的占用的空间的文件。</p><p>命令：du</p><p>功能：显示当前目录下的所有文件和目录。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301621919.png"></p><p>du命令的几个参数：</p><p>-c：显示所有已列出文件总的大小。<br>-h：按用户易读的格式输出大小，即用K替代千字节，用M替代兆字节，用G替代吉字节。<br>-s：显示每个输出参数的总计。</p><p>在我们查看了具体的文件之后就是要对它们使用文件处理命令进行处理。</p><h1 id="处理数据文件"><a href="#处理数据文件" class="headerlink" title="处理数据文件"></a>处理数据文件</h1><p>结合上节所述，当我们有大量的数据时，一般来说很难提取到有用的信息，但是Linux系统提供了命令行工具来处理大量的数据，这些命令可以帮助我们更好的应对。</p><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p>命令：sort</p><p>功能：sort命令是对数据进行排序的。默认情况下，sort命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301630992.png"></p><p>缺点：默认情况下，sort命令会把数字当做字符来执行标准的字符排序，产生的输出可能根本就不是你要的。解决这个问题可用-n参数。</p><p>另一个常用的参数是 -M，按月排序，Linux的日志中经常会有时间戳来表明事件是什么时候发生的。</p><p>其他参数：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301636268.png"></p><p><strong>Tip：管道命令（|）将du命令的输出重定向到sort命令。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301643408.png"></p><h2 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h2><p>在海量的数据背景下，我们通常需要在大文件中找到一行或几行数据即可，这个时候我们就需要搜索数据了。</p><p>命令：grep  pattern  file</p><p>功能：在文件中查找数据。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301650375.png"></p><p>若是要进行反向搜索，加入参数 -v 即可。</p><p>显示匹配模式的行的行号，加入 -n 参数即可。</p><p>若想知道有多少行含有匹配模式，加入参数 -c 。</p><p>若要指定多个匹配模式，可使用 -e 模式。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301653653.png"></p><p><strong>Tip：在默认模式下，也可使用正则表达式来定义查找匹配的模式。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301655071.png"></p><h2 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h2><p>在windows系统中我们经常使用的压缩文件就是zip文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301700599.png"></p><p><strong>Tip：compress文件压缩已经很少在Linux系统中见到了，基本现在都是使用gzip。</strong></p><p>命令：gzip；gzcat；gunzip</p><p>功能：压缩文件；查看压缩文件的内容；解压文件。</p><p>缺点：该命令只能压缩一个文件，不能将多个文件压缩进一个压缩包。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301703112.png"></p><p>gzip命令可以一次性指定多个文件名，也可以使用通配符来一次性批量压缩文件。</p><h2 id="归档数据"><a href="#归档数据" class="headerlink" title="归档数据"></a>归档数据</h2><p>为了解决压缩数据中不能同时压缩多个文件的缺点，还有另外的命令来解决这个问题。</p><p>命令：tar function [options] objects1 objects2</p><p>功能：能将多个文件在磁带设备中归档到一个文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301713823.png"></p><p><strong>Tip：文件名以.tgz结尾。这些是gzip压缩过的tar文件可以用命令tar -zxvf filename.tgz来解压。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304301718385.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此篇博客是学完系统管理之后一些要点的总结，下一篇将是对Linux shell及其使用。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-字符串的格式化输入输出</title>
      <link href="/2023/04/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2023/04/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在总结完数据类型之后，我们就开始对printf（）和scanf（）中都有的格式化字符串进行学习和探讨。</p><h1 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h1><p>字符串是一个或多个字符的序列，一般使用双引号将内容括起来，正如单引号对于字符一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Zing went the strings of my heart!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="char类型数组和null字符"><a href="#char类型数组和null字符" class="headerlink" title="char类型数组和null字符"></a>char类型数组和null字符</h2><p>在C语言中没有专门用于储存字符串的变量类型，一般被储存在char类型的数组中，每个单元储存一个字符。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304191340852.png"></p><p>上述数组的末尾的字符\0，这是空字符（null字符），C语言用它标记字符串的结束，空字符不是数字0，它是非打印字符，其ASCII码值是0。C的字符串一定是以空字符结束，也就是说数组的容量至少要比存储字符串的字符数多一。</p><p>数组：一行连续的多个储存单元，同类型数据元素的有序序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">40</span>];</span><br></pre></td></tr></table></figure><p>char是声明变量的数据类型，name是数组的名字，方括号表明这是一个数组，40则是说明该数组的数量。</p><h2 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h2><p>转换说明：%s</p><p>我们不需要把空字符放到字符串结尾，scanf（）在读取输入时就已经完成这项工作了，编译器也会在末尾加上空字符。</p><p><strong>Tip：scanf（）只会读取连续的字符，从第一个非空白字符起到空白字符结束。下面将会进行详尽阐述</strong></p><p>字符串和字符的区别：”x” 和 ‘x’ 就是不一样的，前者是char数组，后者是char类型；前者在末尾还有空字符，而后者则没有。</p><h2 id="Strlen（）函数"><a href="#Strlen（）函数" class="headerlink" title="Strlen（）函数"></a>Strlen（）函数</h2><p>在数据类型的博客中我们介绍了一个sizeof运算符，它以字节为单位给出对象的大小。strlen（）函数给出字符串的字符长度，因为一个字节储存一个字符，但其实这两种方法应用字符串的结果并不相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRAISE <span class="string">&quot;You are an extraordinary being.&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">40</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK, %s.%s\n&quot;</span>, name, PRAISE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your name of %zd letters occupies %zd memory cells.\n&quot;</span>, <span class="built_in">strlen</span>(name), <span class="keyword">sizeof</span>(name));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The phrase of praise has %zd letters &quot;</span>, <span class="built_in">strlen</span>(PRAISE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;and occpies %zd memory cells.\n&quot;</span>, <span class="keyword">sizeof</span>(PRAISE));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序中 sizeof 运算符报告name数组有40个存储单元，但是只有前11个用来存储，所以strlen（）得出的结果是11。一般来说 sizeof 运算符给出的数更大，因为它要把字符串末尾的空字符也计算在内。</p><p><strong>Tip：sizeof 运算符使用圆括号的场景，取决于运算对象是类型还是特定量。运算对象是类型，则必不可少；若是特定量则可以省略，但还是建议在所有情况加上（）。</strong></p><h1 id="常量和预处理器"><a href="#常量和预处理器" class="headerlink" title="常量和预处理器"></a>常量和预处理器</h1><p>在程序中，我们使用一个常量一般都是直接键入，虽然无需声明，但是不够好，我们可以使用符号常量。一般使用符号常量有两种方法：</p><p>1.声明一个变量，给变量赋予所需的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> tax;</span><br><span class="line">tax = <span class="number">0.015</span>;</span><br></pre></td></tr></table></figure><p>虽然这样做提供了一个符号名，但是 tax 本质是一个变量，复杂的程序在运行中可能会无意改变它的值。</p><p>2.C预处理器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAX 0.015</span></span><br></pre></td></tr></table></figure><p>在前面博客介绍过预处理器是如何使用 #include 包含其他文件信息，但同时预处理器也可以用来定义常量。</p><p>通用格式：#define <em>NAME</em>  <em>value</em></p><p>#define 指令还可以定义字符和字符串常量，前者单引号，后者双引号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define BEEP &#x27;\a&#x27;</span><br><span class="line">#define TEE &#x27;T&#x27;</span><br><span class="line">#define ESC &#x27;\033&#x27;</span><br><span class="line">#define OOPS &quot;Now you have done it!&quot;</span><br></pre></td></tr></table></figure><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p>在C90标准中新增了const关键字，用于限定一个变量为只读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>num 这个值成为一个只读值，不能更改。</p><p><strong>Tip：const 定义的是一个只读变量，而不是常量。</strong></p><p>后面的博客再来详细介绍。</p><h2 id="明示常量"><a href="#明示常量" class="headerlink" title="明示常量"></a>明示常量</h2><p>C头文件limits.h 和 floar.h 分别提供了整数类型和浮点类型大小限制相关的详细信息。</p><p>在limits.h头文件中包含以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MAX +32767</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_MIN -32768</span></span><br></pre></td></tr></table></figure><p>下表是limits.h中一些明示常量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201515931.png"></p><p>类似的，下表是一些float.h中的一些明示常量：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201519224.png"></p><h1 id="printf（）和scanf（）"><a href="#printf（）和scanf（）" class="headerlink" title="printf（）和scanf（）"></a>printf（）和scanf（）</h1><p>这个两个函数对于C语言学习者来说并不陌生，一个输入函数，一个输出函数；工作原理几乎相同，都是使用格式化字符串和参数列表。</p><h2 id="printf（）函数"><a href="#printf（）函数" class="headerlink" title="printf（）函数"></a>printf（）函数</h2><p>在请求printf（）函数打印数据的指令要与待打印数据的类型相匹配。打印整数使用%d，打印字符要用%c，这些符号被称为转换说明：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201529890.png"></p><h2 id="printf（）函数的使用"><a href="#printf（）函数的使用" class="headerlink" title="printf（）函数的使用"></a>printf（）函数的使用</h2><p>打印输出函数的使用就需要在这里赘述了，简单说一下格式即可：</p><p>格式：printf（格式化字符串，待打印项1，待打印项2，…）;</p><p>其中待打印项1等都是需要打印的，它们可以是变量，常量，甚至是打印之前要计算的表达式，前提是格式化字符串应当包含每个待打印项对应的转换说明；数量和类型都要对应。</p><p>若是只打印短语或句子，就不需要使用任何转换说明；如果只打印数据，也不用加入说明文字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c%d\n&quot;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="number">2</span> * cost);</span><br></pre></td></tr></table></figure><p><strong>Tip：由于%在printf（）函数中拿来标识转换说明了，因此打印%符号就需要用别的方法，然而我们之前有使用过 \ （反斜杠）的转义字符来表示符号，但在这里并不适用，我们只需要使用%%即可。</strong></p><h2 id="printf（）的转换说明修饰符"><a href="#printf（）的转换说明修饰符" class="headerlink" title="printf（）的转换说明修饰符"></a>printf（）的转换说明修饰符</h2><p>在%和转换字符之间插入修饰符可以修饰基本的转换说明，下面列出一些可作为修饰符的合法字符，若要同时插入多个字符，也得与下表顺序相同。（并非所有的组合都可行）</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201600738.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201602465.png"></p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGES 959</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%2d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10d*\n&quot;</span>, PAGES);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%-10d*\n&quot;</span>, PAGES);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展示的是对于字段宽度以及修饰符的作用。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304201614801.png"></p><p>上面是对于整型来说的，下面我们看看对于浮点型来说，修饰符又有那些作用呢:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> RENT <span class="number">3852.99</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%e*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%4.2f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%3.1f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10.3f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%10.3E*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%+4.2f*\n&quot;</span>, RENT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*%010.2f*\n&quot;</span>, RENT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序输出结果如下所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304211740883.png"></p><p>该程序中使用了const 关键字，限定变量为只读。</p><p>第一个转换说明%f ，在这种情况下，字段宽度和小数点后面的位数均为系统默认设置，小数点后打印6位数字。</p><p>第二个转换说明%e 无需过多的赘述，在数据类型的博客中有详细讲解。</p><p>第四个和第六个例子分别对输出结果进行四舍五入。</p><p>第七个转换说明中包含了+标记，这使得打印的值前面多了一个代数符号；最后一个转换说明的 0 标记使得打印的值前面用 0 填充来满足字段的要求。</p><p>剩下的一些其他格式的数据在这里就不逐个展示了。</p><p><strong>Tip：在整型数据中使用精度（%5.3d）生成足够的前导0 用来满足最小位数的要求，若是精度和 0 同时出现，0 标记会被忽略。</strong></p><p>对于字符串格式来说：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLURB <span class="string">&quot;Authentic imitation&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%2s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%24s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%24.5s]\n&quot;</span>, BLURB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%-24.5s]\n&quot;</span>, BLURB);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然第一个转换说明是%2s ，但是字段会被扩大为可容纳所有字符的格式，另 . 5是告诉打印函数只打印5个字符，- 号则是使得文本左对齐输出。</p><h2 id="转换说明的意义"><a href="#转换说明的意义" class="headerlink" title="转换说明的意义"></a>转换说明的意义</h2><p>在介绍了这么多转换说明和修饰符之后，我们应该深入了解一下转换说明的存在意义，实际上转换说明就是把电脑中存储的二进制格式的值转换成我们所需的一系列字符。转换本质上是翻译说明，而非替换；无论输出格式如何多种多样，数据存储的方式都只有二进制一种。</p><p>转换说明会碰到的问题：</p><h3 id="1-转换不匹配："><a href="#1-转换不匹配：" class="headerlink" title="1.转换不匹配："></a>1.转换不匹配：</h3><p>通常我们打印一个 int 类型的值，我们可以使用%d ，%x ，%o ，类似的，打印float 类型的值，我们可以使用%f ，%e ，%g 。</p><p>在这个转换说明中可以着重看一下原码，反码和补码的概念，但是我们同样需要注意%u 不会把数字和符号进行区分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGES 336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORDS 65618</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">short</span> num = PAGES;</span><br><span class="line"><span class="type">short</span> mnum = -PAGES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num as short and unsigned short: %hd %hu\n&quot;</span>, num,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-num as short and unsigned short: %hd %hu\n&quot;</span>, mnum,mnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num as int and char: %d %c\n&quot;</span>, num, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;WORDS as int, short, and char: %d %hd %c\n&quot;</span>,WORDS,WORDS,WORDS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码说的都是整型数据中的错误，若是错误出现在浮点型中时，出现的结果会更令人意想不到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> n1 = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">double</span> n2 = <span class="number">3.0</span>;</span><br><span class="line"><span class="type">long</span> n3 = <span class="number">2000000000</span>;</span><br><span class="line"><span class="type">long</span> n4 = <span class="number">1234567890</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1e %.1e %.1e %.1e\n&quot;</span>, n1, n2, n3, n4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld %ld\n&quot;</span>, n3, n4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld %ld %ld %ld\n&quot;</span>, n1, n2, n3, n4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行中除了n1和n2两个值之外，n3和n4这两个值输出都并不正常，这里我们就需要说到在printf（）函数中，float类型（4位字节）会变成double类型（8位字节）进行输出，使用%e 打印long类型（4位字节），除了查看本身的4位之外，还会额外查看相邻的4位字节，共同组成解释浮点数。即使n3 位数正确，最终得到的结果也是无意义的值。</p><p>在第三行中输出显示，printf（）函数即使使用正确的转换说明也可能会生成虚假的结果，其中的问题就出在了C语言的信息传递过程中。参数传递过程会因为系统和编译器的实现方式而出现变化。</p><p>上面程序的第三句输出，n1是作为double类型存储到栈的内存区域占8位字节，n2 同样也是占8位，n3 和 n4 各自占据了4位字节，然后才是函数根据不同的转换说明进行数据的读取，%ld 说明应该读取4个字节，然而前4个字节是n1 的前半部分，这样的读取就出现错误。n2 则是读取了n1 的后半部分。虽然用对了转换说明，却读不出正确的值。</p><p><strong>Tip：从这里可以看出计算机其实非常的死板，只能按部就班的完成指令</strong></p><h3 id="2-printf（）的返回值："><a href="#2-printf（）的返回值：" class="headerlink" title="2.printf（）的返回值："></a>2.printf（）的返回值：</h3><p>在C语言起始那篇博客中，我们介绍过大部分C语言函数都会有一个返回值，这是函数计算并且返回给主调程序的值，总之程序中可以把返回值像其他值一样使用。printf（）的返回值是函数打印之后的附带用途，一般很少用的到，一般是检查错误用到比较多。（写入文件的时候比较常用），若是一张CD拒绝写入时，程序采取相应的行动。要实现需要先了解 if 语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bph2o = <span class="number">212</span>;</span><br><span class="line"><span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">    rv = <span class="built_in">printf</span>(<span class="string">&quot;%d F is water&#x27;s boiling point.\n&quot;</span>, bph2o);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The printf() function printed %d characters.\n&quot;</span>,</span><br><span class="line">rv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序就展示了printf（）在正常运行时的返回值。计算了所有的字符数包括空格和不可见的换行符。</p><h3 id="3-打印较长的字符串"><a href="#3-打印较长的字符串" class="headerlink" title="3.打印较长的字符串"></a>3.打印较长的字符串</h3><p>在打印字符串时，我们经常会碰到较长的语句，在屏幕上不方便阅读，若是有空格、制表符、换行符等用于分隔不同的部分，C编译器会忽略他们，所以一条语句可以写成很多行，在不同部分之间输入空白即可。</p><p><strong>Tip：切记不能在双引号括起来的字符串中间断行，会产生报错。</strong></p><p>给字符串断行的三种方法：</p><p>1.我们可以使用多个printf（）语句，因为第一个字符串没有以\n字符结束，所以第二个字符串会紧跟第一个字符串的末尾。</p><p>2.用反斜杠（\）和Enter键组合的方式来断行，这使得光标移到下一行，而且字符串不会包含换行符。</p><p>3.ANSI C 引入的字符串连接，在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作一个字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s one way to print a &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;long string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s another way to print a \</span></span><br><span class="line"><span class="string">long string.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s the newest way to print a &quot;</span></span><br><span class="line"><span class="string">&quot;long string.\n&quot;</span>); <span class="comment">/* ANSI C */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231633510.png"></p><h2 id="scanf（）的使用"><a href="#scanf（）的使用" class="headerlink" title="scanf（）的使用"></a>scanf（）的使用</h2><p>结束了printf（）函数的学习，接下来介绍一下scanf（）函数，C语言库中包含很多的输出函数，scanf（）是其中最通用的一个，因为它可以读取不同格式的数据，但是从键盘输入的都是文本字符：字母，数字和标点符号，要把字符依次转换成数值就是scanf（）函数需要做的事情，与printf（）所做的事情正好相反。</p><p><strong>Tip：printf（）整数、浮点数、字符串–&gt; 文本</strong></p><p>​           <strong>scanf（） 文本 –&gt; 整数、浮点数、字符串</strong></p><p>这两个函数的核心本质都是格式化字符串。</p><p>scanf（）函数中用的最多的是指向变量的指针，关于指针的内容后续再详细介绍，这里我们只需要知道两条规则：</p><p>1.如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;。</p><p>2.如果用scanf()把字符串读入字符数组中，不要使用&amp;。</p><p>示例程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> age; <span class="comment">// 变量</span></span><br><span class="line"><span class="type">float</span> assets; <span class="comment">// 变量</span></span><br><span class="line"><span class="type">char</span> pet[<span class="number">30</span>]; <span class="comment">// 字符数组，用于储存字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your age, assets, and favorite pet.\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %f&quot;</span>, &amp;age, &amp;assets); <span class="comment">// 这里要使用&amp;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, pet); <span class="comment">// 字符数组不使用&amp;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d $%.2f %s\n&quot;</span>, age, assets, pet);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面包含了整型、浮点型和字符串三个数据类型。</p><p><strong>Tip：在scanf（）函数中唯一的例外是%c 转换说明，根据%c ，scanf（）会读取每个字符，包括空白。</strong></p><p>scanf（）函数所用的转换说明与printf（）函数几乎相同，主要的区别是对于float类型和double类型，printf（）都使用%f ，%e ，%g。而scanf（）函数仅仅把这几个用于float类型，对于double类型需要加上l 修饰符。</p><p>具体的转换说明如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231700976.png"></p><p>修饰符如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231702651.png"></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304231702338.png"></p><p><strong>Tip：若要同时使用多个修饰符需要严格按照修饰符的顺序。</strong></p><h3 id="从scanf（）看输入"><a href="#从scanf（）看输入" class="headerlink" title="从scanf（）看输入"></a>从scanf（）看输入</h3><p>scanf（）函数读取输入若是%d ，一开始会跳过所有的空白字符，直至遇到第一个非空白字符才开始读取，若是遇到数字或符号，继续读取，若还是数字继续，反之暂停。然后会把非数字字符返回给输入，也意味着下次读取会是上次丢弃的字符，这点很重要。</p><p>若是%d 遇到第一个非空白字符是A而不是数字，那么scanf（）函数就会一直卡在第一个转换说明这里。若是多个转换说明，C语言规定会在第一个出错处停止读取输入。</p><p>如果使用的是%s 转换说明，scanf（）会读取除了空白以外的所有字符。即非空白字符起，空白字符止。</p><p>C语言还有其他的输入函数，如 getchar（）和 fgets（）等。这两个函数更适合特殊的处理情况，未来碰到在详细介绍。</p><h3 id="格式化字符串中的普通字符"><a href="#格式化字符串中的普通字符" class="headerlink" title="格式化字符串中的普通字符"></a>格式化字符串中的普通字符</h3><p>scanf（）函数可以把普通字符放在格式化字符串里，除了空格字符外的普通字<br>符必须与输入字符串严格匹配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;n, &amp;m);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">88</span>,<span class="number">121</span></span><br><span class="line"><span class="number">88</span>, <span class="number">121</span></span><br><span class="line"><span class="number">88</span>,</span><br><span class="line"><span class="number">121</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d ,%d&quot;</span>, &amp;n, &amp;m);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">88</span>,<span class="number">121</span></span><br><span class="line"><span class="number">88</span> ,<span class="number">121</span></span><br><span class="line"><span class="number">88</span> , <span class="number">121</span></span><br></pre></td></tr></table></figure><p>上述代码就是输入一个数字，逗号，一个数字，逗号必须紧跟第一个数字，后面的间隔和空白并没有具体的要求。格式化字符串的空白意味着跳过下一个输入项前面的所有的空白。（所有的空白包括没有空格的情况）。</p><p><strong>Tip：那么对于%c 来说，在格式化字符串中添加一个空格字符会有所不同，如果把空格放到格式化字符串的%c之前，scanf（）会跳过非空白字符。若没有空格，那么会读取空白字符。</strong></p><h3 id="scanf（）的返回值"><a href="#scanf（）的返回值" class="headerlink" title="scanf（）的返回值"></a>scanf（）的返回值</h3><p>scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0。当scanf()检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。</p><h2 id="printf（）和scanf（）的-修饰符"><a href="#printf（）和scanf（）的-修饰符" class="headerlink" title="printf（）和scanf（）的*修饰符"></a>printf（）和scanf（）的*修饰符</h2><p>在这两个函数的修饰符中都有*修饰符，但是作用却完全不同。</p><p>在printf（）中，若是不想预先指定字段宽度，希望通过程序来指定，可以使用* 修饰符来代替字段宽度，但是需要一个参数告诉函数，字段宽度是多少，也就是说转换说明%*d，参数列表应包含 *和d对应的值。这同样适用于浮点数的指定精度和字段宽度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> width, precision;</span><br><span class="line"><span class="type">int</span> number = <span class="number">256</span>;</span><br><span class="line">    <span class="type">double</span> weight = <span class="number">242.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a field width:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;width);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The number is :%*d:\n&quot;</span>, width, number);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now enter a width and a precision:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;width, &amp;precision);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Weight = %*.*f\n&quot;</span>, width, precision, weight);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中程序中的width是字段宽度，number是待打印的数值。</p><p>scanf（）中的用法就和printf（）不同，把* 放在%和转换字符之间时，会使得scanf（）跳过相应的输出项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter three integers:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%*d %*d %d&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The last integer was %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="printf（）用法提示"><a href="#printf（）用法提示" class="headerlink" title="printf（）用法提示"></a>printf（）用法提示</h2><p>在输出时想把数据打印成列，指定固定的字段宽度是很有用的，若是不指定的话，会显得数据显示的很杂乱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, val1, val2, val3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%9d %9d %9d\n&quot;</span>, val1, val2, val3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>         <span class="number">234</span>        <span class="number">1222</span></span><br><span class="line"> <span class="number">4</span>           <span class="number">5</span>          <span class="number">23</span></span><br><span class="line"> <span class="number">6</span>          <span class="number">22</span>          <span class="number">34</span></span><br></pre></td></tr></table></figure><p>这样就会显得整齐不少，在两个转换说明之间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟一起输出。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此我们结束了对于这两个函数的使用包括修饰符等，也对数据类型进行了巩固，下一篇将进入运算符和表达式包括语句的学习。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>故障修复-虚拟机USB口不识别U盘</title>
      <link href="/2023/04/16/%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D-%E8%99%9A%E6%8B%9F%E6%9C%BAUSB%E5%8F%A3%E4%B8%8D%E8%AF%86%E5%88%ABU%E7%9B%98/"/>
      <url>/2023/04/16/%E6%95%85%E9%9A%9C%E4%BF%AE%E5%A4%8D-%E8%99%9A%E6%8B%9F%E6%9C%BAUSB%E5%8F%A3%E4%B8%8D%E8%AF%86%E5%88%ABU%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>前因：在学习Linux系统管理命令时想尝试一下用 mount 命令将U盘挂载到虚拟机中，然而将U盘插入电脑后，虚拟机并无任何反应，开始百度查找原因，基本可以确定是VMware USB Arbitration Service 服务未开启的问题。</p><p>找到疑似原因，就开始尝试修复，首先win + r 键，输入service.msc，回车进入服务，找到上述的USB服务并开启服务，在这里我们遇到了第一个问题：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161433611.png"></p><p>接着在百度上查找原因，大部分说的是AMD主板这类的问题，尝试过后发现效果并不是很理想，本着除根需除净的原则，还是选择将VM虚拟机卸载重装。</p><p>在尝试过程中有个使用exe文件重装修复的方法，尝试之后会出现以下的问题：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161438609.png"></p><p>这也是博主尝试的最后一种方法，实在修不动，选择重装大法了。（当然重装之后还是使用修复的方法对USB接口服务进行修复）</p><p><strong>Tip：VMx86驱动程序的版本不匹配，基本就是以前安装过的VM虚拟机卸载的不干净导致脚本文件产生冲突。</strong></p><p>重装VM虚拟机的过程中，又出现了一个问题：无法安装服务，请确保您有足够的权限安装系统文件。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161442321.png"></p><p>这个问题解决详情可见<a href="https://blog.csdn.net/qq_55868479/article/details/124046593">无法安装服务“VMware Authorization Service” ，请确保您有足够的权限安装系统，如何解决？_神偷克星的博客-CSDN博客</a></p><p>最后博主也是用CCleaner清除干净注册表之后成功安装。</p><p><strong>Tip：在清除注册表之后最重要的一点：重启电脑！重启电脑！重启电脑！</strong></p><p>然而在重新安装完成之后，插入U盘仍然没有任何反应，这时候就可以使用上面修复的手段了：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161449782.png"></p><p>点击修复，再次进入服务启用VMware USB Arbitration Service 服务即可：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161451393.png"></p><p>可以看到该服务已经启动成功了。</p><p>此时我们将U盘插入电脑，就会看到以下画面：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161452158.png"></p><p>圆满修复。</p><p><strong>在这篇博客完成之前，博主Picgo出现图片上传的网络问题，一开始以为是VPN的故障，查完发现Github的token有时长限制，具体修复如下：</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg202304161455368.png"></p><p>将Expiration的期限改为无限制，重新生成令牌即可。</p>]]></content>
      
      
      <categories>
          
          <category> 系统故障 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-数据类型总结</title>
      <link href="/2023/04/14/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/14/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在上一篇博客中我们详细介绍了C语言中的基础数据类型和相关转换说明的原理剖析，那么这一篇博客对数据类型的具体使用作简单介绍和总结。</p><h1 id="使用数据类型"><a href="#使用数据类型" class="headerlink" title="使用数据类型"></a>使用数据类型</h1><p>我们在编写程序的时候，应当注意合理选择所需的变量及其类型，通常来说，使用int或者float类型来选择数字，char类型表示字符。</p><p><strong>Tip：使用变量之前必须先声明，且选择有意义的变量名，若是需要初始化变量，应当与类型匹配。</strong></p><p>声明（初始化）方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> apple = <span class="number">3</span>；<span class="comment">/*正确*/</span></span><br><span class="line"><span class="type">int</span> bananas = <span class="number">4.0</span>;<span class="comment">/*不好的方式*/</span></span><br></pre></td></tr></table></figure><p>若是我们使用一个类型的数值初始化给不同类型的变量的时候，编译器会首先把值转换成与变量匹配的类型，会导致数据错误以及丢失。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cost = <span class="number">12.99</span>;<span class="comment">/*用double类型值初始化整型变量*/</span></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.1415926536</span>;<span class="comment">/*用double类型的值初始化单精度浮点型*/</span></span><br></pre></td></tr></table></figure><p>上述程序cost的值是12，第二个声明会损失一些精度，因为在C语言中只能保证单精度浮点型前6位的精度，一般来说编译器会对这样的初始化产生警报。</p><h1 id="参数和陷阱"><a href="#参数和陷阱" class="headerlink" title="参数和陷阱"></a>参数和陷阱</h1><p>对于printf（）函数的使用主要是需要注意函数中的参数，在格式化字符串中有多少个转换说明，就说明后面需要几个参数，我们需要做的就是确保转换说明数量、类型与后面参数的数量、类型是否一致。</p><p><strong>但是这对于printf（）和scanf（）函数来说并不起作用，因为这两个函数的参数个数是可变的。</strong></p><p>在下一篇博客中会对printf（）和scanf（）这两个函数进行具体的分析，这里就简单的做个说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">7.0f</span>;</span><br><span class="line">    <span class="type">float</span> g = <span class="number">8.0f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n, m);<span class="comment">/*参数太多*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, n);<span class="comment">/*参数太少*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f, g);<span class="comment">/*值的类型不匹配*/</span></span><br><span class="line">    </span><br><span class="line">    retuen <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是基本会出现的多数问题，在编译器中大部分也会有提醒，然而C标准对此并未作出要求，若是程序正常运行，这些细小的错误会很难察觉。</p><h1 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h1><p>对于转义序列来说，我们主要可以看看退格（\b）、水平制表符（\t）、回车（\r）的工作方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\aEnter your desired monthly salary:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; $_______\b\b\b\b\b\b\b&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;salary);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\t$%.2f a month is %.2f a year.&quot;</span>, salary, salary * <span class="number">12.0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\rGee!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的薪资询问系统（简单交互），其中含有许多的转义序列。</p><h2 id="刷新输出"><a href="#刷新输出" class="headerlink" title="刷新输出"></a>刷新输出</h2><p>printf（）函数在什么时候会把输出发送到屏幕上呢？<br>最初，printf（）会把内容发送到缓冲区的中间存储区域，然后缓冲区的内容再不断被发送到屏幕上。在C标准中规定了什么时候把缓冲区的内容发送到屏幕：</p><p>1.缓冲区满</p><p>2.遇到换行字符</p><p>3.需要输入的时候</p><p><strong>Tip：还有一种刷新缓冲区的方法就是使用fflush（）函数。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的char，即unsigned char或signed char。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有short、int、long和long long类型。C规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存0或1，分别代表false和true。</p><p>下一篇博客将对字符串和printf（）、scanf（）两个函数做详细解析。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-文件与目录列表2</title>
      <link href="/2023/04/13/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%952/"/>
      <url>/2023/04/13/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<p>接上篇博客，这篇我们开始讲述Linux命令行中关于文件目录的最后一小点内容–目录。</p><h1 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h1><p>在Linux之中，有许多的命令对文件和目录都有效，而有些只对目录有效，那么首先我们来说说怎么创建一个新的目录：</p><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>命令：mkdir  -  make directories</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413100027.png"></p><p>我们可以使用 ls命令来查看，可以注意到新目录列表是以d开头，这表示New_dir1是一个目录而不是一个文件。</p><p>单一的 mkdir命令只能创建一个一个目录，若是我们想要创建多个目录或者子目录，就需要在命令后加入-p的参数。如果我们在创建目录出现错误或者建错地方，我们又应该如何去删除呢</p><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><p>命令：rmdir   -  remove directories</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413100717.png"></p><p>上图可以看到我在一个目录下又创建了一个目录，我想要删除，延续了rm命令的 -i习惯，但是在 rmdir命令中并没有 -i选项来询问是否要删除目录。</p><p><strong>Tips：在默认的情况下，rmdir命令只能删除空目录，若是目录下含有文件等，rmdir命令是无法执行的。</strong></p><p>虽然rmdir命令只能删除空目录，但是不代表删除目录会有很大的麻烦，我们还可以在非空目录上使用rm命令，使用-r参数使得命令可以向下进入目录，删除其中的文件，删除文件之后并且删除目录。</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413101811.png"></p><p>上图这种方法同样可以向下进入多个子目录，当需要大量删除目录和文件，这一点尤为有效。若是文件达到一定量级这种方法的弊端也随之显现出来，因为我们要确认每一个文件，这时最终的方法就是使用 -r 和 -f 同时使用的rm命令。</p><p><strong>Tip：在使用 rm -rf 命令之前最好先确认操作是否符合预期，务必谨慎使用该指令。</strong></p><h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><p>Linux中还有几个命令可以查看文件的内容，而不需要调用其他的文本编辑器。</p><h2 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h2><p>命令：file （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413102933.png"></p><p>这个命令是一个随手可得的便捷工具，它可以探测文件的内部，并决定文件是什么类型。也可以作为我们区分文件与目录的又一种方法，其次该命令还可以在查询符号链接文件的时候，可以告诉我们它究竟链接到了那个文件上。</p><h2 id="查看整个文件"><a href="#查看整个文件" class="headerlink" title="查看整个文件"></a>查看整个文件</h2><p>若是我们手头有一个很大的文本文件，我们会希望看看里面的内容，在Linux中有三个不同的命令能完成这个任务。</p><p>命令1：cat  (option)</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413103904.png"></p><p>cat命令是显示文本文件中所有数据的得力工具，没有什么特别的内容。还有一些和该命令搭配使用的参数：</p><p>参数：-n </p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413104310.png"></p><p>该参数会给所有的内容的行加上行号。（在检查脚本的时候很有用）</p><p>若是只想给有文本的加上行号可以使用 - b 参数。</p><p>若是不想制表符出现，可以使用 -T 参数。</p><p><strong>Tip：对于大型文件来说，cat命令有些繁琐，文件的文本会一晃而过。下面的命令可以解决这个问题。</strong></p><p>命令2：more  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413105421.png"></p><p>more命令是为了解决cat命令一旦运行，无法控制后面的操作，more命令可以在显示一页数据之后停下来，more命令是分页工具，正如前面提到过的man命令一样，可以通过空格键和回车键逐行浏览文件，浏览完之后按q键退出。</p><p><strong>Tip：不过more命令只支持文本文件最基本的移动，有些高级功能可以使用less命令。</strong></p><p>命令3 ：less  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413110115.png"></p><p>上图就是通过 less 命令进入一个源代码文件。less命令与more命令基本一样，除此之外还包括很多其他的命令集。</p><h2 id="查看部分文件"><a href="#查看部分文件" class="headerlink" title="查看部分文件"></a>查看部分文件</h2><p>上面的命令都是查看完整文件，但其实有些时候我们只需要查看文件的开头或者结尾就满足需求了，这个时候用cat、more或者less就显得没这么便捷了，好在Linux中有两个专用的命令</p><p>命令1：tail  （option）</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413111736.png"></p><p>该命令正如它的名字，会显示文件内容的最后几行的内容。在系统默认情况下，它会显示文件的末尾10行。</p><p>参数：-n  number</p><p>在-n后面加上想要的行数就可以指定该命令的显示行数了。</p><p>参数：-f</p><p>该参数是tail命令的一个突出特性，该参数允许我们在其他进程使用该文件的时候查看文件的内容，tail命令会保持不断活动的状态，这是实时监测系统日志的良好方法。</p><p>命令2：head filename</p><p>实例：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230413112342.png"></p><p>与上同理，该命令会显示文件开头的行内容，默认情况下，会显示前10行的内容。该命令也支持参数 -n 。</p><p><strong>Tip：因为一般来说文件的开头不会轻易改变，head命令并不像tail命令一样支持参数 -f 。</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于在文件系统中切换目录以及处理文件和目录的基本知识到这里就结束了。下面就是正式开始脚本编程之前的最后准备–系统管理命令（如何通过命令行探查Linux系统的内部信息）。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学-数据类型</title>
      <link href="/2023/03/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/31/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型简介"><a href="#数据类型简介" class="headerlink" title="数据类型简介"></a>数据类型简介</h1><p>在上一篇博客中，已经结束了对于C语言最基本的了解，这篇我们来对关键字中的最为重要且最多的数据类型关键字，他们包括：int、short、long、unsigned、char、float、double、_ Bool、_ Complex、_ Imaginary。</p><p>每一个程序都离不开数据，我们把数字，字母和文字输入进电脑，希望电脑通过这些数据完成某些任务，我们要学会怎么读取数据以及如何操控数据。</p><p>C语言提供两大系列的数据类型：整数类型and浮点数类型。</p><p><strong>Tip：以上关键字大都可以分为这两个类型 。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230331131221.png"></p><p>上述程序的功能是将体重转换为白金价值，其中，我们一改往日的变量定义，在本例中使用了浮点型的float变量，用于处理更大范围的数据，float类型可以储存带小数的数字。</p><h1 id="变量与常量数据"><a href="#变量与常量数据" class="headerlink" title="变量与常量数据"></a>变量与常量数据</h1><p>在一个程序运行过程中没有发生变化的，称之为常量（constant），那么在程序运行过程中可能会被改变或者被赋值的，则称之为变量（variable)。</p><p>在上述程序中，weight就是一个变量，14.5833是一个常量。</p><h1 id="数据类型关键字"><a href="#数据类型关键字" class="headerlink" title="数据类型关键字"></a>数据类型关键字</h1><p>当然不仅是变量与常量不同，不同的数据类型之间也有差异，一些数据类型表示数字，一些数据类型表示字母。如果数据是常量，编译器一般通过程序中的书写形式来识别；但是对于变量而言，我们在程序的开头就要指定它的类型，下图是C语言中的数据类型关键字：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230331140122.png"></p><p>其中，int关键字用来表示基本的整数类型，long、short、unsigned三个关键字，包括新增的signed用于提供整数类型的变式，unsigned short int等；char关键字用于指定字母和其他字符（#￥%*），char类型也可以表示较小的整数；float、double、long double表示带小数点的数；_ Bool类型表示布尔值（true or false）， _ Complex 表示复数， _ Imaginary 表示虚数。</p><p><strong>Tip：位、字节和字是指计算机数据单元或者存储单元的术语：</strong></p><p><strong>位（bit）：可以储存0或1，是构建计算机内存的基本模块。</strong></p><p><strong>字节（byte）：对于几乎所有机器，1字节均为8位，这是字节的标准定义。</strong></p><p><strong>字（word）：是设计计算机时给定的自然存储单位，会随着计算机的进步而进步，现在基本都是64位。</strong></p><h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>整数：与数学的概念一样，在C语言中，整数是没有小数部分的数，我们需要做的是把十进制的数转换到计算机中的二进制，在8位字节中储存该数字，例如7在二进制中就是00000111。</p><p>浮点数：与数学中的实数概念差不多，注意，在一个值后面加上一个小数点，该值就变成一个浮点值了。所以，7是整数，7.00就是浮点数了。显而易见，书写浮点数的方式有很多种，我们主要学习e记数法。</p><p>3.16E7表示的是3.16*10^7，7是10的指数。计算机中把浮点数分成小数部分和指数部分来表示，并且分开存储。</p><p>我们主要需要理解浮点数和整数的储存方案的不同。</p><h1 id="C语言基本数据类型"><a href="#C语言基本数据类型" class="headerlink" title="C语言基本数据类型"></a>C语言基本数据类型</h1><h2 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h2><p>C语言中提供了许多的整数类型，为的是方便程序员针对不同的情况选择不同的类型。特别是，C语言中的整数类型可以表示不同的取值范围和正负值，一般大部分情况使用int类型即可。</p><p>int类型是有符号整型，其值必须为正负整数或零，一般而言，一个int类型需要占用一个机器字长。早期的16位IBM机一般使用16位来储存一个int值，取值范围（-32768-32767）。现在的个人计算机已经发展到了64位，不过ISO C 规定int的取值范围最小为-32768-32767。</p><p><strong>Tip：若是占据16位，为什么不是（-65536-65535），因为一般来说，系统会用首位表示有符号整数的正负号。</strong></p><p>声明int变量在此就不再赘述了，以上已经使用很多了。那么在定义了变量之后，就要对其提供对应的值，变量获取值的方法：第一种就是赋值，利用 &#x3D; 即可；第二种途径是通过函数来获得值（scanf（）等函数），最重要的就是第三种方法：初始化变量！</p><p>初始化变量就是在定义变量的同时就赋予一个初始值，在int 语句后加上一个 &#x3D; 和对应的值即可。</p><p>简单来说，声明变量就是给变量创建和标记存储空间，并为其指定初始值。</p><p>int的常量就比较简单了，一般来说不带小数点的就是int型常量；之后还有long常量和long long常量。</p><p><strong>Tip：最好在初始化时不要把初始化的变量和未初始化的变量放在同一条声明中。</strong></p><p>printf（）函数可以打印int类型的值，%d表明了在一行里打印整数的位置，%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。</p><h3 id="八进制与十六进制"><a href="#八进制与十六进制" class="headerlink" title="八进制与十六进制"></a>八进制与十六进制</h3><p>一般来说，C语言都是假定整型常量是一个十进制数。然而，由于底层是二进制作为基础，实际应用中还是使用八进制和十六进制数，因为8和16都2的幂，但是计算机是无法自行分别各个进制之间的区别的，在C语言中，用特定的前缀表示使用哪种进制。0x或0X前缀表示十六进制值，所以十进制数16表示成十六进制是0x10或0X10。与此类似，0前缀表示八进制。在之后的内容中会详细的讲述进制相关的内容。</p><p><strong>Tip：无论使用那种进制来表示，都不会影响数据的存储方式，因为计算机内部还是二进制进行编码。</strong></p><p>八进制与十六进制的显示：与%d用来显示十进制类似，以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。</p><p>**Tip：在C语言中，八进制和十六进制的常量属于无符号整型（unsigned int）。</p><h2 id="其他整数类型"><a href="#其他整数类型" class="headerlink" title="其他整数类型"></a>其他整数类型</h2><p>我们初学C语言时，int类型能够满足大多数程序的需求了，当然这小节内容为的是留一个印象。C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。</p><p>short int类型（或者简写为short）：占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。short类型属于有符号类型。</p><p>long int类型（long）：占用的存储空间可能比int多，适用于较大数值的场合。long也属于有符号类型。</p><p>long long int或long long（C99标准加入）：占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。</p><p>unsigned int或unsigned：只用于非负值的场合。这种类型与有符号类型表示的范围不同。若是16位unsigned，取值范围则是0-65535。</p><p>声明方式：这些整数类型的声明方式与int类型并无任何不同。</p><p><strong>Tip：八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。</strong></p><p>本小节中我们值得注意的一个问题就是整数是否会溢出的问题。要对我们使用的机器的int类型的位数时刻注意。</p><p>短整型，长整型等的显示：打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。</p><p><strong>Tip：注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。</strong></p><h2 id="字符：char类型"><a href="#字符：char类型" class="headerlink" title="字符：char类型"></a>字符：char类型</h2><p>char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。现在使用最主流的编码系统就是ASCII码，在ASCII码中，整数65代表大写字母A。因此，储存字母A实际上储存的是整数65。</p><p>C语言把1字节（8位）定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。</p><p>声明方式：char类型变量的声明方式与其他类型变量的声明方式相同。</p><p>字符常量的书写方式：在C语言中，用单引号括起来的单个字符被称为字符常量，<strong>单引号必不可少，若是双引号则是字符串。</strong>也可以使用ASCII码中的对应数字来进行赋值（最好不要这样做）。</p><p>单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。比如像退格，换行，蜂鸣等，在C语言中提供了三种方法表示这些字符。</p><p>第一种就是利用数字代码的方式，定义蜂鸣字符的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> beep = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>第二种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列，如下表：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402114259.png"></p><p>最后两个转义序列（\0oo和\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\）并用单引号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beep = <span class="string">&#x27;\007&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上述代码等同于 \a;</p><p>十六进制就是将前缀从0改为x即可，记得带上单引号。</p><p>我们在使用数字和数字字符的时候需要注意，字符 ‘4’ 在ASCII码中是52，而不是数字4。</p><p><strong>Tip：无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。</strong></p><p>字符打印方式：printf()函数用%c指明待打印的字符，如果用%d转换说明打印 char类型变量的值，打印的是一个整数。下图清楚显示了数据的显示过程：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402120020.png"></p><h2 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h2><p>_ Bool类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。通常来说布尔类型只占用一位存储空间，在以后会对这个类型进行展开讲解。</p><h2 id="可移植类型：stdint-h和inttypes-h"><a href="#可移植类型：stdint-h和inttypes-h" class="headerlink" title="可移植类型：stdint.h和inttypes.h"></a>可移植类型：stdint.h和inttypes.h</h2><p>在C99标准中新增了两个头文件stdint.h和inttypes.h，以确保C语言的类型在各系统中的功能相同。在stdint.h头<br>文件中，int32_t表示32位有符号整数类型，在使用32位系统中，头文件会把int32_t作为int的别名，若是在16位的系统中，int32_t会被作为long的别名，使用stdint.h的头文件编写程序是为了方便在不同的系统进行匹配。</p><p>不过我们还可能碰到计算机底层系统不能匹配int32_t的情况。这个时候一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型，这组类型集合被称为最小宽度类型。如int_least8_t是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。若是系统最小的整数类型是16位也并不妨碍int_least8_t的使用。</p><p>仅作为了解。</p><h2 id="浮点型：float、double、long-double"><a href="#浮点型：float、double、long-double" class="headerlink" title="浮点型：float、double、long double"></a>浮点型：float、double、long double</h2><p>在C语言的标准中，float类型的必须至少能表示6位的有效数字，取值范围在10^-37~10^37。一般来说，浮点型通常要占用32位，其中8位用于指数部分的值和符号，剩余的24位是使用于非指数部分的值和符号。</p><p>另外一个浮点型double（双精度），double类型和float类型的最小取值范围相同，但是double必须能表示10位有效数字，一般情况下双精度占用的是64位，一些系统是将多余的32位均用于非指数的部分，从而达到更高的精度。</p><p>第三个浮点型long double是用于满足比double类型更高的精度要求，C语言中只保证long double和double的精度相同。</p><p>声明方式：同其他数据类型。</p><p>浮点型常量的书写方式：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。</p><p>2.87E3，-1.56E12等</p><p>正号可以省略。可以没有小数点或者指数部分，但是不能同时省略两者，可以省略小数部分或整数部分，但是不能同时省略两者。</p><p><strong>Tip：不要在浮点型常量中间加空格</strong></p><p>在默认情况下，浮点型常量是double类型的精度，若是在浮点数后面加上f或F的后缀即可覆盖默认的设置，加上l或L的话就是long double的类型。</p><p>在C99标准中还有一种新的浮点型常量的格式，用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂。</p><p>0xa.1fp10 &#x3D; 10364.0（了解）</p><p>浮点数的打印：printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La转换说明。</p><p>浮点数的上溢和下溢：上溢和整数类型的溢出原理基本类似，而下溢则是在计算过程中由于计算符导致有效数字丢失位置的情况。</p><p>下溢例子：以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。</p><h2 id="复数和虚数类型"><a href="#复数和虚数类型" class="headerlink" title="复数和虚数类型"></a>复数和虚数类型</h2><p>C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型float_Imaginary、double _Imaginary和long double _Imaginary。如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。</p><h2 id="类型大小"><a href="#类型大小" class="headerlink" title="类型大小"></a>类型大小</h2><p>sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。</p><p>下图是源码展示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402133219.png"></p><p>以下是输出结果：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230402133353.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是对C语言中数据类型的基本学习和介绍。 </p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行-文件与目录列表</title>
      <link href="/2023/03/26/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/"/>
      <url>/2023/03/26/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="文件与目录-ls命令"><a href="#文件与目录-ls命令" class="headerlink" title="文件与目录-ls命令"></a>文件与目录-ls命令</h1><p>上篇我们已经知道了如何遍历系统和验证当前的工作目录，接下来就可以开始探索各种目录中的文件了。</p><p>要想知道目录中有那些文件，可以使用列表命令（ls）。</p><p>ls命令最基本的形式会显示当前目录下的文件和目录，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326150508.png"></p><p>ls命令带上-F参数的ls命令轻松区分文件和目录。使用-F参数可以得到如下输出：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326150758.png"></p><p>基本的ls命令在某种意义上有点容易让人误解。它显示了当前目录下的文件和目录，但并没有将全部都显示出来。Linux经常采用隐藏文件来保存配置信息。在Linux上，隐藏文件通常是文件名以点号开始的文件。要把隐藏文件和普通文件及目录一起显示出来，就得用到-a参数。</p><p>ls命令中的-R参数是ls命令可用的另一个参数，叫作递归选项。它列出了当前目录下包含的子目录中的文件。如果目录很多，这个输出就会很长。如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326151353.png"></p><p><strong>Tip：输入参数时可以不用像图片中一样，ls -F -R，可以进行合并 ls -FR。</strong></p><p>在基本的输出列表中，ls命令并未输出太多每个文件的相关信息。要显示附加信息，另一个常用的参数是-l。-l参数会产生长列表格式的输出，包含了目录中每个文件的更多相关信息。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326151751.png"></p><p>在这些相关信息中主要分为以下这些：</p><p>文件类型，比如目录（d）、文件（-）、字符型文件（c）或块设备（b）；<br>文件的权限（参见第6章）；<br>文件的硬链接总数；<br>文件属主的用户名；<br>文件属组的组名；<br>文件的大小（以字节为单位）；<br>文件的上次修改时间；<br>文件名或目录名。</p><p><strong>Tip：在shell中输入man ls 可以查看ls命令的各种参数，man命令同样适用于其他指令。</strong></p><p>前面的例子可知，默认情况下，ls命令会输出目录下的所有非隐藏文件。有时这个输出会显得过多，当你只需要查看单个少数文件信息时更是如此。ls命令还支持在命令行中定义过滤器，它会用过滤器来决定应该在输出中显示哪些文件或目录。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326152853.png"></p><p>当用户指定特定文件的名称作为过滤器时，ls命令只会显示该文件的信息。有时你可能不知道要找的那个文件的确切名称。ls命令能够识别标准通配符，并在过滤器中用它们进行模式匹配：<br>问号（?）代表一个字符；<br>星号（*）代表零个或多个字符。<br>问号可用于过滤器字符串中替代任意位置的单个字符。</p><p>在过滤器中使用星号和问号被称为文件扩展匹配（file globbing），指的是使用通配符进行模式匹配的过程。通配符正式的名称叫作元字符通配符（metacharacter wildcards）。除了星号和问号之外，还有更多的元字符通配符可用于文件扩展匹配。可以使用中括号。下面是中括号的两种用法：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326153254.png"></p><p>另外，可以使用感叹号（!）将不需要的内容排除在外。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326154001.png"></p><p><strong>Tip：在使用 (!) 时，也需要在外面加上中括号。</strong></p><h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><h2 id="创建文件-touch命令"><a href="#创建文件-touch命令" class="headerlink" title="创建文件-touch命令"></a>创建文件-touch命令</h2><p>我们在学习的过程时不时会遇到创建空文件的情况，这时可以使用touch命令创建空文件，注意文件的大小是0。而且touch命令还可以用来改变文件的修改时间，这个操作并不会改变文件的内容。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230326155341.png"></p><p>那么touch命令与mkdir命令的区别在什么地方？</p><p>touch命令：</p><p>语法：touch [options] filename<br>           -a：改变访问时间<br>           -m：改变改动时间<br>           -t timestamp：改变访问时间和改动时间为timestamp</p><p>mkdir命令：</p><p>语法：mkdir [options] dirname<br>           -p：递归创建文件夹<br>           -mmode：新建文件夹，并设置文件夹的文件访问模式为mode</p><p>总结来说，一个是创建文件，一个是创建文件夹。</p><h2 id="复制文件-cp命令"><a href="#复制文件-cp命令" class="headerlink" title="复制文件-cp命令"></a>复制文件-cp命令</h2><p>在最基本的用法里，cp命令需要两个参数——源对象和目标对象：<br>cp source destination<br>当source和destination参数都是文件名时，cp命令将源文件复制成一个新文件，并且以destination命名。新文件就像全新的文件一样，有新的修改时间。</p><p><strong>Tip：如果目标文件已经存在，cp命令可能并不会提醒这一点。最好是加上-i选项，强制shell询问是否需要覆盖已有文件。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327131534.png"></p><p>另外，cp命令的-R参数威力强大。可以用它在一条命令中递归地复制整个目录的内容。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327131921.png"></p><p><strong>Tip：cp命令中也可以使用通配符，除了单点符和通配符之外，还可以使用shell的另一特性，那就是制表键自动补全。</strong></p><h2 id="制表键自动补全"><a href="#制表键自动补全" class="headerlink" title="制表键自动补全"></a>制表键自动补全</h2><p>在我们日常使用命令行时，由于繁多且复杂，很容易输错命令、目录名和文件名，这正是制表键自动补全挺身而出的时候。制表键自动补全允许你在输入文件名或目录名时按一下制表键，让shell帮忙将内容补充完整。</p><p><strong>Tip：使用制表键自动补全的的技巧在于要给shell足够的文件名信息，使其能够将需要文件同其他<br>文件区分开。假如有另一个文件名也是以really开头，那么就算按了制表键，也无法完成文件名<br>的自动补全。这时候你会听到嘟的一声。要是再按一下制表键，shell就会列出所有以really开头的<br>文件名。这个特性可以让你观察究竟应该输入哪些内容才能完成自动补全。</strong></p><h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>链接文件是Linux文件系统的一个优势。如需要在系统上维护同一文件的两份或多份副本，除了保存多份单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。这种虚拟的副本就称为链接。链接是目录中指向文件真实位置的占位符。在Linux中有两种不同类型的文件链接：<br><strong>符号链接：ln -s filename</strong><br><strong>硬链接：ln filename</strong></p><p>符号链接就是一个实实在在的文件，它指向存放在虚拟目录结构中某个地方的另一个文件。这两个通过符号链接在一起的文件，彼此的内容并不相同。</p><p>硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们从根本上而言是同一个文件。</p><p>符号链接类似于C语言的指针！若是想要验证是否为不同的文件，可以使用 ls -i 命令查看incode编号。</p><p><strong>Tip：复制链接文件的时候，产生的是源文件的副本，容易弄混乱，不如创建源文件的另一个链接，一个源文件可以有多个链接，千万不要创建软链接的软链接，容易造成断裂。</strong></p><h2 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h2><p>在Linux中，重命名文件称为移动。mv命令可以将文件和目录移动到另一个位置或重新命名。</p><p>​                               <img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327134310.png"></p><p><strong>Tip：移动文件会将文件名进行更改，但inode编号和时间戳保持不变。这是因为mv只影响文件名。</strong></p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230327135136.png"></p><p>我们可以看到在重命名目录之后，原来的目录名已经不存在了。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Linux中，删除（deleting）叫作移除（removing）。bash shell中删除文件的命令是rm。rm命令的基本格式非常简单。</p><p><strong>rm -i filename</strong></p><p><strong>Tip：-i命令参数提示你是不是要真的删除该文件。ubuntu中虽然有回收站或垃圾箱，但是，在使用rm命令时，我们仍要养成总是加入-i参数的好习惯。</strong></p><p>rm命令的另外一个特性是，如果要删除很多文件且不受提示符的打扰，可以用-f参数强制删除。</p><p>下篇将介绍mkdir命令的使用场景–目录。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言浅学</title>
      <link href="/2023/03/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6/"/>
      <url>/2023/03/23/C%E8%AF%AD%E8%A8%80%E6%B5%85%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="多个函数"><a href="#多个函数" class="headerlink" title="多个函数"></a>多个函数</h1><p>截至目前，所有的程序都只使用了printf（）函数。接下来我们来演示如何把自己的函数加入程序中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* two_func.c -- 一个文件中包含两个函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">butler</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">/* C函数原型 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I will summon the butler function.\n&quot;</span>);</span><br><span class="line">butler();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes. Bring me some tea and writeable DVDs.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">butler</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">/* 函数定义的开始 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You rang, sir?\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>butler()函数在程序中出现了3次。第1次是函数原型（prototype），告知编译器在程序中要使用该函数；第 2 次以函数调用（function call）的形式出现在 main()中；最后一次出现在函数定义（function definition）中，函数定义即是函数本身的源代码。</p><p>在 main()中调用 butler()很简单，写出函数名和圆括号即可。当butler()执行完毕后，程序会继续执行main()中的下一条语句。</p><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><p>在我们自己编写程序的过程中，会因为粗心大意犯一些错误，程序的错误通常叫做 bug，找出并修正错误的过程叫做调试（debug）。</p><p>通常来说程序的错误主要集中在三个方面：语法错误，语义错误，程序状态。</p><p>语法错误：C语言的语法错误指的是，把有效的C符号放在错误的地方。</p><p>语义错误：在C语言中，如果遵循了C规则，但是结果不正确，那就是犯了语义错误。</p><p>Tip：编译器无法检测语义错误，因为这类错误并未违反 C语言的规则。</p><p>程序状态：程序状态是在程序的执行过程中，某给定点上所有变量值的集合。它是计算机当前状态的一个快照。</p><h1 id="关键字和保留标识符"><a href="#关键字和保留标识符" class="headerlink" title="关键字和保留标识符"></a>关键字和保留标识符</h1><p>关键字是C语言的词汇。它们对C而言比较特殊，不能用它们作为标识符（如，变量名）。许多关键字用于指定不同的类型，如 int。还有一些关键字（如，if）用于控制程序中语句的执行顺序。如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230323141935.png"></p><p>保留标识符包括那些以下划线字符开头的标识符和标准库函数名，如printf（）。</p><p>对C语言的了解在此篇结束，接下来开始学习C语言中的数据类型。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言回顾</title>
      <link href="/2023/03/18/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/"/>
      <url>/2023/03/18/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言初识"><a href="#C语言初识" class="headerlink" title="C语言初识"></a>C语言初识</h1><p>C语言属于编译型语言，所以编写C程序的过程大致可以分为7个步骤：</p><ol><li>定义程序目标</li><li>设计程序</li><li>编写代码</li><li>编译</li><li>运行程序</li><li>测试和调试程序</li><li>维护和修改程序</li></ol><p>在理想状态下，完成7个步骤即可，但在一些大型项目中，需要我们做一些重复的工作。7个步骤中，我认为最重要的是1，2两个步骤，当我们接到一个项目时，无论简单与否，不是拿起电脑就开始敲代码，而是应该确定我们这个项目的目标，这样我们才能将心无旁骛地前进；而设计程序是为了扫除项目中无关紧要的细枝末节，使得程序最大程度上得到精简。</p><p>完成以上的工作之后，我们就可以开始编写代码了，以我们最常见的Hello world.c为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是编译的过程，编者主要使用Linux系统编写的C程序，有关编译过程可以找博客中关于命令行的编译知识。在编译过程中，编译器会检查C程序是否有效，如果发现错误，那么编译器会报告相应的错误，理解报错也是我们应当掌握的技能。</p><p>第5-7步就是得出结果和维护的过程，C程序是以能否运行为首要前提，而在此之后，我们就要对自己写的程序进行不断优化，编者相信不管什么时候都要抱有一颗学徒的心，为了使程序变得更好，剩下的步骤显得格外珍贵。</p><h1 id="C语言概述"><a href="#C语言概述" class="headerlink" title="C语言概述"></a>C语言概述</h1><p>一般来说，C程序是以.c作为文件的扩展名，以满足当前系统对文件名的要求，下面是一个简单的C程序，分块查看一个程序包含那些部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>                           <span class="comment">/* 一个简单的C程序 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;                             <span class="comment">/* 定义一个名为num的变量 */</span></span><br><span class="line">num = <span class="number">1</span>;                             <span class="comment">/* 为num赋一个值 */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am a simple&quot;</span>);             <span class="comment">/* 使用printf()函数 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;computer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;My favorite number is d% because it is first.\n&quot;</span>,num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对任意一个C程序，我们都可以对它进行拆解，如下图所示：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230319153816.png"></p><p>头文件和include指令本质就是在程序执行前将准备工作做完，无需赘述。</p><p>main()函数，C程序一般都是从main()函数开始执行，因为该例中没有传递任何信息，因此圆括号内是void。</p><p>&#x2F;* ………….. *&#x2F; 是程序的注释，并不会执行，写注释可以让看程序者更容易明白程序要表达的意思。</p><p>{</p><p>…</p><p>} 是标记函数体的开始和结束。</p><p>int num 表示对num这个变量进行声明，说明num是一个整数变量。</p><p>数据类型包括整数、字符和浮点数等，变量声明是一个程序的必要步骤，命名只能是字母、数字和下划线，且第一个字符必须是字母或者下划线。</p><p>\n 是换行的意思，换行符是转义序列，例如 \t 表示Tab键，\b 表示Backspace键，每一个转义序列都是以反斜()开始，以后再来细说。</p><p>d% 是一个占位符，作用是指明num值输出的位置，在语句最后要将num加上。</p><p>return 0 就是程序的结尾。</p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令行初识</title>
      <link href="/2023/03/17/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/2023/03/17/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux命令行"><a href="#Linux命令行" class="headerlink" title="Linux命令行"></a>Linux命令行</h1><p>linux系统使用时有别于windows系统，没有完美的图形界面，所以命令行成为了使用linux系统的基础。</p><p>Tips：linux系统在使用时一般使用正斜线（&#x2F;），而不是反斜线（\），linux中反斜线表示转义字符。</p><p>首先是进入控制台使用的快捷键：Ctrl+Alt+t：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230317133117.png"></p><p>进入控制台后我们就可以开始学习命令行了。</p><p>正如window中一样，我们首先要知道怎么打开一个文件夹，在linux中使用的cd命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$cd /home                     进入名为home的目录</span><br></pre></td></tr></table></figure><p>cd命令的参数可以用两种方法表示：一种是使用绝对文件路径，另一种是使用相对文件路径。</p><p>绝对文件路径较为简单，同windows理，在执行上述代码后，~会变成&#x2F;home，这时就处于home的目录下了。若是没有配置好提示符来显示当前shell会话的绝对文件路径，可以使用pwd命令显示出来，如下图。</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317142148.png"></p><p>相对文件路径是允许用户指定一个基于当前位置的目标文件路径。相对文件路径不以代表根目录的正斜线（&#x2F;）开头，而是以目录名或是一个特殊字符开始。假如位于home目录中，并希望切换到代码子目录，那么可以使用cd命令加上一个相对文件路径：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317142732.png"></p><p>上图并没有使用正斜线（&#x2F;），而是采用了相对文件路径将大大减少输入内容。</p><p>另有两个特殊字符可用于相对文件路径中</p><p>单点符（.），表示当前目录；</p><p>双点符（..），表示当前目录的父目录。</p><p>双点符在目录层级的移动时非常便利，如下图：</p><p><img src="https://raw.githubusercontent.com/Dongzh0915/Picture/main/E%3A%5Chexo%5Cblog%5Csource%5Cimg20230317143139.png"></p><p>从home目录下的代码文件夹移动到视频文件夹。</p>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/18/hello-world/"/>
      <url>/2022/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
